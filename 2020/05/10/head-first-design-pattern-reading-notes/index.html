<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>《Head First 设计模式》读书笔记 | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《Head First 设计模式》读书笔记</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/readings/"><i class="fa fa-book"> 阅读</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《Head First 设计模式》读书笔记</h1><div class="post-meta">May 10, 2020<span> | </span><span class="category"><a href="/categories/读书笔记/">读书笔记</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 7</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-设计模式入门"><span class="toc-number">1.</span> <span class="toc-text">第一章 设计模式入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-观察者模式"><span class="toc-number">2.</span> <span class="toc-text">第二章 观察者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-装饰者模式"><span class="toc-number">3.</span> <span class="toc-text">第三章 装饰者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-工厂模式"><span class="toc-number">4.</span> <span class="toc-text">第四章 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单工厂"><span class="toc-number">4.1.</span> <span class="toc-text">简单工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法"><span class="toc-number">4.2.</span> <span class="toc-text">工厂方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象工厂"><span class="toc-number">4.3.</span> <span class="toc-text">抽象工厂</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-单件模式"><span class="toc-number">5.</span> <span class="toc-text">第五章 单件模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-命令模式"><span class="toc-number">6.</span> <span class="toc-text">第六章 命令模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-适配器模式和外观模式"><span class="toc-number">7.</span> <span class="toc-text">第七章 适配器模式和外观模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-模板方法模式"><span class="toc-number">8.</span> <span class="toc-text">第八章 模板方法模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-迭代器与组合模式"><span class="toc-number">9.</span> <span class="toc-text">第九章 迭代器与组合模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">10.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料-1"><span class="toc-number">11.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><h1 id="第一章-设计模式入门"><a href="#第一章-设计模式入门" class="headerlink" title="第一章 设计模式入门"></a>第一章 设计模式入门</h1><blockquote>
<p>使用模式最好的方式是：”把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”</p>
</blockquote>
<p>通过一个给 Duck 类型添加 fly 功能的实例，一步步地提出解决方案。</p>
<p>先是使用继承，但是继承并不能很好地解决问题，因为鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当的。</p>
<p>接着又提出使用接口，但是 Java 接口不具有实现代码，所以继承接口无法达到代码的复用。这意味着: 无论何时你需要修改某个行为，你必须得往下追踪并在每一个定义此行为的类中修改它，一不小心，可能会造成新的错误!</p>
<p>进而提出了第一个设计原则：</p>
<blockquote>
<p>设计原则一：封装变化。找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
</blockquote>
<p>这样的概念很简单，几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510222131.png" alt="取出易于变化的部分"></p>
<blockquote>
<p>设计原则二：针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510223436.png" alt="接口和对应的类"></p>
<p>关键在于，鸭子现在会将飞行和呱呱叫的动作“委托”(delegate)别人处理，而不是使用定义在 Duck 类(或子类)内的呱呱叫和飞行方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510224745.png" alt="整合鸭子的行为"></p>
<blockquote>
<p>设计原则三：多用组合，少用继承。</p>
</blockquote>
<h1 id="第二章-观察者模式"><a href="#第二章-观察者模式" class="headerlink" title="第二章 观察者模式"></a>第二章 观察者模式</h1><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103228.png" alt="观察者模式"></p>
<blockquote>
<p>定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
</blockquote>
<p>类图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103804.png" alt="类图"></p>
<blockquote>
<p>设计原则四：为了交互对象之间的松耦合设计而努力。</p>
</blockquote>
<p>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p>
<h1 id="第三章-装饰者模式"><a href="#第三章-装饰者模式" class="headerlink" title="第三章 装饰者模式"></a>第三章 装饰者模式</h1><blockquote>
<p>设计原则五：类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>怎么理解呢？允许系统在不修改代码的情况下，进行功能扩展。想想观察者模式（在第 2 章）……通过加入新的观察者，我们可以在任何时候扩展 Subject（主题），而且不需向主题中添加代码。</p>
<blockquote>
<p>要让 OO 设计同时具备开放性和关闭性，又不修改现有的代码，需要花费许多时间和努力。一般来说，我们实在没有闲工夫把设计的每个部分都这么设计（而且，就算做得到， 也可能只是一种浪费）。遵循<code>开放-关闭</code>原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用<code>开放-关闭</code>原则。</p>
</blockquote>
<blockquote>
<p>定义：装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
</blockquote>
<p>类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516112728.png" alt="类图"></p>
<h1 id="第四章-工厂模式"><a href="#第四章-工厂模式" class="headerlink" title="第四章 工厂模式"></a>第四章 工厂模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂并不是一个设计模式，它是一个编程习惯。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525114337.png" alt="简单工厂类图"></p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码和子类对象创建代码解耦了。</p>
<p>通过让子类决定该创建的对象是什么，来达到将对象的创建过程封装的目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115100.png" alt="工厂方法 —— pizza"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115941.png" alt="工厂方法类图 —— pizza"></p>
<p>创建者类和产品类可以放平：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120204.png" alt="平行的类层级"></p>
<blockquote>
<p>定义：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
</blockquote>
<p>注意，上面的“决定”并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120706.png" alt="工厂方法类图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525121832.png" alt="简单工厂和工厂方法的工区别"></p>
<blockquote>
<p>设计原则：依赖倒置原则。要依赖抽象，不要依赖具体类。</p>
</blockquote>
<p>不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。倒置是指和一般 OO 设计的思考方式完全相反。低层组件现在依赖高层的抽象，而高层组件现在也在依赖相同的抽象。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote>
<p>定义：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125846.png" alt="抽象工厂类图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125943.png" alt="抽象工厂类图 —— pizza"></p>
<h1 id="第五章-单件模式"><a href="#第五章-单件模式" class="headerlink" title="第五章 单件模式"></a>第五章 单件模式</h1><p>也就是我们常说的单例模式，有些对象只能有一个实例，例如线程池、数据库连接等。全局变量也可以做到这一点，但全局变量必须一开始就要创建好对象，如果一直没用到，就形成浪费了。</p>
<blockquote>
<p>定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。</p>
</blockquote>
<p>应对多线程，有三种应对方法：</p>
<ol>
<li>直接加同步原语，在 Java 中是 synchronized。很简单，可能会有一些性能问题。</li>
<li>使用饿汉式，启动时即创建。</li>
<li>用双重加锁检查，即 double-checked locking。</li>
</ol>
<p>用 Go 来实现，非常简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton 是单例模式类</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetInstance 用于获取单例模式对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章-命令模式"><a href="#第六章-命令模式" class="headerlink" title="第六章 命令模式"></a>第六章 命令模式</h1><blockquote>
<p>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作。</p>
</blockquote>
<p>命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。</p>
<h1 id="第七章-适配器模式和外观模式"><a href="#第七章-适配器模式和外观模式" class="headerlink" title="第七章 适配器模式和外观模式"></a>第七章 适配器模式和外观模式</h1><p>这两个模式比较简单，工作中也用得比较多，只是叫不出名字。</p>
<blockquote>
<p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
</blockquote>
<p>有对象适配器和类适配器两类，前者使用组合，后者使用多重继承。后者的好处是不用实现目标类的所有方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123621.png" alt="对象适配器、类适配器"></p>
<blockquote>
<p>外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
</blockquote>
<p>两者的区别：只能从意图上来区别。适配器的意图是将接口转换成不同接口；而外观模式的意图是简化接口。另外需要注意的是：虽然大多数教科书所采用的例子中适配器只适配一个类，但是实际上适配器模式也可以将多个类接口转换成客户希望的一个接口。</p>
<blockquote>
<p>设计原则七：最少知识原则。只和你的密友谈话。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123757.png" alt="外观模式"></p>
<h1 id="第八章-模板方法模式"><a href="#第八章-模板方法模式" class="headerlink" title="第八章 模板方法模式"></a>第八章 模板方法模式</h1><p>很多模式之前或多或少地用过，像这一章的模板方法模式，去年在重构热力图的时候就用到过。当然，那时并不知道有这么个名字，只是很自然地一个想法。所有很多东西还是最后要上升到理论层次，就感觉不一样了。</p>
<blockquote>
<p>定义：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<p>因为 Golang 不提供继承机制，需要使用匿名组合模拟实现继承。</p>
<p>此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。</p>
<h1 id="第九章-迭代器与组合模式"><a href="#第九章-迭代器与组合模式" class="headerlink" title="第九章 迭代器与组合模式"></a>第九章 迭代器与组合模式</h1><blockquote>
<p>定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
</blockquote>
<blockquote>
<p>定义：组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p>
</blockquote>
<p>组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【读书会】<a href="https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE" target="_blank" rel="noopener">https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE</a></p>
<p>【设计模式中文网站】<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p>
<p>【Go 设计模式】<a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></p>
<h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><p>【读书会】<a href="https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE" target="_blank" rel="noopener">https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE</a></p>
<p>【设计模式中文网站】<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p>
<p>【Go 设计模式】<a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/05/10/head-first-design-pattern-reading-notes/">https://qcrao.com/2020/05/10/head-first-design-pattern-reading-notes/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/设计模式/">设计模式</a></div><div class="post-nav"><a class="next" href="/2020/05/06/dive-into-go-sync-map/">深度解密Go语言之sync.map</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/故障排查/" style="font-size: 15px;">故障排查</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/head-first-design-pattern-reading-notes/">《Head First 设计模式》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/dive-into-go-sync-map/">深度解密Go语言之sync.map</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/codec-accident/">“���”引发的线上事故</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/dive-into-go-sync-pool/">深度解密Go语言之sync.pool</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/talk-about-g0/">聊聊 g0</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/how-to-traverse-defer-links/">defer 链表如何被遍历执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/high-performance-mysql-reading-notes/">《高性能 MySQL》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/dive-into-go-pprof/">深度解密Go语言之pprof</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/18/golang-error-break-through/">Golang error 的突围</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/dive-into-go-scheduler-source-code/">深度解密调度器源码系列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="Panda - Just for fun" target="_blank">Panda - Just for fun</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">170k</span><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 鄂ICP备20006251号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>