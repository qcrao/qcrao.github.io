<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>defer 链表如何被遍历执行 | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">defer 链表如何被遍历执行</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/readings/"><i class="fa fa-book"> 阅读</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">defer 链表如何被遍历执行</h1><div class="post-meta">Mar 23, 2020<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">1.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>去年开始写文章的第一篇就是关于 defer，名字比较文艺：<a href="https://mp.weixin.qq.com/s/txj7jQNki_8zIArb9kSHeg" target="_blank" rel="noopener">《Golang 之轻松化解 defer 的温柔陷阱》</a>，还被吐槽了。因为这篇文章，到《Go 夜读》讲了一期。不过当时纯粹是应用层面的，也还没有跳进 Go 源码这个大坑，文章看着比较清新，也没有大段的源码解析。</p>
<p>自从听了曹大在《Go 夜读》分享的 Go 汇编，以及研读了阿波张的 Go 调度器源码分析的文章后，各种源码、汇编满天飞……</p>
<p>上次欧神写了一篇<a href="https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q" target="_blank" rel="noopener">《Go GC 20 问》</a>，全文也没有一行源码，整体读下来很畅快。今天这篇也来尝试一下这种写法，不过，我们先从一个小的主题开始：defer 链表是如何被遍历并执行的。</p>
<p>关于 defer 的源码分析文章，网络上也有很多。不过，很少有能完全说明白这个话题的，除了阿波张的。</p>
<p>我们知道，为了在退出函数前执行一些资源清理的操作，例如关闭文件、释放连接等。会在函数里写上多个 defer 语句，被 defered 的函数，以“先进后出”的顺序，在 <code>RET</code> 指令前得以执行。</p>
<p>在一条函数调用链中，多个函数中会出现多个 defer 语句。例如：<code>a() -&gt; b() -&gt; c()</code> 中，每个函数里都有 defer 语句，而这些 defer 语句会创建对应个数的 <code>_defer</code> 结构体，这些结构体以链表的形式挂在 <code>goroutine</code> 结构体下。看起来像这样：</p>
<p><img src="/2020/03/23/how-to-traverse-defer-links/1.png" alt="defer 挂在 g 上"></p>
<p>在编译器的加持下，defer 语句会先调用 deferporc 函数，new 一个 <code>_defer</code> 结构体，挂到 g 上。当然，这里的 new 会优先从当前绑定的 P 的 defer pool 里取，没取到会去全局的 defer pool 里取，实在没有的话就新建一个，很熟悉的套路。</p>
<p>这样做好之后，等待函数体执行完，在 RET 指令之前（注意不是 return 之前），调用 <code>deferreturn</code> 函数完成 <code>_defer</code> 链表的遍历，执行完这条链上所有被 <code>defered</code> 的函数（如关闭文件、释放连接等）。这里的问题是在 <code>deferreturn</code> 函数的最后，会使用 <code>jmpdefer</code> 跳转到之前被 defered 的函数，这时控制权转移到了用户自定义的函数。这只是执行了一个被 defered 的函数，这条链上其他的被 defered 的函数，该如何得到执行呢？</p>
<p>答案就是控制权会再次交给 runtime，并再次执行 deferreturn 函数，完成 defer 链表的遍历。那这一切是如何完成的呢？</p>
<p>这就要从 Go 汇编的栈帧说起了。先看一个汇编函数的声明：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br></pre></td></tr></table></figure>

<p>最后两个数字表示 gogo 函数的栈帧大小为 16B，即函数的局部变量和为调用子函数准备的参数和返回值需要 16B 的栈空间；参数和返回值的大小加起来是 8B。实际上 gogo 函数的声明是这样的：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func gogo(buf *gobuf)</span></span><br></pre></td></tr></table></figure>

<p>参数及返回值的大小是给调用者“看”的，调用者根据这个数字可以构造栈：准备好被调函数需要的参数及返回值。</p>
<p>典型的函数调用场景下参数布局图如下图：</p>
<p><img src="/2020/03/23/how-to-traverse-defer-links/2.png" alt="函数调用参数布局"></p>
<p>左图中，主调函数准备好调用子函数的参数及返回值，执行 <code>CALL</code> 指令，将返回地址压入栈顶，相当于执行了 <code>PUSH IP</code>，之后，将 BP 寄存器的值入栈，相当于执行了 <code>PUSH BP</code>，再 jmp 到被调函数。</p>
<p>图中 <code>return address</code> 表示子函数执行完毕后，返回到上层函数中调用子函数语句的下一条要执行的指令，它属于 caller 的栈帧。而调用者的 BP 则属于被调函数的栈帧。</p>
<p>子函数执行完毕后，执行 <code>RET</code> 指令：首先将子函数栈底部的值赋到 CPU 的 BP 寄存器中，于是 BP 指向上层函数的 BP；再将 <code>return address</code> 赋到 IP 寄存器中，这时 SP 回到左图所示的位置。相当于还原了整个调用子函数的现场，像是一切都没发生过；接着，CPU 继续执行 IP 寄存器里的下一条指令。</p>
<p>再回到 defer 上来，其实在构造 <code>_defer</code> 结构体的时候，需要将当前函数的 SP、被 defered 的函数指针保存到 <code>_defer</code> 结构体中。并且会将被 defered 的函数所需要的参数 copy 到 _defer 结构体相邻的位置。最终在调用被 defered 的函数的时候，用的就是这时被 copy 的值，相当于使用了它的一个快照，如果此参数不是指针或引用类型的话，会产生一些意料之外的 bug。</p>
<p>最后，在 deferreturn 函数里，这些被 defered 的函数得以执行，<code>_defer</code> 链表也会被逐渐“消耗”完。</p>
<p>使用一个阿波张<a href="https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g" target="_blank" rel="noopener">文章</a>中的例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Println(<span class="string">"sum:"</span> , c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> sum(a, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"a: %d, b: %d\n"</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    f(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完 <code>f</code> 函数时，最终会进入 deferreturn 函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">	d := gp._defer</span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Do nothing.</span></span><br><span class="line">	<span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz)) <span class="comment">// 移动参数</span></span><br><span class="line">	&#125;</span><br><span class="line">	fn := d.fn</span><br><span class="line">	d.fn = <span class="literal">nil</span></span><br><span class="line">	gp._defer = d.link</span><br><span class="line">	freedefer(d)</span><br><span class="line">	</span><br><span class="line">	_ = fn.fn</span><br><span class="line">	jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>免不了还是要看一下代码，不然的话很难讲清楚。</p>
<p>因为我们是在遍历 <code>_defer</code> 链表，所以得有一个终止的条件：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是当 _defer 链表为空的时候，终止遍历。在后面的代码里会看到，每执行完一个被 defered 的函数后，都会将 _defer 结构体从链表中删除并回收，所以 _defer 链表会越来越短。</p>
<p><code>switch</code> 语句里要做的就是准备好被 defered 的函数（例子中就是 sum 函数）所需要的 a，b 两个 int 型参数。参数从哪来呢？从 _defer 结构体相邻的位置，还记得吗，这是在 deferproc 函数里 copy 过去的。<code>deferArgs(d)</code> 返回的就是当时 copy 的目的地址。那现在要拷贝到哪去呢？答案是：<code>unsafe.Pointer(&amp;arg0)</code>。我们知道，arg0 是 deferreturn 函数的参数，我们又知道，在 Go 汇编中，一个函数的参数是由它的主调函数准备的。因此 arg0 的地址实际上就是它的上层函数（在这里就是 f 函数）的栈上放参数的位置。</p>
<p>函数的最后，通过 <code>jmpdefer</code> 跳转到被 defered 的 sum 函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br></pre></td></tr></table></figure>

<p>核心在于 jmpdefer 所做的事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16</span><br><span class="line">    MOVQ	fv+0(FP), DX	// fn // defer 的函数的地址</span><br><span class="line">    MOVQ	argp+8(FP), BX</span><br><span class="line">    LEAQ	-8(BX), SP	// caller sp after CALL</span><br><span class="line">    MOVQ	-8(SP), BP	// restore BP as if deferreturn returned (harmless if framepointers not in use)</span><br><span class="line">    SUBQ	$5, (SP)	// return to CALL again</span><br><span class="line">    MOVQ	0(DX), BX</span><br><span class="line">    JMP	BX	// but first run the deferred function</span><br></pre></td></tr></table></figure>

<p>首先将 sum 函数的地址放到 DX 寄存器中，最后通过 JMP 指令去执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	argp+8(FP), BX</span><br><span class="line">LEAQ	-8(BX), SP	// caller sp after CALL // 执行 CALL 指令后 f 函数的栈顶</span><br></pre></td></tr></table></figure>

<p>这两行实际上是调整了下当前 SP 寄存器的值，因为 argp+8(FP) 实际上是 jmpdefer 的第二个参数（它在 deferreturn 函数中），它指向 f 函数栈帧中的刚被 copy 过来的 sum 函数的参数。而 <code>-8(BX)</code> 就代表了 f 函数调用 deferreturn 的返回地址，实际上就是 deferreturn 函数的下一条指令地址。</p>
<p>接着，<code>MOVQ    -8(SP), BP</code> 这条指令则重置了 BP 寄存器，使它指向了 f 栈帧 的 BP。这样，SP、BP 寄存器回到了 f 函数调用 deferreturn 之前的状态：f 刚准备好调用 deferreturn 的参数，并且把返回值压栈了。相当于抛弃了 deferreturn 函数的栈帧，不过，确实也没什么用了。</p>
<p>接着 <code>SUBQ    $5, (SP)</code> 把返回地址减少了 5B，刚好是一个 CALL 指令的长度。什么意思？当执行完 deferreturn 函数之后，执行流程会返回到 <code>CALL deferreturn</code> 的下一条指令，将这个值减少 5B，也就又回到了 <code>CALL deferreturn</code> 指令，从而实现了“递归地”调用 deferreturn 函数的效果。当然，栈却不会在增长！</p>
<p><img src="/2020/03/23/how-to-traverse-defer-links/3.png" alt="执行 jmpdefer"></p>
<p><code>jmpdefer</code> 函数的最后会执行 sum 函数，看起来就像是 f 函数亲自调用 sum 函数一样，参数、返回值都是就绪的。</p>
<p>等到 sum 函数执行完，执行流程就会跳转到 <code>call deferreturn</code> 指令处重新进入 deferreturn 函数，遍历完所有的 _defer 结构体，执行完所有的被 defered 的函数，才真正执行完 deferretrun 函数。</p>
<p><img src="/2020/03/23/how-to-traverse-defer-links/4.png" alt="重新调用 deferreturn"></p>
<p>到这里，全文就结束了。我们可以看到，实现遍历 defer 链表的关键就是 jmpdefer 函数所做的一些“见不得人”的工作，将调用 deferreturn 函数的返回地址减少了 5 个字节，使得被 defered 的函数执行完后，又回到 <code>CALL deferreturn</code> 指令处，从而实现“递归地”调用 deferreturn 函数，完成 _defer 链表的遍历。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【阿波张 defer 源码分析】<a href="https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g</a></p>
<p>【阿波张 panic&amp;recover】<a href="https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw</a></p>
<p>【阿波张 defer 基础】<a href="https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw</a></p>
<p>【汇编分析】<a href="https://segmentfault.com/a/1190000019804120?utm_medium=referral&amp;utm_source=tuicool" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019804120?utm_medium=referral&amp;utm_source=tuicool</a></p>
<p>【曹大 Go 汇编分享】<a href="https://github.com/cch123/asmshare/blob/master/layout.md" target="_blank" rel="noopener">https://github.com/cch123/asmshare/blob/master/layout.md</a></p>
<p>【曹大 Go 汇编】<a href="https://xargin.com/plan9-assembly" target="_blank" rel="noopener">https://xargin.com/plan9-assembly</a></p>
<p>【曹大利用汇编写的 goid 获取】<a href="https://github.com/cch123/goroutineid" target="_blank" rel="noopener">https://github.com/cch123/goroutineid</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/03/23/how-to-traverse-defer-links/">https://qcrao.com/2020/03/23/how-to-traverse-defer-links/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2020/04/03/talk-about-g0/">聊聊 g0</a><a class="next" href="/2020/03/08/high-performance-mysql-reading-notes/">《高性能 MySQL》读书笔记</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/故障排查/" style="font-size: 15px;">故障排查</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/05/concurrency-in-go-reading-notes/">深度阅读之《Concurrency in Go》</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/07/linux-performance-reading-notes/">《Linux 性能优化》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/head-first-design-pattern-reading-notes/">《Head First 设计模式》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/dive-into-go-sync-map/">深度解密Go语言之sync.map</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/codec-accident/">“���”引发的线上事故</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/dive-into-go-sync-pool/">深度解密Go语言之sync.pool</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/talk-about-g0/">聊聊 g0</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/how-to-traverse-defer-links/">defer 链表如何被遍历执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/high-performance-mysql-reading-notes/">《高性能 MySQL》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/dive-into-go-pprof/">深度解密Go语言之pprof</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="Panda - Just for fun" target="_blank">Panda - Just for fun</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">180.3k</span><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 鄂ICP备20006251号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>