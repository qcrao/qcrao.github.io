<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Golang 之轻松化解 defer 的温柔陷阱 | qcrao 的博客</title><meta property="og:title" content="Golang 之轻松化解 defer 的温柔陷阱 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-02-12T11:08:00+08:00"><meta property="article:modified_time" content="2019-02-12T11:08:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="Golang 之轻松化解 defer 的温柔陷阱"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/how-to-keep-off-trap-of-defer/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Golang 之轻松化解 defer 的温柔陷阱</h1></header><date class="post-meta meta-date">2019年2月12日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><h1 id=什么是defer>什么是defer？</h1><p><code>defer</code>是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。</p><p><code>defer</code>语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。</p><p><code>defer</code>在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>f, _ <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Open</span>(<span style=color:#d14>&#34;defer.txt&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>defer</span> f.<span style=color:#900;font-weight:700>Close</span>()
</span></span></code></pre></div><p>注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断<code>f</code>是否为空，如果<code>f</code>为空，就不能调用<code>f.Close()</code>函数了，会直接panic的。</p><h1 id=为什么需要defer>为什么需要defer？</h1><p>程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。</p><p>但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供<code>defer</code>关键字，在打开资源语句的下一行，就可以直接用<code>defer</code>语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。</p><h1 id=怎样合理使用defer>怎样合理使用defer?</h1><p>defer的使用其实非常简单：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>f,err <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Open</span>(filename)
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#0086b3>panic</span>(err)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> f <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>defer</span> f.<span style=color:#900;font-weight:700>Close</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。</p><p>当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。</p><h1 id=defer进阶>defer进阶</h1><h2 id=defer的底层原理是什么>defer的底层原理是什么？</h2><p>我们先看一下官方对<code>defer</code>的解释：</p><blockquote><p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.</p></blockquote><p>翻译一下：每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的时候产生panic.</p><p>defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也说是说最先被定义的defer语句最后执行。先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。</p><p>在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。</p><p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。</p><p>举个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> whatever [<span style=color:#099>3</span>]<span style=color:#000;font-weight:700>struct</span>{}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> whatever {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() { 
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Println</span>(i) 
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#099>2</span>
</span></span><span style=display:flex><span><span style=color:#099>2</span>
</span></span><span style=display:flex><span><span style=color:#099>2</span>
</span></span></code></pre></div><p>defer后面跟的是一个闭包（后面会讲到），i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2.</p><p>有了上面的基础，我们来检验一下成果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> number <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (n number) <span style=color:#0086b3>print</span>()   { fmt.<span style=color:#900;font-weight:700>Println</span>(n) }
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (n <span style=color:#000;font-weight:700>*</span>number) <span style=color:#900;font-weight:700>pprint</span>() { fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#000;font-weight:700>*</span>n) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> n number
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> n.<span style=color:#0086b3>print</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> n.<span style=color:#900;font-weight:700>pprint</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() { n.<span style=color:#0086b3>print</span>() }()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() { n.<span style=color:#900;font-weight:700>pprint</span>() }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	n = <span style=color:#099>3</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#099>3</span>
</span></span><span style=display:flex><span><span style=color:#099>3</span>
</span></span><span style=display:flex><span><span style=color:#099>3</span>
</span></span><span style=display:flex><span><span style=color:#099>0</span>
</span></span></code></pre></div><p>第四个defer语句是闭包，引用外部函数的n, 最终结果是3;
第三个defer语句同第四个；
第二个defer语句，n是引用，最终求值是3.
第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0;</p><h2 id=利用defer原理>利用defer原理</h2><p>有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>mergeFile</span>() <span style=color:#458;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	f, _ <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Open</span>(<span style=color:#d14>&#34;file1.txt&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> f <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>(f io.Closer) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>:=</span> f.<span style=color:#900;font-weight:700>Close</span>(); err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>				fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;defer close file1.txt err %v\n&#34;</span>, err)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}(f)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// ……
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	f, _ = os.<span style=color:#900;font-weight:700>Open</span>(<span style=color:#d14>&#34;file2.txt&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> f <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>(f io.Closer) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>:=</span> f.<span style=color:#900;font-weight:700>Close</span>(); err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>				fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;defer close file2.txt err %v\n&#34;</span>, err)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}(f)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码中就用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，妙哉！可以想像一下如果不这样将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了，都是最后一个打开的文件。</p><p>不过在调用close()函数的时候，要注意一点：先判断调用主体是否为空，否则会panic. 比如上面的代码片段里，先判断<code>f</code>不为空，才会调用<code>Close()</code>函数，这样最安全。</p><h2 id=defer命令的拆解>defer命令的拆解</h2><p>如果defer像上面介绍地那样简单（其实也不简单啦），这个世界就完美了。事情总是没这么简单，defer用得不好，是会跳进很多坑的。</p><p>理解这些坑的关键是这条语句：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>return</span> xxx
</span></span></code></pre></div><p>上面这条语句经过编译之后，变成了三条指令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>1.</span> <span style=color:#a61717;background-color:#e3d2d2>返回值</span> <span style=color:#a61717;background-color:#e3d2d2>=</span> <span style=color:#900;font-weight:700>xxx</span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>2.</span> <span style=color:#a61717;background-color:#e3d2d2>调用</span><span style=color:#900;font-weight:700>defer函数</span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>3.</span> <span style=color:#a61717;background-color:#e3d2d2>空的</span><span style=color:#900;font-weight:700>return</span>
</span></span></code></pre></div><p>1,3步才是Return 语句真正的命令，第2步是defer定义的语句，这里可能会操作返回值。</p><p>下面我们来看两个例子，试着将return语句和defer语句拆解到正确的顺序。</p><p>第一个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f</span>() (r <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>     t <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>       t = t <span style=color:#000;font-weight:700>+</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>     }()
</span></span><span style=display:flex><span>     <span style=color:#000;font-weight:700>return</span> t
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>拆解后：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f</span>() (r <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>     t <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 1. 赋值指令
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     r = t
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     <span style=color:#000;font-weight:700>func</span>() {        
</span></span><span style=display:flex><span>         t = t <span style=color:#000;font-weight:700>+</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 3. 空的return指令
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     <span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里第二步没有操作返回值r, 因此，main函数中调用f()得到5.</p><p>第二个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f</span>() (r <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>(r <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>          r = r <span style=color:#000;font-weight:700>+</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>    }(r)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>拆解后：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f</span>() (r <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 1. 赋值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     r = <span style=color:#099>1</span>
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 2. 这里改的r是之前传值传进去的r，不会改变要返回的那个r值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     <span style=color:#000;font-weight:700>func</span>(r <span style=color:#458;font-weight:700>int</span>) { 
</span></span><span style=display:flex><span>          r = r <span style=color:#000;font-weight:700>+</span> <span style=color:#099>5</span>
</span></span><span style=display:flex><span>     }(r)
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     <span style=color:#998;font-style:italic>// 3. 空的return
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>     <span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因此，main函数中调用f()得到1.</p><h2 id=defer语句的参数>defer语句的参数</h2><p>defer语句表达式的值在定义时就已经确定了。下面展示三个函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f1</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> err <span style=color:#458;font-weight:700>error</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> fmt.<span style=color:#900;font-weight:700>Println</span>(err)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err = errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;defer error&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f2</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> err <span style=color:#458;font-weight:700>error</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Println</span>(err)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err = errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;defer error&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f3</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> err <span style=color:#458;font-weight:700>error</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>(err <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Println</span>(err)
</span></span><span style=display:flex><span>	}(err)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	err = errors.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;defer error&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>f1</span>()
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>f2</span>()
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>f3</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt;nil&gt;
</span></span><span style=display:flex><span>defer error
</span></span><span style=display:flex><span>&lt;nil&gt;
</span></span></code></pre></div><p>第1，3个函数是因为作为函数参数，定义的时候就会求值，定义的时候err变量的值都是nil, 所以最后打印的时候都是nil. 第2个函数的参数其实也是会在定义的时候求值，只不过，第2个例子中是一个闭包，它引用的变量err在执行的时候最终变成<code>defer error</code>了。关于闭包在本文后面有介绍。</p><p>第3个函数的错误还比较容易犯，在生产环境中，很容易写出这样的错误代码。最后defer语句没有起到作用。</p><h2 id=闭包是什么>闭包是什么？</h2><p>闭包是由函数及其相关引用环境组合而成的实体，即：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:teal>闭包</span><span style=color:#000;font-weight:700>=</span>函数+引用环境
</span></span></code></pre></div><p>一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。</p><p>有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。</p><p>举个简单的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> a = <span style=color:#900;font-weight:700>Accumulator</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>a</span>(<span style=color:#099>1</span>))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>a</span>(<span style=color:#099>10</span>))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>a</span>(<span style=color:#099>100</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;------------------------&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> b = <span style=color:#900;font-weight:700>Accumulator</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>b</span>(<span style=color:#099>1</span>))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>b</span>(<span style=color:#099>10</span>))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;%d\n&#34;</span>, <span style=color:#900;font-weight:700>b</span>(<span style=color:#099>100</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Accumulator</span>() <span style=color:#000;font-weight:700>func</span>(<span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> x <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>func</span>(delta <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;(%+v, %+v) - &#34;</span>, <span style=color:#000;font-weight:700>&amp;</span>x, x)
</span></span><span style=display:flex><span>		x <span style=color:#000;font-weight:700>+=</span> delta
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc420014070, 0<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>1</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc420014070, 1<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>11</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc420014070, 11<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>111</span>
</span></span><span style=display:flex><span>------------------------
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc4200140b8, 0<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>1</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc4200140b8, 1<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>11</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>0xc4200140b8, 11<span style=color:#000;font-weight:700>)</span> - <span style=color:#099>111</span>
</span></span></code></pre></div><p>闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。</p><h2 id=defer配合recover>defer配合recover</h2><p>Golang被诟病比较多的就是它的error, 经常是各种error满天飞。编程的时候总是会返回一个error，留给调用者处理。如果是那种致命的错误，比如程序执行初始化的时候出问题，直接panic掉，省得上线运行后出更大的问题。</p><p>但是有些时候，我们需要从异常中恢复。比如服务器程序遇到严重问题，产生了panic, 这时我们至少可以在程序崩溃前做一些“扫尾工作”，如关闭客户端的连接，防止客户端一直等待等等。</p><p>panic会停掉当前正在执行的程序，不只是当前协程。在这之前，它会有序地执行完当前协程defer列表里的语句，其它协程里挂的defer语句不作保证。因此，我们经常在defer里挂一个recover语句，防止程序直接挂掉，这起到了<code>try...catch</code>的效果。</p><p>注意，recover()函数只在defer的上下文中才有效（且只有通过在defer中用匿名函数调用才有效），直接调用的话，只会返回<code>nil</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;defer main&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> user = os.<span style=color:#900;font-weight:700>Getenv</span>(<span style=color:#d14>&#34;USER_&#34;</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;defer caller&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>recover</span>(); err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>				fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;recover success. err: &#34;</span>, err)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>defer</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>				fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;defer here&#34;</span>)
</span></span><span style=display:flex><span>			}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>if</span> user <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;&#34;</span> {
</span></span><span style=display:flex><span>				<span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;should set user env.&#34;</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// 此处不会执行
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;after panic&#34;</span>)
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	time.<span style=color:#900;font-weight:700>Sleep</span>(<span style=color:#099>100</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;end of main function&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的panic最终会被recover捕获到。这样的处理方式在一个http server的主流程常常会被用到。一次偶然的请求可能会触发某个bug, 这时用recover捕获panic, 稳住主流程，不影响其他请求。</p><p>程序员通过监控获知此次panic的发生，按时间点定位到日志相应位置，找到发生panic的原因，三下五除二，修复上线。一看四周，大家都埋头干自己的事，简直完美：偷偷修复了一个bug, 没有发现！嘿嘿！</p><h1 id=后记>后记</h1><p>defer非常好用，一般情况下不会有什么问题。但是只有深入理解了defer的原理才会避开它的温柔陷阱。掌握了它的原理后，就会写出易懂易维护的代码。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png><img class=mx-auto alt=QR src=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png></a></p><h1 id=参考资料>参考资料</h1><p>【defer那些事】 <a href=https://xiaozhou.net/something-about-defer-2014-05-25.html>https://xiaozhou.net/something-about-defer-2014-05-25.html</a></p><p>【defer代码案例】 <a href=https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html>https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></p><p>【闭包】 <a href=https://www.kancloud.cn/liupengjie/go/576456>https://www.kancloud.cn/liupengjie/go/576456</a></p><p>【闭包】 <a href=http://blog.51cto.com/speakingbaicai/1703229>http://blog.51cto.com/speakingbaicai/1703229</a></p><p>【闭包】 <a href=https://blog.csdn.net/zhangzhebjut/article/details/25181151>https://blog.csdn.net/zhangzhebjut/article/details/25181151</a></p><p>【延迟】 <a href=http://liyangliang.me/posts/2014/12/defer-in-golang/>http://liyangliang.me/posts/2014/12/defer-in-golang/</a></p><p>【defer三条原则】 <a href=https://leokongwq.github.io/2016/10/15/golang-defer.html>https://leokongwq.github.io/2016/10/15/golang-defer.html</a></p><p>【defer代码例子】 <a href=https://juejin.im/post/5b948b3e6fb9a05d3827beda>https://juejin.im/post/5b948b3e6fb9a05d3827beda</a></p><p>【defer panic】 <a href=https://ieevee.com/tech/2017/11/23/go-panic.html>https://ieevee.com/tech/2017/11/23/go-panic.html</a></p><p>【defer panic】 <a href=https://zhuanlan.zhihu.com/p/33743255>https://zhuanlan.zhihu.com/p/33743255</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/how-to-keep-off-trap-of-defer/>https://qcrao.com/post/how-to-keep-off-trap-of-defer/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>