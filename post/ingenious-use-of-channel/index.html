<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Go channel 的妙用 | qcrao 的博客</title><meta property="og:title" content="Go channel 的妙用 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-02-04T22:02:17+08:00"><meta property="article:modified_time" content="2021-02-04T22:02:17+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="Go channel 的妙用"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/ingenious-use-of-channel/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css integrity=sha384-KyZXEAg3QhqLMpG8r+Knujsl5wVI+KzIO2G2Z4h4z2g5zF0VyQDq7V2E6Z8D6pv crossorigin=anonymous><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Go channel 的妙用</h1></header><date class="post-meta meta-date">2021年2月4日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>昨天在内网上看到一篇讲数据库连接的文章，列出了一些 sql 包的一些源码，我注意到其中取用、归还连接的方式非常有意思——通过临时创建的 channel 来传递连接。</p><p>在 sql.DB 结构体里，使用 <code>freeConn</code> 字段来表示当前所有的连接，也就是一个连接池。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> DB <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    freeConn     []<span style=color:#000;font-weight:700>*</span>driverConn
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当需要拿连接的时候，从 freeConn 中取出第一个元素：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>conn <span style=color:#000;font-weight:700>:=</span> db.freeConn[<span style=color:#099>0</span>]
</span></span><span style=display:flex><span><span style=color:#0086b3>copy</span>(db.freeConn, db.freeConn[<span style=color:#099>1</span>:])
</span></span><span style=display:flex><span>db.freeConn = db.freeConn[:numFree<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>]
</span></span><span style=display:flex><span>conn.inUse = <span style=color:#000;font-weight:700>true</span>
</span></span></code></pre></div><p>取 slice 切片的第一个元素，然后将 slice 后面的元素往前挪，最后通过截断来“释放”最后一个元素。</p><p>当然，能进行上述操作的前提是切片 <code>db.freeConn</code> 长度大于 0，即有空闲连接存在。如果当前没有空闲连接，那如何处理呢？接下来就是 channel 的妙用的地方。</p><p><code>sql.DB</code> 结构体里还有另一个字段 <code>connRequests</code>，它用来存储当前有哪些“协程”在申请连接：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> DB <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    freeConn     []<span style=color:#000;font-weight:700>*</span>driverConn
</span></span><span style=display:flex><span>    connRequests <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>uint64</span>]<span style=color:#000;font-weight:700>chan</span> connRequest
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>connRequests</code> 的 key 是一个 uint64类型，其实就是一个递增加 1 的 key；而 <code>connRequest</code> 表示申请一个新连接的请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> connRequest <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	conn <span style=color:#000;font-weight:700>*</span>driverConn
</span></span><span style=display:flex><span>	err  <span style=color:#458;font-weight:700>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的 <code>conn</code> 正是需要的连接。</p><p>当连接池中没有空闲连接的时候：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>req <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>chan</span> connRequest, <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>reqKey <span style=color:#000;font-weight:700>:=</span> db.<span style=color:#900;font-weight:700>nextRequestKeyLocked</span>()
</span></span><span style=display:flex><span>db.connRequests[reqKey] = req
</span></span></code></pre></div><p>先是构建了一个 <code>chan connRequest</code>，同时拿到了一个 reqKey，将它和 req 绑定到 connRequests 中。</p><p>接下来，在 select 中等待超时或者从 req 这个 channel 中拿到空闲连接：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>select</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>case</span> <span style=color:#000;font-weight:700>&lt;-</span>ctx.<span style=color:#900;font-weight:700>Done</span>():
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>case</span> ret, ok <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&lt;-</span>req:
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> !ok {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, errDBClosed
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> ret.conn, ret.err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，select 有两个 case，第一个是通过 context 控制的 <code>&lt;-Done</code>；第二个则是前面构造的 <code>&lt;-req</code>，如果从 req 中读出了元素，那就相当于获得了连接：ret.conn。</p><p>那什么时候会向 req 中发送连接呢？答案是在向连接池归还连接的时候。</p><p>前面提到，空闲连接是一个切片，归还的时候直接 append 到这个切片就可以了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (db <span style=color:#000;font-weight:700>*</span>DB) <span style=color:#900;font-weight:700>putConnDBLocked</span>(dc <span style=color:#000;font-weight:700>*</span>driverConn, err <span style=color:#458;font-weight:700>error</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    db.freeConn = <span style=color:#0086b3>append</span>(db.freeConn, dc)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但其实在 append 之前，还会去检查当前 connRequests 中是否有申请空闲连接的请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> c <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>len</span>(db.connRequests); c &gt; <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> req <span style=color:#000;font-weight:700>chan</span> connRequest
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> reqKey <span style=color:#458;font-weight:700>uint64</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> reqKey, req = <span style=color:#000;font-weight:700>range</span> db.connRequests {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#0086b3>delete</span>(db.connRequests, reqKey) <span style=color:#998;font-style:italic>// Remove from pending requests.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		dc.inUse = <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	req <span style=color:#000;font-weight:700>&lt;-</span> connRequest{
</span></span><span style=display:flex><span>		conn: dc,
</span></span><span style=display:flex><span>		err:  err,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>如果有请求的话，直接将当前连接“塞到” req channel 里去了。另一边，申请连接的 goroutine 就可以从 req channel 中读出 conn。</p><p>于是，通过 channel 就实现了一次“连接传输”的功能。</p><p>这让我想到不久之前芮神写的一篇<a href=https://mp.weixin.qq.com/s/MtdU1xhOI5XkuSDrIYFRMA>《高并发服务遇redis瓶颈引发time-wait事故》</a>，文中提到了将多个 redis command 组装为一个 pipeline：</p><blockquote><p>调用方把 redis command 和接收结果的 chan 推送到任务队列中，然后由一个 worker 去消费，worker 组装多个 redis cmd 为 pipeline，向 redis 发起请求并拿回结果，拆解结果集后，给每个命令对应的结果 chan 推送结果。调用方在推送任务到队列后，就一直监听传输结果的 chan。</p></blockquote><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210204090619.png><img class=mx-auto alt="redis commnd 组装成 pipeline" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210204090619.png></a></p><p>这里的用法就和本文描述的 channel 用法一致。</p><p>细想一下，以上提到的 channel 用法很神奇吗？我们平时没有接触过吗？</p><p>我用过最多的是“生产者-消费者”模式，先启动 N 个 goroutine 消费者，读某个 channel，之后，生产者再在某个时候向 channel 中发送元素：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; engine.workerNum; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>            work = <span style=color:#000;font-weight:700>&lt;-</span>engine.workChan
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>另外，我还会用 channel 充当一个 “ready” 的信号，用来指示某个“过程”准备好了，可以接收结果了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (j <span style=color:#000;font-weight:700>*</span>Job) <span style=color:#900;font-weight:700>Finished</span>() <span style=color:#000;font-weight:700>&lt;-</span><span style=color:#000;font-weight:700>chan</span> <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> j.finish
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>前面提到的“生产者-消费者”和 “ready” 信号这两种 channel 用法和本文的 channel 用法并没有什么本质区别。唯一不同的点是前者的 channel 是事先创建好的，并且是“公用”的；而本文中用到的 channel 实际上是“临时”创建的，并且只有这一个请求使用。</p><p>最后，用曹大最近在读者群里说的话结尾：</p><blockquote><ol><li><p>抄代码是很好的学习方式。</p></li><li><p>选一两个感兴趣的方向，自己尝试实现相应的 feature list，实现完和标准实现做对比。</p></li><li><p>先积累再创造，别一上来就想着造轮子，看的多了碰上很多东西就有新思路了。</p></li></ol></blockquote></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/ingenious-use-of-channel/>https://qcrao.com/post/ingenious-use-of-channel/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/how-to-be-a-TO/ title="项目 TO 的自我修养">项目 TO 的自我修养</a></li><li><a href=https://qcrao.com/post/how-to-write-a-things3-client/ title="如何写一个 things3 client">如何写一个 things3 client</a></li><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>