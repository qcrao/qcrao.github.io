<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>“三次握手，四次挥手”你真的懂吗？ | qcrao 的博客</title><meta property="og:title" content="“三次握手，四次挥手”你真的懂吗？ - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-01-16T11:10:00+08:00"><meta property="article:modified_time" content="2019-01-16T11:10:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="“三次握手，四次挥手”你真的懂吗？"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-three-way-handshake/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css integrity=sha384-KyZXEAg3QhqLMpG8r+Knujsl5wVI+KzIO2G2Z4h4z2g5zF0VyQDq7V2E6Z8D6pv crossorigin=anonymous><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>“三次握手，四次挥手”你真的懂吗？</h1></header><date class="post-meta meta-date">2019年1月16日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p><p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。</p><h1 id=什么是3次握手4次挥手>什么是“3次握手，4次挥手”</h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h2 id=tcp服务模型>TCP服务模型</h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id=tcp头部>TCP头部</h2><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201642.png><img class=mx-auto alt="tcp header" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201642.png></a></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code>ISN</code>，之后发送的数据是ISN加1，因此SYN位字段会<code>消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。
RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。
SYN —— 用于初如化一个连接的序列号。
FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h2 id=状态转换>状态转换</h2><p>三次握手和四次挥手的状态转换如下图。
<a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201613.png><img class=mx-auto alt="tcp connect" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201613.png></a></p><h1 id=为什么要三次握手四次挥手>为什么要“三次握手，四次挥手”</h1><h2 id=三次握手>三次握手</h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。
从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。
第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的，而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表面看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th style=text-align:left>视角</th><th style=text-align:left>客收</th><th style=text-align:left>客发</th><th style=text-align:left>服收</th><th style=text-align:left>服发</th></tr></thead><tbody><tr><td style=text-align:left>客视角</td><td style=text-align:left>二</td><td style=text-align:left>一 + 二</td><td style=text-align:left>一 + 二</td><td style=text-align:left>二</td></tr><tr><td style=text-align:left>服视角</td><td style=text-align:left>二 + 三</td><td style=text-align:left>一</td><td style=text-align:left>一</td><td style=text-align:left>二 + 三</td></tr></tbody></table><h2 id=四次挥手>四次挥手</h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解<code>“上层的意志”</code>。</p><h1 id=三次握手四次挥手怎么完成>“三次握手，四次挥手”怎么完成？</h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><h2 id=三次握手-1>三次握手</h2><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201544.png><img class=mx-auto alt=三次握手 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201544.png></a></p><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h2 id=四次挥手-1>四次挥手</h2><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201522.png><img class=mx-auto alt=四次挥手 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201522.png></a></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h2 id=为什么建立连接是三次握手而关闭连接却是四次挥手呢>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h1 id=三次握手四次挥手进阶>“三次握手，四次挥手”进阶</h1><h2 id=isn>ISN</h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><pre tabindex=0><code>ISN = M + F(localhost, localport, remotehost, remoteport)
</code></pre><p>M是一个计时器，每隔4微秒加1。
F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h2 id=序列号回绕>序列号回绕</h2><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#998;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>* The next routines deal with comparing 32 bit unsigned ints
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>* and worry about wraparound (automatic with unsigned arithmetic).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>static</span> <span style=color:#000;font-weight:700>inline</span> <span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>before</span>(__u32 seq1, __u32 seq2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> (__s32)(seq1<span style=color:#000;font-weight:700>-</span>seq2) <span style=color:#000;font-weight:700>&lt;</span> <span style=color:#099>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-weight:700;font-style:italic>#define after(seq2, seq1) before(seq1, seq2)
</span></span></span></code></pre></div><p>上述是内核中的解决回绕问题代码。__s32是有符号整型的意思，而__u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><pre tabindex=0><code>假设seq1=255， seq2=1（发生了回绕）。
seq1 = 1111 1111 seq2 = 0000 0001
我们希望比较结果是
 seq1 - seq2=
 1111 1111
-0000 0001
-----------
 1111 1110

由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为
 0000 0001 + 1 = 0000 0010 = 2

因此seq1 - seq2 &lt; 0
</code></pre><h2 id=syn-flood攻击>syn flood攻击</h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h3 id=无效连接的监视释放>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h3 id=延缓tcb分配方法>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h4 id=syn-cache技术>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h4 id=syn-cookie技术>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h3 id=使用syn-proxy防火墙>使用SYN Proxy防火墙</h3><p>一种方式是确认了连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c&rsquo;, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h2 id=连接队列>连接队列</h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201443.png><img class=mx-auto alt="tcp queue" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201443.png></a></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>查看是否有连接溢出
</span></span><span style=display:flex><span>netstat -s | grep LISTEN
</span></span></code></pre></div><h3 id=半连接队列满了>半连接队列满了</h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><blockquote><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><table><thead><tr><th style=text-align:left>参数</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:left>tcp_syncookies</td><td style=text-align:left>SYNcookie将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</td></tr><tr><td style=text-align:left>tcp_syncookies</td><td style=text-align:left>内核放弃建立连接之前发送SYN包的数量。</td></tr><tr><td style=text-align:left>tcp_synack_retries</td><td style=text-align:left>内核放弃连接之前发送SYN+ACK包的数量</td></tr><tr><td style=text-align:left>tcp_max_syn_backlog</td><td style=text-align:left>默认为1000. 这表示半连接队列的长度，如果超过则放弃当前连接。</td></tr><tr><td style=text-align:left>tcp_abort_on_overflow</td><td style=text-align:left>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr></tbody></table><h3 id=全连接队列满了>全连接队列满了</h3><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回<code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到客户端。</p><table><thead><tr><th style=text-align:left>参数</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:left>tcp_abort_on_overflow</td><td style=text-align:left>如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr><tr><td style=text-align:left>min(backlog, somaxconn)</td><td style=text-align:left>全连接队列的长度。</td></tr></tbody></table><h3 id=命令>命令</h3><p>netstat -s命令</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000;font-weight:700>[</span>root@server ~<span style=color:#000;font-weight:700>]</span><span style=color:#998;font-style:italic>#  netstat -s | egrep &#34;listen|LISTEN&#34; </span>
</span></span><span style=display:flex><span><span style=color:#099>667399</span> <span style=color:#0086b3>times</span> the listen queue of a socket overflowed
</span></span><span style=display:flex><span><span style=color:#099>667399</span> SYNs to LISTEN sockets ignored
</span></span></code></pre></div><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000;font-weight:700>[</span>root@server ~<span style=color:#000;font-weight:700>]</span><span style=color:#998;font-style:italic>#  netstat -s | grep TCPBacklogDrop</span>
</span></span></code></pre></div><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000;font-weight:700>[</span>root@server ~<span style=color:#000;font-weight:700>]</span><span style=color:#998;font-style:italic>#  ss -lnt</span>
</span></span><span style=display:flex><span>State Recv-Q Send-Q Local Address:Port Peer Address:Port
</span></span><span style=display:flex><span>LISTEN     <span style=color:#099>0</span>      <span style=color:#099>128</span> *:6379 *:*
</span></span><span style=display:flex><span>LISTEN     <span style=color:#099>0</span>      <span style=color:#099>128</span> *:22 *:*
</span></span></code></pre></div><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。
非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h3 id=小结>小结</h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h1 id=三次握手四次挥手redis实例分析>“三次握手，四次挥手”redis实例分析</h1><ol><li>我在dev机器上部署redis服务，端口号为6379,</li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpdump -w /tmp/a.cap port <span style=color:#099>6379</span> -s0
</span></span><span style=display:flex><span>-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包
</span></span></code></pre></div><ol start=3><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpdump -r /tmp/a.cap -n -nn -A -x| vim -
</span></span><span style=display:flex><span>（-x 以16进制形式展示，便于后面分析）
</span></span></code></pre></div><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：
<a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201406.png><img class=mx-auto alt="ip head" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201406.png></a>
它由固定长度20B+可变长度构成。</p><pre tabindex=0><code class=language-tcpdump data-lang=tcpdump>10:55:45.662077 IP dev2.39070 &gt; dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0
        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561
        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000
        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a
        0x0030:  b062 e330 0000 0000 0103 0307
</code></pre><p>对着IP头部格式，来拆解数据包的具体含义。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x4</td><td style=text-align:left>IP版本为ipv4</td></tr><tr><td style=text-align:left>0x5</td><td style=text-align:left>首部长度为5 * 4字节=20B</td></tr><tr><td style=text-align:left>0x00</td><td style=text-align:left>服务类型，现在基本都置为0</td></tr><tr><td style=text-align:left>0x003c</td><td style=text-align:left>总长度为3*16+12=60字节，上面所有的长度就是60字节</td></tr><tr><td style=text-align:left>0x08cf</td><td style=text-align:left>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td style=text-align:left>0x4000</td><td style=text-align:left><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td style=text-align:left>0x36</td><td style=text-align:left>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td style=text-align:left>0x06</td><td style=text-align:left>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td style=text-align:left>0x14a5</td><td style=text-align:left>16bitIP首部校验和。</td></tr><tr><td style=text-align:left>0x0ab3 b561</td><td style=text-align:left>32bit源ip地址。</td></tr><tr><td style=text-align:left>0x0a60 5cd4</td><td style=text-align:left>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x989e</td><td style=text-align:left>16bit源端口。1<em>16</em>16<em>16+8</em>16<em>16+14</em>16+11=39070</td></tr><tr><td style=text-align:left>0x18eb</td><td style=text-align:left>16bit目的端口6379</td></tr><tr><td style=text-align:left>0xf65a ebff</td><td style=text-align:left>32bit序列号。4133153791</td></tr><tr><td style=text-align:left>0x0000 0000</td><td style=text-align:left>32bit确认号。</td></tr><tr><td style=text-align:left>0xa</td><td style=text-align:left>4bit首部长度，以4byte为单位。共10*4=40字节。因此TCP报文的可选长度为40-20=20</td></tr><tr><td style=text-align:left>0b000000</td><td style=text-align:left>6bit保留位。目前置为0.</td></tr><tr><td style=text-align:left>0b000010</td><td style=text-align:left>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。</td></tr><tr><td style=text-align:left>0x7210</td><td style=text-align:left>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。29200</td></tr><tr><td style=text-align:left>0x872f</td><td style=text-align:left>16bit校验和。</td></tr><tr><td style=text-align:left>0x0000</td><td style=text-align:left>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x0204 05b4</td><td style=text-align:left>最大报文长度为，05b4=1460. 即可接收的最大包长度，通常为MTU减40字节，IP头和TCP头各20字节</td></tr><tr><td style=text-align:left>0x0402</td><td style=text-align:left>表示支持SACK</td></tr><tr><td style=text-align:left>0x080a b062 e330 0000 0000</td><td style=text-align:left>时间戳。Ts val=b062 e330=2959270704, ecr=0</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x03 0307</td><td style=text-align:left>窗口扩大因子为7. 移位7, 乘以128</td></tr><tr><td style=text-align:left>这样第一个包分析完了。dev2向dev发送SYN请求。<code>也就是三次握手中的第一次了。</code></td><td></td></tr><tr><td style=text-align:left><code>SYN seq(c)=4133153791</code></td><td></td></tr></tbody></table><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.
<code>SYN ack=seq(c)+1 seq(s)=4264776963</code></p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.
<code>ack=seq(s)+1, seq=seq(c)+1</code>
至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><pre tabindex=0><code class=language-tcpdump data-lang=tcpdump>10:55:48.090073 IP dev2.39070 &gt; dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14
        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561
        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504
        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac
        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67
        0x0040:  0d0a
</code></pre><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792
ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><pre tabindex=0><code class=language-tcpdump data-lang=tcpdump>0x2a31         -&gt; *1
0x0d0a         -&gt; \r\n
0x2434         -&gt; $4
0x0d0a         -&gt; \r\n
0x7069 0x6e67  -&gt; ping
0x0d0a         -&gt; \r\n
</code></pre><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。
序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).</p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.
数据部分2b50 4f4e 470d 0a, 翻译过来就是<code>+PONG\r\n</code>.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><h1 id=总结>总结</h1><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><p>所以，“三次握手，四次挥手”你真的懂了吗？欢迎一起交流~~</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201244.png><img class=mx-auto alt=20210108201244 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210108201244.png></a></p><h1 id=参考资料>参考资料</h1><p>【redis】 <a href=https://segmentfault.com/a/1190000015044878>https://segmentfault.com/a/1190000015044878</a></p><p>【tcp option】 <a href=https://blog.csdn.net/wdscq1234/article/details/52423272>https://blog.csdn.net/wdscq1234/article/details/52423272</a></p><p>【滑动窗口】 <a href=https://www.zhihu.com/question/32255109>https://www.zhihu.com/question/32255109</a></p><p>【全连接队列】 <a href=http://jm.taobao.org/2017/05/25/525-1/>http://jm.taobao.org/2017/05/25/525-1/</a></p><p>【client fooling】 <a href=https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071>https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071</a></p><p>【backlog RECV_Q】 <a href=http://blog.51cto.com/59090939/1947443>http://blog.51cto.com/59090939/1947443</a></p><p>【定时器】 <a href=https://www.cnblogs.com/menghuanbiao/p/5212131.html>https://www.cnblogs.com/menghuanbiao/p/5212131.html</a></p><p>【队列图示】 <a href=https://www.itcodemonkey.com/article/5834.html>https://www.itcodemonkey.com/article/5834.html</a></p><p>【tcp flood攻击】 <a href=https://www.cnblogs.com/hubavyn/p/4477883.html>https://www.cnblogs.com/hubavyn/p/4477883.html</a></p><p>【MSS MTU】 <a href=https://blog.csdn.net/LoseInVain/article/details/53694265>https://blog.csdn.net/LoseInVain/article/details/53694265</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-three-way-handshake/>https://qcrao.com/post/dive-into-three-way-handshake/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/how-to-be-a-TO/ title="项目 TO 的自我修养">项目 TO 的自我修养</a></li><li><a href=https://qcrao.com/post/how-to-write-a-things3-client/ title="如何写一个 things3 client">如何写一个 things3 client</a></li><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>