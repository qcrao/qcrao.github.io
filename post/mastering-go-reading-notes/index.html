<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度阅读之《Mastering Go》 | qcrao 的博客</title><meta property="og:title" content="深度阅读之《Mastering Go》 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-04-19T23:07:24+08:00"><meta property="article:modified_time" content="2021-04-19T23:07:24+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度阅读之《Mastering Go》"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/mastering-go-reading-notes/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度阅读之《Mastering Go》</h1></header><date class="post-meta meta-date">2021年4月19日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>写在前面：这本书前前后后花了挺长时间，去年 11 月份就开始读了，中间又断了，直到最近才捡起来看完。</p><p>本书讲得内容非常全面，语言也很顺畅，生词非常少，并且内容没有太大难度，看起来比较过瘾，算是全面复习一下 Go 语言。如果你想开始练习阅读英文书，这本将是一个非常好的开始。</p><p>下面是阅读过程中记录的一些有用的点，随意看看就好。</p><hr><ol><li><p>Go 有很多优点，其中一点是没有预编译阶段，这使得它的编译速度更快。像 C 语中，以 # 开头的会被预编译器处理。有预编译器的语言有：C, C++, Ada, and PL/SQL。预编译器的一大缺点是它会修改源代码，而人们不知道送到编译器里的最终的代码是什么。</p></li><li><p>可以直接在命令行执行 <code>go doc strings.Fields</code> 获取库函数的解释；执行 <code>go get golang.org/x/tools/cmd/godoc</code> 会安装 godoc 工具，注意这两者是不同的。前者是 go 命令，后者则是 godoc 命令。执行 <code>godoc -http :8080</code> 可以启动一个 server，访问 <code>http://localhost:8080/pkg/</code> 即可看到 Go 的文档。</p></li><li><p>执行 <code>go build</code> 会显示生成一个可执行文件，仅仅一个 hello_world 就会达到 2M 大小，这是因为 Go 是静态链接，生成的文件可以直接执行，不需要再动态链接其他文件。而执行 <code>go run</code> 命令，虽然也会生成可执行文件，但是它是隐式的，之后当程序执行完后会被自动删掉。注意，看不见并不等于不存在！</p></li><li><p>所有的 UNIX 系统都支持：<code>/dev/stdin</code>、<code>/dev/stdout</code>、<code>/dev/stderr</code> 这三个特殊的文件名，它们也可以用 0、1、2 号文件描述符来描述。</p></li><li><p>fmt.Println(), fmt.Print(), and fmt.Printf() 用于打印，fmt.Sprintln(), fmt.Sprint(), fmt.Sprintf() 用于生成字符串，fmt.Fprintln(), fmt.Fprint(), fmt.Fprintf() 用于写文件。</p></li><li><p>短赋值符 <code>:=</code> 不能用于函数之外，因此全局变量只能用 <code>var</code> 声明。</p></li><li><p>下面的代码用于从标准输入读取数据，每读出一行就打印出来：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> f <span style=color:#000;font-weight:700>*</span>os.File
</span></span><span style=display:flex><span>	f = os.Stdin
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> f.<span style=color:#900;font-weight:700>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	scanner <span style=color:#000;font-weight:700>:=</span> bufio.<span style=color:#900;font-weight:700>NewScanner</span>(f)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> scanner.<span style=color:#900;font-weight:700>Scan</span>() {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;&gt;&#34;</span>, scanner.<span style=color:#900;font-weight:700>Text</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>按 ctrl+D 退出循环，因为 ctrl+D 会告知程序没有更多的数据可以读取。</p><ol start=8><li><code>os.Args</code> 可以记录通过命令行输入的参数，并且它的类型是 []string，第一个元素是程序名，之后的为输入参数。例如：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> run a.<span style=color:#000;font-weight:700>go</span> <span style=color:#099>10</span> <span style=color:#099>1</span>
</span></span></code></pre></div><p><code>os.Args</code> 为 <code>[/tmp/go-build059507490/b001/exe/cla 10 1]</code></p><ol start=9><li>关于 docker 的命令：</li></ol><pre tabindex=0><code># 根据 tag 创建
docker build -t go_hw:v1 .

# 列出所有的 docker images
docker images

# 运行
docker run go_hw:v1

# 删除（-f 强制删除）
docker rmi 5a0d2473aa96 f56365ec0638
</code></pre><ol start=10><li><p>关于 Go 的垃圾回收算法：并发标记清除、非分代、非整理，使用写屏障。</p></li><li><p>Go 为了降低 GC 的停顿时间，让 GC 和用户程序并发执行。为了让三色标记的结果不受并发执行的程序的影响，在整个标记过程中，要确保一个不变性：黑色集合里的对象保证不会指向白色集合里的对象，注意这并不影响一个白色对象指向黑色对象。我们把用户程序称为 mutator，mutator 运行了一个 writer barrier，每次当堆上有对象的指针（如果是对象的非指针字段变化，不影响）发生了变化，说明此对象可达，就要运行 writer barrier，将它变成灰色。mutator 通过 writer barrier 保证“黑色集合里的对象保证不会指向白色集合里的对象”这一不变性。这会带来性能的损耗，但这是并发执行用户程序和 GC 的代价。</p></li><li><p>垃圾回收器会在 channel 不可达时回收它，即使 channel 还未关闭。</p></li><li><p><code>time go run xx.go</code> 可以计算运行程序花费的时间。</p></li><li><p>Please remember that at the end of the day, all programs that work on UNIX machines end up using C system calls to communicate with the UNIX kernel and perform most of their tasks. 所有在 UNIX 系统上运行的程序最终都会通过 C 系统调用来和内核打交道。用其他语言编写程序进行系统调用，方法不外乎两个：一是自己封装，二是依赖 glibc、或者其他的运行库。Go 语言选择了前者，把系统调用都封装到了 syscall 包。封装时也同样得通过汇编实现。</p></li><li><p><code>strace ls</code> 查看都有哪些系统调用，<code>-c</code> 可以计数。</p></li><li><p>将 .go 文件转化成汇编代码时，可指定操作系统和架构：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#998;font-style:italic># 两者等价</span>
</span></span><span style=display:flex><span><span style=color:teal>GOOS</span><span style=color:#000;font-weight:700>=</span>darwin <span style=color:teal>GOARCH</span><span style=color:#000;font-weight:700>=</span>amd64 go tool compile -S goEnv.go
</span></span><span style=display:flex><span><span style=color:teal>GOOS</span><span style=color:#000;font-weight:700>=</span>darwin <span style=color:teal>GOARCH</span><span style=color:#000;font-weight:700>=</span>amd64 go build -gcflags -S goEnv.go
</span></span></code></pre></div><p>GOOS 和 GOARCH 可选项为：The list of valid GOOS values includes android, darwin, dragonfly, freebsd, linux, nacl, netbsd, openbsd, plan9, solaris, windows, and zos. On the other hand, the list of valid GOARCH values includes 386, amd64, amd64p32, arm, armbe, arm64, arm64be, ppc64, ppc64le, mips, mipsle, mips64, mips64le, mips64p32, mips64p32le, ppc, s390, s390x, sparc, and sparc64.</p><ol start=16><li><p><code>go build -x defer.go</code> 展示 build 过程。</p></li><li><p>数组可以用 “:” 变成切片：array4[0:] 或 array4[:]，copy 函数只接收切片作为参数。</p></li><li><p>什么时候使用指针：1. 可以 share data，尤其是在函数之间；2. 区别某个变量是未设置还是真的零值。</p></li><li><p>关于 strings 有很多有意思的方法，例如 Repeat, Fields 等等，在<a href=https://github.com/PacktPublishing/Mastering-Go-Second-Edition/blob/master/ch04/useStrings.go>这里</a>可以看到很多。</p></li><li><p>Go container 包有 heap/list/ring 这几个组件。</p></li><li><p><code>math/rand</code> 可用于生成伪随机数；更安全的生成随机数：<code>crypto/rand</code>。</p></li><li><p>关于可变参数的函数（A variadic function），<code>...Type</code> 称为 pack operator，而 <code>Slice...</code> 则被称为 unpack operator。一个可变参数的函数只能使用一次 pack operator。</p></li><li><p>安装一个本地包：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ mkdir ~/go/src/aPackage
</span></span><span style=display:flex><span>$ cp aPackage.go ~/go/src/aPackage/
</span></span><span style=display:flex><span>$ go install aPackage
</span></span><span style=display:flex><span>$ <span style=color:#0086b3>cd</span> ~/go/pkg/darwin_amd64/
</span></span><span style=display:flex><span>$ ls -l aPackage.a
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#099>1</span> mtsouk staff <span style=color:#099>4980</span> Dec <span style=color:#099>22</span> 06:12 aPackage.a
</span></span></code></pre></div><p>编译一个本地包：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go tool compile aPackage.go
</span></span><span style=display:flex><span>$ ls -l aPackage.*
</span></span><span style=display:flex><span>-rw-r--r--@ <span style=color:#099>1</span> mtsouk staff <span style=color:#099>201</span> Jan <span style=color:#099>10</span> 22:08 aPackage.go -rw-r--r-- <span style=color:#099>1</span> mtsouk staff <span style=color:#099>16316</span> Mar <span style=color:#099>4</span> 20:01 aPackage.o
</span></span></code></pre></div><ol start=24><li><p>关于 Go 版本，例如 v1.2.3，v1/v2/v3 通常是不兼容的，<code>1</code> 表示大版本，<code>2</code> 表示 feature，<code>3</code> 表示 fix。</p></li><li><p>如何和 gomod 工作：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ go mod init
</span></span><span style=display:flex><span>go: creating new go.mod: module github.com/mactsouk/myModule 
</span></span><span style=display:flex><span>$ touch myModule.go
</span></span><span style=display:flex><span>$ vi myModule.go
</span></span><span style=display:flex><span>$ git add .
</span></span><span style=display:flex><span>$ git commit -a -m <span style=color:#d14>&#34;Initial version 1.0.0&#34;</span>
</span></span><span style=display:flex><span>$ git push
</span></span><span style=display:flex><span>$ git tag v1.0.0
</span></span><span style=display:flex><span>$ git push -q origin v1.0.0
</span></span><span style=display:flex><span>$ go list
</span></span><span style=display:flex><span>github.com/mactsouk/myModule
</span></span><span style=display:flex><span>$ go list -m
</span></span><span style=display:flex><span>github.com/mactsouk/myModule
</span></span></code></pre></div><ol start=26><li>创建 v2 版本：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>git commit -a -m <span style=color:#d14>&#34;using v2.0.0&#34;</span>
</span></span><span style=display:flex><span>git tag v2.0.0
</span></span><span style=display:flex><span>git push --tags origin v2
</span></span><span style=display:flex><span>git --no-pager branch -a
</span></span></code></pre></div><ol start=27><li>使用 go mod vendor 命令来将依赖放到 vendor 文件夹里：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>go mod init useV1V2
</span></span><span style=display:flex><span>go mod vendor
</span></span></code></pre></div><ol start=28><li>查找哪些 go 源文件使用了 syscall：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>grep <span style=color:#d14>\&#34;</span>syscall<span style=color:#d14>\&#34;</span> <span style=color:#d14>`</span>find /usr/local/go/src -name <span style=color:#d14>&#34;*.go&#34;</span><span style=color:#d14>`</span>
</span></span></code></pre></div><ol start=29><li><p>要记住的是在绝大部分程序里不需要使用反射，所以我们得弄清楚为什么反射是必须的以及什么时候需要使用反射。反射在实现 fmt, text/template, html/template 时是必须的。例如在 fmt 包里，反射可以让你不需要明确处理所有的类型，你当然可以明确处理你知道的所有类型，但你仍然不可能处理 All possible types。</p></li><li><p>什么时候用反射：Therefore, you might need to use reflection when you want to be as generic as possible or when you want to make sure that you will be able to deal with data types that do not exist at the time of writing your code but might exist in the future. Additionally, reflection is handy when working with values of types that do not implement a common interface.</p></li><li><p>反射不好的三点：a. 大量的反射会造成程序代码难以理解和维护。一个可行的解决方法是清晰的文档注释，但众所周知，程序员是最不愿意写文档的人；b. 相比正常的数据结构，反射是动态地“决定”数据结构，因此会更慢。这些动态代码也会使得一些代码工具更难执行重构和分析；c. 反射的错误在 build 期间不会被捕获，很多都是在运行期间直接 crash 整个程序。而且这经常是在程序正常运行数月甚至是数年之后才会爆发。一个可行的办法是大量的测试，但这也不太可能覆盖完全，并且会让代码库更加庞大。</p></li><li><p>Go 不是一门面向对象的语言，但它可以模拟面向对象语言的某些功能。</p></li><li><p>flag.var 可以解析用逗号分隔的多个值。</p></li><li><p><code>wc</code> 命令的结果有三列，分别表示行数、word 数，以及字节数。平时用的最多的是 <code>wc -l</code>，表示行数；<code>wc -w</code> 表示 wrod 数；<code>wc -c</code> 表示字节数。</p></li><li><p>如何输出一个文件的权限，上代码：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	arguments <span style=color:#000;font-weight:700>:=</span> os.Args
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(arguments) <span style=color:#000;font-weight:700>==</span> <span style=color:#099>1</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;usage: permissions filename\n&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	filename <span style=color:#000;font-weight:700>:=</span> arguments[<span style=color:#099>1</span>]
</span></span><span style=display:flex><span>	info, _ <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Stat</span>(filename)
</span></span><span style=display:flex><span>	mode <span style=color:#000;font-weight:700>:=</span> info.<span style=color:#900;font-weight:700>Mode</span>()
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(filename, <span style=color:#d14>&#34;mode is&#34;</span>, mode.<span style=color:#900;font-weight:700>String</span>()[<span style=color:#099>1</span>:<span style=color:#099>10</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=36><li><p><code>crtl+C</code> 向进程发送 SIGINT 信号。Unix 里的信号其实都是软中断，用来异步处理“事件”，信号可以通过 name 和 number 来识别。进程不可能处理所有类型的信号，有些信号不能被 caught，不能被 blocked，例如 SIGKILL、SIGSTOP 不能被 caught，不能被 blocked，也不能被 ignored。因为它们给内核和 root 用户提供了特权，可以停止运行某些进程。一般我们建议用信号的 name 来操作，例如 <code>kill -s INT pid</code>。有个例外的是 SIGKILL，它对应的 number 是 9，例如我们经常执行 <code>kill -9 pid</code> 来杀死某个进程，它等价于 <code>kill -s KILL pid</code>。</p></li><li><p>最常用来发送信号的方式用 kill 命令，默认发送的是 SIGTERM 信号。<code>kill -l</code> 命令可以列出所有支持的信号。</p></li><li><p><code>go run -race xx.go</code> 可以显示有竞争冲突的代码。</p></li><li><p><code>diff pipeline.go plNoRace.go --color</code> 显示两个文件的 diff。</p></li><li><p>Go 语言的并发模型是 fork-join 型的。使用 go 关键字启动子协程工作，使用 sync.Wait 和 channel 来收集结果。</p></li><li><p>可通过设置环境变量来改变 runtime.GOMAXPROCS(0) 的输出值：<code>export GOMAXPROCS=800;</code>。</p></li><li><p>sync.RWMutex 结构体里包含 sync.Mutex，即“读写锁”是在“锁”的基本上实现的。只有当所的读锁都 Unlock 了，写锁才能被 Lock。</p></li><li><p><code>time go run xx.go</code> 可以显示执行时间，包括 real, sys, user 的执行时间。</p></li><li><p>如果子 context 取消了，父 context 没有收到消息，那么在父 context 取消前就发生了内存泄露。</p></li></ol><blockquote><p>For garbage collection to work correctly, the parent goroutine needs to keep a reference to each child goroutine. If a child goroutine ends without the parent knowing about it, then a memory leak occurs until the parent is canceled as well.</p></blockquote><ol start=45><li>TAOCP——《计算机程序设计艺术》的作者高德纳（Donald Ervin Knuth）老爷子的一句经典的话：</li></ol><blockquote><p>&ldquo;The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.&rdquo;</p></blockquote><p>告诉我们不要老想着性能优化，在真的出现问题、出现瓶颈的时候再来考虑。</p><p>还有 Erlang 的作者之一 Joe Armstrong：</p><blockquote><p>&ldquo;Make it work, then make it beautiful, then if you really, really have to, make it fast. 90 percent of the time, if you make it beautiful, it will already be fast. So really, just make it beautiful!&rdquo;</p></blockquote><p>这告诉我们性能优化并不是主要工作，我们不要花费大量精力在这上面。</p><ol start=46><li><p>做优化的前提是程序没有 bug，所以如果你在程序的第一版就来优化是有问题的，因为 v1 版本可能经常有 bug。</p></li><li><p>交叉编译命令：<code>env GOOS=linux GOARCH=386 go build xCompile.go</code>。指定操作系统、指令集。</p></li><li><p>通过 <a href=https://golang.org/pkg/bytes/>bytes 包</a>的例子，可以看懂 godoc 和<a href=https://golang.org/src/bytes/bytes.go>源码</a>里的 comments 的对应关系。<code>pkg/bytes</code> 文档里有很多代码样例，还可以 run 一下，但其实这些样例是写死在源码里的，就在 <code>src/bytes/example_test.go</code> 文件里。一开始没发现这个文件，我直接拿样例代码全局搜，一下就找到了。例如，源码写的如下两个 example：</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// src
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>ExampleToTitleSpecial</span>() {
</span></span><span style=display:flex><span>	str <span style=color:#000;font-weight:700>:=</span> []<span style=color:#0086b3>byte</span>(<span style=color:#d14>&#34;ahoj vývojári golang&#34;</span>)
</span></span><span style=display:flex><span>	totitle <span style=color:#000;font-weight:700>:=</span> bytes.<span style=color:#900;font-weight:700>ToTitleSpecial</span>(unicode.AzeriCase, str)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Original : &#34;</span> <span style=color:#000;font-weight:700>+</span> <span style=color:#0086b3>string</span>(str))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;ToTitle : &#34;</span> <span style=color:#000;font-weight:700>+</span> <span style=color:#0086b3>string</span>(totitle))
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Output:
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// Original : ahoj vývojári golang
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// ToTitle : AHOJ VÝVOJÁRİ GOLANG
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>在 <a href=https://golang.org/pkg>pkg</a> 上，就对应这样：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210416085739.png><img class=mx-auto alt="go pkg example" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210416085739.png></a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/mastering-go-reading-notes/>https://qcrao.com/post/mastering-go-reading-notes/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li><li><a href=https://qcrao.com/post/how-to-use-functional-options-pattern/ title="曹大带我学 Go（7）—— 如何优雅地指定配置项">曹大带我学 Go（7）—— 如何优雅地指定配置项</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>