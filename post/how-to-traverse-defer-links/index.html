<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>defer 链表如何被遍历执行 | qcrao 的博客</title><meta property="og:title" content="defer 链表如何被遍历执行 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-03-23T09:32:16+08:00"><meta property="article:modified_time" content="2020-03-23T09:32:16+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="defer 链表如何被遍历执行"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/how-to-traverse-defer-links/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>defer 链表如何被遍历执行</h1></header><date class="post-meta meta-date">2020年3月23日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>去年开始写文章的第一篇就是关于 defer，名字比较文艺：<a href=https://mp.weixin.qq.com/s/txj7jQNki_8zIArb9kSHeg>《Golang 之轻松化解 defer 的温柔陷阱》</a>，还被吐槽了。因为这篇文章，到《Go 夜读》讲了一期。不过当时纯粹是应用层面的，也还没有跳进 Go 源码这个大坑，文章看着比较清新，也没有大段的源码解析。</p><p>自从听了曹大在《Go 夜读》分享的 Go 汇编，以及研读了阿波张的 Go 调度器源码分析的文章后，各种源码、汇编满天飞……</p><p>上次欧神写了一篇<a href=https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q>《Go GC 20 问》</a>，全文也没有一行源码，整体读下来很畅快。今天这篇也来尝试一下这种写法，不过，我们先从一个小的主题开始：defer 链表是如何被遍历并执行的。</p><p>关于 defer 的源码分析文章，网络上也有很多。不过，很少有能完全说明白这个话题的，除了阿波张的。</p><p>我们知道，为了在退出函数前执行一些资源清理的操作，例如关闭文件、释放连接等。会在函数里写上多个 defer 语句，被 defered 的函数，以“先进后出”的顺序，在 <code>RET</code> 指令前得以执行。</p><p>在一条函数调用链中，多个函数中会出现多个 defer 语句。例如：<code>a() -> b() -> c()</code> 中，每个函数里都有 defer 语句，而这些 defer 语句会创建对应个数的 <code>_defer</code> 结构体，这些结构体以链表的形式挂在 <code>goroutine</code> 结构体下。看起来像这样：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200321185857.png><img class=mx-auto alt="defer 挂在 g 上" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200321185857.png></a></p><p>在编译器的加持下，defer 语句会先调用 deferporc 函数，new 一个 <code>_defer</code> 结构体，挂到 g 上。当然，这里的 new 会优先从当前绑定的 P 的 defer pool 里取，没取到会去全局的 defer pool 里取，实在没有的话就新建一个，很熟悉的套路。</p><p>这样做好之后，等待函数体执行完，在 RET 指令之前（注意不是 return 之前），调用 <code>deferreturn</code> 函数完成 <code>_defer</code> 链表的遍历，执行完这条链上所有被 <code>defered</code> 的函数（如关闭文件、释放连接等）。这里的问题是在 <code>deferreturn</code> 函数的最后，会使用 <code>jmpdefer</code> 跳转到之前被 defered 的函数，这时控制权转移到了用户自定义的函数。这只是执行了一个被 defered 的函数，这条链上其他的被 defered 的函数，该如何得到执行呢？</p><p>答案就是控制权会再次交给 runtime，并再次执行 deferreturn 函数，完成 defer 链表的遍历。那这一切是如何完成的呢？</p><p>这就要从 Go 汇编的栈帧说起了。先看一个汇编函数的声明：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>TEXT runtime<span style=color:#a61717;background-color:#e3d2d2>·</span><span style=color:#900;font-weight:700>gogo</span>(SB), NOSPLIT, <span style=color:#a61717;background-color:#e3d2d2>$</span><span style=color:#099>16</span><span style=color:#000;font-weight:700>-</span><span style=color:#099>8</span>
</span></span></code></pre></div><p>最后两个数字表示 gogo 函数的栈帧大小为 16B，即函数的局部变量和为调用子函数准备的参数和返回值需要 16B 的栈空间；参数和返回值的大小加起来是 8B。实际上 gogo 函数的声明是这样的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// func gogo(buf *gobuf)
</span></span></span></code></pre></div><p>参数及返回值的大小是给调用者“看”的，调用者根据这个数字可以构造栈：准备好被调函数需要的参数及返回值。</p><p>典型的函数调用场景下参数布局图如下图：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213247.png><img class=mx-auto alt=函数调用参数布局 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213247.png></a></p><p>左图中，主调函数准备好调用子函数的参数及返回值，执行 <code>CALL</code> 指令，将返回地址压入栈顶，相当于执行了 <code>PUSH IP</code>，之后，将 BP 寄存器的值入栈，相当于执行了 <code>PUSH BP</code>，再 jmp 到被调函数。</p><p>图中 <code>return address</code> 表示子函数执行完毕后，返回到上层函数中调用子函数语句的下一条要执行的指令，它属于 caller 的栈帧。而调用者的 BP 则属于被调函数的栈帧。</p><p>子函数执行完毕后，执行 <code>RET</code> 指令：首先将子函数栈底部的值赋到 CPU 的 BP 寄存器中，于是 BP 指向上层函数的 BP；再将 <code>return address</code> 赋到 IP 寄存器中，这时 SP 回到左图所示的位置。相当于还原了整个调用子函数的现场，像是一切都没发生过；接着，CPU 继续执行 IP 寄存器里的下一条指令。</p><p>再回到 defer 上来，其实在构造 <code>_defer</code> 结构体的时候，需要将当前函数的 SP、被 defered 的函数指针保存到 <code>_defer</code> 结构体中。并且会将被 defered 的函数所需要的参数 copy 到 _defer 结构体相邻的位置。最终在调用被 defered 的函数的时候，用的就是这时被 copy 的值，相当于使用了它的一个快照，如果此参数不是指针或引用类型的话，会产生一些意料之外的 bug。</p><p>最后，在 deferreturn 函数里，这些被 defered 的函数得以执行，<code>_defer</code> 链表也会被逐渐“消耗”完。</p><p>使用一个阿波张<a href=https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g>文章</a>中的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#d14>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>sum</span>(a, b <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    c <span style=color:#000;font-weight:700>:=</span> a <span style=color:#000;font-weight:700>+</span> b
</span></span><span style=display:flex><span>    fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;sum:&#34;</span> , c)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>f</span>(a, b <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>defer</span> <span style=color:#900;font-weight:700>sum</span>(a, b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;a: %d, b: %d\n&#34;</span>, a, b)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    a, b <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>1</span>, <span style=color:#099>2</span>
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>f</span>(a, b)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行完 <code>f</code> 函数时，最终会进入 deferreturn 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>deferreturn</span>(arg0 <span style=color:#458;font-weight:700>uintptr</span>) {
</span></span><span style=display:flex><span>    gp <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>getg</span>()
</span></span><span style=display:flex><span>	d <span style=color:#000;font-weight:700>:=</span> gp._defer
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> d <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>......</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>switch</span> d.siz {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>case</span> <span style=color:#099>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Do nothing.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>case</span> sys.PtrSize:
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>uintptr</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>arg0)) = <span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>uintptr</span>)(<span style=color:#900;font-weight:700>deferArgs</span>(d))
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#900;font-weight:700>memmove</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>arg0), <span style=color:#900;font-weight:700>deferArgs</span>(d), <span style=color:#0086b3>uintptr</span>(d.siz)) <span style=color:#998;font-style:italic>// 移动参数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	}
</span></span><span style=display:flex><span>	fn <span style=color:#000;font-weight:700>:=</span> d.fn
</span></span><span style=display:flex><span>	d.fn = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	gp._defer = d.link
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>freedefer</span>(d)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	_ = fn.fn
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>jmpdefer</span>(fn, <span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>arg0)))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>免不了还是要看一下代码，不然的话很难讲清楚。</p><p>因为我们是在遍历 <code>_defer</code> 链表，所以得有一个终止的条件：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>d <span style=color:#000;font-weight:700>:=</span> gp._defer
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> d <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是当 _defer 链表为空的时候，终止遍历。在后面的代码里会看到，每执行完一个被 defered 的函数后，都会将 _defer 结构体从链表中删除并回收，所以 _defer 链表会越来越短。</p><p><code>switch</code> 语句里要做的就是准备好被 defered 的函数（例子中就是 sum 函数）所需要的 a，b 两个 int 型参数。参数从哪来呢？从 _defer 结构体相邻的位置，还记得吗，这是在 deferproc 函数里 copy 过去的。<code>deferArgs(d)</code> 返回的就是当时 copy 的目的地址。那现在要拷贝到哪去呢？答案是：<code>unsafe.Pointer(&arg0)</code>。我们知道，arg0 是 deferreturn 函数的参数，我们又知道，在 Go 汇编中，一个函数的参数是由它的主调函数准备的。因此 arg0 的地址实际上就是它的上层函数（在这里就是 f 函数）的栈上放参数的位置。</p><p>函数的最后，通过 <code>jmpdefer</code> 跳转到被 defered 的 sum 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#900;font-weight:700>jmpdefer</span>(fn, <span style=color:#0086b3>uintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>arg0)))
</span></span></code></pre></div><p>核心在于 jmpdefer 所做的事：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#900;font-weight:700>TEXT</span> <span style=color:teal>runtime</span><span style=color:#a61717;background-color:#e3d2d2>·</span><span style=color:teal>jmpdefer</span>(<span style=color:teal>SB</span>), <span style=color:teal>NOSPLIT</span>, <span style=color:teal>$0-16</span>
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>MOVQ</span>	<span style=color:teal>fv</span><span style=color:#a61717;background-color:#e3d2d2>+</span><span style=color:#099>0</span>(<span style=color:teal>FP</span>), <span style=color:teal>DX</span>	<span style=color:#998;font-style:italic>// fn // defer 的函数的地址
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>MOVQ</span>	<span style=color:teal>argp</span><span style=color:#a61717;background-color:#e3d2d2>+</span><span style=color:#099>8</span>(<span style=color:teal>FP</span>), <span style=color:teal>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>LEAQ</span>	-<span style=color:#099>8</span>(<span style=color:teal>BX</span>), <span style=color:teal>SP</span>	<span style=color:#998;font-style:italic>// caller sp after CALL
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>MOVQ</span>	-<span style=color:#099>8</span>(<span style=color:teal>SP</span>), <span style=color:teal>BP</span>	<span style=color:#998;font-style:italic>// restore BP as if deferreturn returned (harmless if framepointers not in use)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>SUBQ</span>	<span style=color:teal>$5</span>, (<span style=color:teal>SP</span>)	<span style=color:#998;font-style:italic>// return to CALL again
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#900;font-weight:700>MOVQ</span>	<span style=color:#099>0</span>(<span style=color:teal>DX</span>), <span style=color:teal>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>JMP</span>	<span style=color:teal>BX</span>	<span style=color:#998;font-style:italic>// but first run the deferred function
</span></span></span></code></pre></div><p>首先将 sum 函数的地址放到 DX 寄存器中，最后通过 JMP 指令去执行。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#900;font-weight:700>MOVQ</span>	<span style=color:teal>argp</span><span style=color:#a61717;background-color:#e3d2d2>+</span><span style=color:#099>8</span>(<span style=color:teal>FP</span>), <span style=color:teal>BX</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>LEAQ</span>	-<span style=color:#099>8</span>(<span style=color:teal>BX</span>), <span style=color:teal>SP</span>	<span style=color:#998;font-style:italic>// caller sp after CALL // 执行 CALL 指令后 f 函数的栈顶
</span></span></span></code></pre></div><p>这两行实际上是调整了下当前 SP 寄存器的值，因为 argp+8(FP) 实际上是 jmpdefer 的第二个参数（它在 deferreturn 函数中），它指向 f 函数栈帧中的刚被 copy 过来的 sum 函数的参数。而 <code>-8(BX)</code> 就代表了 f 函数调用 deferreturn 的返回地址，实际上就是 deferreturn 函数的下一条指令地址。</p><p>接着，<code>MOVQ -8(SP), BP</code> 这条指令则重置了 BP 寄存器，使它指向了 f 栈帧 的 BP。这样，SP、BP 寄存器回到了 f 函数调用 deferreturn 之前的状态：f 刚准备好调用 deferreturn 的参数，并且把返回值压栈了。相当于抛弃了 deferreturn 函数的栈帧，不过，确实也没什么用了。</p><p>接着 <code>SUBQ $5, (SP)</code> 把返回地址减少了 5B，刚好是一个 CALL 指令的长度。什么意思？当执行完 deferreturn 函数之后，执行流程会返回到 <code>CALL deferreturn</code> 的下一条指令，将这个值减少 5B，也就又回到了 <code>CALL deferreturn</code> 指令，从而实现了“递归地”调用 deferreturn 函数的效果。当然，栈却不会在增长！</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213332.png><img class=mx-auto alt="执行 jmpdefer" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213332.png></a></p><p><code>jmpdefer</code> 函数的最后会执行 sum 函数，看起来就像是 f 函数亲自调用 sum 函数一样，参数、返回值都是就绪的。</p><p>等到 sum 函数执行完，执行流程就会跳转到 <code>call deferreturn</code> 指令处重新进入 deferreturn 函数，遍历完所有的 _defer 结构体，执行完所有的被 defered 的函数，才真正执行完 deferretrun 函数。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213438.png><img class=mx-auto alt="重新调用 deferreturn" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213438.png></a></p><p>到这里，全文就结束了。我们可以看到，实现遍历 defer 链表的关键就是 jmpdefer 函数所做的一些“见不得人”的工作，将调用 deferreturn 函数的返回地址减少了 5 个字节，使得被 defered 的函数执行完后，又回到 <code>CALL deferreturn</code> 指令处，从而实现“递归地”调用 deferreturn 函数，完成 _defer 链表的遍历。</p><h1 id=参考资料>参考资料</h1><p>【阿波张 defer 源码分析】 <a href=https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g>https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g</a></p><p>【阿波张 panic&recover】 <a href=https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw>https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw</a></p><p>【阿波张 defer 基础】 <a href=https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw>https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw</a></p><p>【汇编分析】 <a href="https://segmentfault.com/a/1190000019804120?utm_medium=referral&utm_source=tuicool">https://segmentfault.com/a/1190000019804120?utm_medium=referral&utm_source=tuicool</a></p><p>【曹大 Go 汇编分享】 <a href=https://github.com/cch123/asmshare/blob/master/layout.md>https://github.com/cch123/asmshare/blob/master/layout.md</a></p><p>【曹大 Go 汇编】 <a href=https://xargin.com/plan9-assembly>https://xargin.com/plan9-assembly</a></p><p>【曹大利用汇编写的 goid 获取】 <a href=https://github.com/cch123/goroutineid>https://github.com/cch123/goroutineid</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/how-to-traverse-defer-links/>https://qcrao.com/post/how-to-traverse-defer-links/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>