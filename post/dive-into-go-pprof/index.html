<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 Go 语言之 pprof | qcrao 的博客</title><meta property="og:title" content="深度解密 Go 语言之 pprof - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-11-10T22:25:48+08:00"><meta property="article:modified_time" content="2019-11-10T22:25:48+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 Go 语言之 pprof"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-go-pprof/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 Go 语言之 pprof</h1></header><date class="post-meta meta-date">2019年11月10日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>相信很多人都听过“雷神 3”关于性能优化的故事。在一个 3D 游戏引擎的源码里，John Carmack 将 <code>1/sqrt(x)</code> 这个函数的执行效率优化到了极致。</p><p>一般我们使用二分法，或者牛顿迭代法计算一个浮点数的平方根。但在这个函数里，作者使用了一个“魔数”，根本没有迭代，两步就直接算出了平方根。令人叹为观止！</p><p>因为它是最底层的函数，而游戏里涉及到大量的这种运算，使得在运算资源极其紧张的 DOS 时代，游戏也可以流畅地运行。这就是性能优化的魅力！</p><p>工作中，当业务量比较小的时候，用的机器也少，体会不到性能优化带来的收益。而当一个业务使用了几千台机器的时候，性能优化 20%，那就能省下几百台机器，一年能省几百万。省下来的这些钱，给员工发年终奖，那得多 Happy！</p><p>一般而言，性能分析可以从三个层次来考虑：应用层、系统层、代码层。</p><p>应用层主要是梳理业务方的使用方式，让他们更合理地使用，在满足使用方需求的前提下，减少无意义的调用；系统层关注服务的架构，例如增加一层缓存；代码层则关心函数的执行效率，例如使用效率更高的开方算法等。</p><p>做任何事，都要讲究方法。在很多情况下，迅速把事情最关键的部分完成，就能拿到绝大部分的收益了。其他的一些边边角角，可以慢慢地缝合。一上来就想完成 100%，往往会陷入付出了巨大的努力，却收获寥寥的境地。</p><p>性能优化这件事也一样，识别出性能瓶颈，会让我们付出最小的努力，而得到最大的回报。</p><p>Go 语言里，pprof 就是这样一个工具，帮助我们快速找到性能瓶颈，进而进行有针对性地优化。</p><h1 id=什么是-pprof>什么是 pprof</h1><p>代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性能算是有个底。</p><p>但是压测是线下的模拟流量，如果到了线上呢？会遇到高并发、大流量，不靠谱的上下游，突发的尖峰流量等等场景，这些都是不可预知的。</p><p>线上突然大量报警，接口超时，错误数增加，除了看日志、监控，就是用性能分析工具分析程序的性能，找到瓶颈。当然，一般这种情形不会让你有机会去分析，降级、限流、回滚才是首先要做的，要先止损嘛。回归正常之后，通过线上流量回放，或者压测等手段，制造性能问题，再通过工具来分析系统的瓶颈。</p><p>一般而言，性能分析主要关注 CPU、内存、磁盘 IO、网络这些指标。</p><p><code>Profiling</code> 是指在程序执行过程中，收集能够反映程序执行状态的数据。在软件工程中，性能分析（performance analysis，也称为 profiling），是以收集程序运行时信息为手段研究程序行为的分析方法，是一种动态程序分析的方法。</p><p>Go 语言自带的 pprof 库就可以分析程序的运行情况，并且提供可视化的功能。它包含两个相关的库：</p><ul><li><p>runtime/pprof
对于只跑一次的程序，例如每天只跑一次的离线预处理程序，调用 pprof 包提供的函数，手动开启性能数据采集。</p></li><li><p>net/http/pprof
对于在线服务，对于一个 HTTP Server，访问 pprof 提供的 HTTP 接口，获得性能数据。当然，实际上这里底层也是调用的 runtime/pprof 提供的函数，封装成接口对外提供网络访问。</p></li></ul><h1 id=pprof-的作用>pprof 的作用</h1><p><code>pprof</code> 是 Go 语言中分析程序运行性能的工具，它能提供各种性能数据：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68523507-3ce36500-02f5-11ea-8e8f-438c9ef2b9f8.png><img class=mx-auto alt="pprof 采集的信息类型" src=https://user-images.githubusercontent.com/7698088/68523507-3ce36500-02f5-11ea-8e8f-438c9ef2b9f8.png></a></p><p><code>allocs</code> 和 <code>heap</code> 采样的信息一致，不过前者是所有对象的内存分配，而 heap 则是活跃对象的内存分配。</p><blockquote><p>The difference between the two is the way the pprof tool reads there at start time. Allocs profile will start pprof in a mode which displays the total number of bytes allocated since the program began (including garbage-collected bytes).</p></blockquote><p>上图来自参考资料【wolfogre】的一篇 pprof 实战的文章，提供了一个样例程序，通过 pprof 来排查、分析、解决性能问题，非常精彩。</p><blockquote><ol><li><p>当 CPU 性能分析启用后，Go runtime 会每 10ms 就暂停一下，记录当前运行的 goroutine 的调用堆栈及相关数据。当性能分析数据保存到硬盘后，我们就可以分析代码中的热点了。</p></li><li><p>内存性能分析则是在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的。</p></li><li><p>阻塞分析是一个很独特的分析，它有点儿类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，在排除 CPU 和内存瓶颈前，不应该用它来分析。</p></li></ol></blockquote><h1 id=pprof-如何使用>pprof 如何使用</h1><blockquote><p>我们可以通过 <code>报告生成</code>、<code>Web 可视化界面</code>、<code>交互式终端</code> 三种方式来使用 <code>pprof</code>。</p><p>—— 煎鱼《Golang 大杀器之性能剖析 PProf》</p></blockquote><h2 id=runtimepprof>runtime/pprof</h2><p>拿 CPU profiling 举例，增加两行代码，调用 <code>pprof.StartCPUProfile</code> 启动 cpu profiling，调用 <code>pprof.StopCPUProfile()</code> 将数据刷到文件里：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#d14>&#34;runtime/pprof&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> cpuprofile = flag.<span style=color:#900;font-weight:700>String</span>(<span style=color:#d14>&#34;cpuprofile&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, <span style=color:#d14>&#34;write cpu profile to file&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// …………
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>        
</span></span><span style=display:flex><span>    pprof.<span style=color:#900;font-weight:700>StartCPUProfile</span>(f)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>defer</span> pprof.<span style=color:#900;font-weight:700>StopCPUProfile</span>()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// …………
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><h2 id=nethttppprof>net/http/pprof</h2><p>启动一个端口（和正常提供业务服务的端口不同）监听 pprof 请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> _ <span style=color:#d14>&#34;net/http/pprof&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>initPprofMonitor</span>() <span style=color:#458;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	pPort <span style=color:#000;font-weight:700>:=</span> global.Conf.<span style=color:#900;font-weight:700>MustInt</span>(<span style=color:#d14>&#34;http_server&#34;</span>, <span style=color:#d14>&#34;pprofport&#34;</span>, <span style=color:#099>8080</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> err <span style=color:#458;font-weight:700>error</span>
</span></span><span style=display:flex><span>	addr <span style=color:#000;font-weight:700>:=</span> <span style=color:#d14>&#34;:&#34;</span> <span style=color:#000;font-weight:700>+</span> strconv.<span style=color:#900;font-weight:700>Itoa</span>(pPort)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		err = http.<span style=color:#900;font-weight:700>ListenAndServe</span>(addr, <span style=color:#000;font-weight:700>nil</span>)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			logger.<span style=color:#900;font-weight:700>Error</span>(<span style=color:#d14>&#34;funcRetErr=http.ListenAndServe||err=%s&#34;</span>, err.<span style=color:#900;font-weight:700>Error</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>pprof</code> 包会自动注册 handler， 处理相关的请求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/net/http/pprof/pprof.go:71
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>init</span>() {
</span></span><span style=display:flex><span>	http.<span style=color:#900;font-weight:700>Handle</span>(<span style=color:#d14>&#34;/debug/pprof/&#34;</span>, http.<span style=color:#900;font-weight:700>HandlerFunc</span>(Index))
</span></span><span style=display:flex><span>	http.<span style=color:#900;font-weight:700>Handle</span>(<span style=color:#d14>&#34;/debug/pprof/cmdline&#34;</span>, http.<span style=color:#900;font-weight:700>HandlerFunc</span>(Cmdline))
</span></span><span style=display:flex><span>	http.<span style=color:#900;font-weight:700>Handle</span>(<span style=color:#d14>&#34;/debug/pprof/profile&#34;</span>, http.<span style=color:#900;font-weight:700>HandlerFunc</span>(Profile))
</span></span><span style=display:flex><span>	http.<span style=color:#900;font-weight:700>Handle</span>(<span style=color:#d14>&#34;/debug/pprof/symbol&#34;</span>, http.<span style=color:#900;font-weight:700>HandlerFunc</span>(Symbol))
</span></span><span style=display:flex><span>	http.<span style=color:#900;font-weight:700>Handle</span>(<span style=color:#d14>&#34;/debug/pprof/trace&#34;</span>, http.<span style=color:#900;font-weight:700>HandlerFunc</span>(Trace))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一个路径 <code>/debug/pprof/</code> 下面其实还有 5 个子路径：</p><blockquote><p>goroutine
threadcreate
heap
block
mutex</p></blockquote><p>启动服务后，直接在浏览器访问：</p><blockquote><p>http://47.93.238.9:8080/debug/pprof/</p></blockquote><p>就可以得到一个汇总页面：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68526001-46c79100-0312-11ea-9a7f-7eb41cf482d6.png><img class=mx-auto alt="页面 /debug/pprof" src=https://user-images.githubusercontent.com/7698088/68526001-46c79100-0312-11ea-9a7f-7eb41cf482d6.png></a></p><p>可以直接点击上面的链接，进入子页面，查看相关的汇总信息。</p><p>关于 goroutine 的信息有两个链接，<code>goroutine</code> 和 <code>full goroutine stack dump</code>，前者是一个汇总的消息，可以查看 goroutines 的总体情况，后者则可以看到每一个 goroutine 的状态。页面具体内容的解读可以参考【大彬】的文章。</p><p>点击 <code>profile</code> 和 <code>trace</code> 则会在后台进行一段时间的数据采样，采样完成后，返回给浏览器一个 profile 文件，之后在本地通过 <code>go tool pprof</code> 工具进行分析。</p><p>当我们下载得到了 profile 文件后，执行命令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go tool pprof ~/Downloads/profile
</span></span></code></pre></div><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68529660-bb62f580-033b-11ea-9ff3-67630ce1d21f.png><img class=mx-auto alt="pprof profile" src=https://user-images.githubusercontent.com/7698088/68529660-bb62f580-033b-11ea-9ff3-67630ce1d21f.png></a></p><p>就可以进入命令行交互式使用模式。执行 <code>go tool pprof -help</code> 可以查看帮助信息。</p><p>直接使用如下命令，则不需要通过点击浏览器上的链接就能进入命令行交互模式：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go tool pprof http://47.93.238.9:8080/debug/pprof/profile
</span></span></code></pre></div><p>当然也是需要先后台采集一段时间的数据，再将数据文件下载到本地，最后进行分析。上述的 Url 后面还可以带上时间参数：<code>?seconds=60</code>，自定义 CPU Profiling 的时长。</p><p>类似的命令还有：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>#</span> <span style=color:#a61717;background-color:#e3d2d2>下载</span> cpu profile<span style=color:#a61717;background-color:#e3d2d2>，默认从当前开始收集</span> <span style=color:#099>30</span>s <span style=color:#a61717;background-color:#e3d2d2>的</span> cpu <span style=color:#a61717;background-color:#e3d2d2>使用情况，需要等待</span> <span style=color:#099>30</span>s
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/profile
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#a61717;background-color:#e3d2d2>#</span> wait <span style=color:#099>120</span>s
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/profile?seconds=120     
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>#</span> <span style=color:#a61717;background-color:#e3d2d2>下载</span> heap profile
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/heap
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>#</span> <span style=color:#a61717;background-color:#e3d2d2>下载</span> goroutine profile
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/goroutine
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>#</span> <span style=color:#a61717;background-color:#e3d2d2>下载</span> block profile
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/block
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>#</span> <span style=color:#a61717;background-color:#e3d2d2>下载</span> mutex profile
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof http:<span style=color:#998;font-style:italic>//47.93.238.9:8080/debug/pprof/mutex
</span></span></span></code></pre></div><p>进入交互式模式之后，比较常用的有 <code>top</code>、<code>list</code>、<code>web</code> 等命令。</p><p>执行 <code>top</code>：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68526610-ea1ba480-0318-11ea-9a13-ea49a1b849b0.png><img class=mx-auto alt="pprof top" src=https://user-images.githubusercontent.com/7698088/68526610-ea1ba480-0318-11ea-9a13-ea49a1b849b0.png></a></p><p>得到四列数据：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>flat</td><td>本函数的执行耗时</td></tr><tr><td>flat%</td><td>flat 占 CPU 总时间的比例。程序总耗时 16.22s, Eat 的 16.19s 占了 99.82%</td></tr><tr><td>sum%</td><td>前面每一行的 flat 占比总和</td></tr><tr><td>cum</td><td>累计量。指该函数加上该函数调用的函数总耗时</td></tr><tr><td>cum%</td><td>cum 占 CPU 总时间的比例</td></tr></tbody></table><p>其他类型，如 heap 的 flat, sum, cum 的意义和上面的类似，只不过计算的东西不同，一个是 CPU 耗时，一个是内存大小。</p><p>执行 <code>list</code>，使用<code>正则</code>匹配，找到相关的代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>list Eat
</span></span></code></pre></div><p>直接定位到了相关长耗时的代码处：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68526943-34eaeb80-031c-11ea-8d3d-c3e103c5a8a0.png><img class=mx-auto alt="pprof list" src=https://user-images.githubusercontent.com/7698088/68526943-34eaeb80-031c-11ea-8d3d-c3e103c5a8a0.png></a></p><p>执行 <code>web</code>（需要安装 graphviz，pprof 能够借助 grapgviz 生成程序的调用图），会生成一个 svg 格式的文件，直接在浏览器里打开（可能需要设置一下 .svg 文件格式的默认打开方式）：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68526883-9c546b80-031b-11ea-86be-ebe59c7cccad.png><img class=mx-auto alt="pprof web" src=https://user-images.githubusercontent.com/7698088/68526883-9c546b80-031b-11ea-86be-ebe59c7cccad.png></a></p><p>图中的连线代表对方法的调用，连线上的标签代表指定的方法调用的采样值（例如时间、内存分配大小等），方框的大小与方法运行的采样值的大小有关。</p><p>每个方框由两个标签组成：在 cpu profile 中，一个是方法运行的时间占比，一个是它在采样的堆栈中出现的时间占比（前者是 flat 时间，后者则是 cumulate 时间占比)；框越大，代表耗时越多或是内存分配越多。</p><p>另外，<code>traces</code> 命令还可以列出函数的调用栈：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68537697-6b1f7e00-03a3-11ea-9d68-d7bdd12c38a4.png><img class=mx-auto alt="pprof traces" src=https://user-images.githubusercontent.com/7698088/68537697-6b1f7e00-03a3-11ea-9d68-d7bdd12c38a4.png></a></p><p>除了上面讲到的两种方式（报告生成、命令行交互），还可以在浏览器里进行交互。先生成 profile 文件，再执行命令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go tool pprof --http<span style=color:#000;font-weight:700>=</span>:8080 ~/Downloads/profile
</span></span></code></pre></div><p>进入一个可视化操作界面：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68528770-214a7f80-0332-11ea-9ed9-b3b80a244fb5.png><img class=mx-auto alt="pprof 可视化界面" src=https://user-images.githubusercontent.com/7698088/68528770-214a7f80-0332-11ea-9ed9-b3b80a244fb5.png></a></p><p>点击菜单栏可以在：Top/Graph/Peek/Source 之间进行切换，甚至可以看到火焰图（Flame Graph）：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68528787-48a14c80-0332-11ea-8e9f-1cf730a02083.png><img class=mx-auto alt="pprof 火焰图" src=https://user-images.githubusercontent.com/7698088/68528787-48a14c80-0332-11ea-8e9f-1cf730a02083.png></a></p><p>它和一般的火焰图相比刚好倒过来了，调用关系的展现是从上到下。形状越长，表示执行时间越长。注：我这里使用的 go 版本是 1.13，更老一些的版本 pprof 工具不支持 <code>-http</code> 的参数。当然也可以下载其他的库查看火焰图，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/google/pprof
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>或者
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>go get github.com/uber/go-torch
</span></span></code></pre></div><h1 id=pprof-进阶>pprof 进阶</h1><p>我在参考资料部分给出了一些使用 pprof 工具进行性能分析的实战文章，可以跟着动手实践一下，之后再用到自己的平时工作中。</p><h2 id=russ-cox-实战>Russ Cox 实战</h2><p>这部分主要内容来自参考资料【Ross Cox】，学习一下大牛的优化思路。</p><p>事情的起因是这样的，有人发表了一篇文章，用各种语言实现了一个算法，结果用 go 写的程序非常慢，而 C++ 则最快。然后 Russ Cox 就鸣不平了，哪受得了这个气？马上启用 pprof 大杀器进行优化。最后，程序不仅更快，而且使用的内存更少了！</p><p>首先，增加 cpu profiling 的代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> cpuprofile = flag.<span style=color:#900;font-weight:700>String</span>(<span style=color:#d14>&#34;cpuprofile&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, <span style=color:#d14>&#34;write cpu profile to file&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    flag.<span style=color:#900;font-weight:700>Parse</span>()
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> <span style=color:#000;font-weight:700>*</span>cpuprofile <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> {
</span></span><span style=display:flex><span>        f, err <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Create</span>(<span style=color:#000;font-weight:700>*</span>cpuprofile)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#900;font-weight:700>Fatal</span>(err)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        pprof.<span style=color:#900;font-weight:700>StartCPUProfile</span>(f)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>defer</span> pprof.<span style=color:#900;font-weight:700>StopCPUProfile</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 pprof 观察耗时 <code>top5</code> 的函数，发现一个读 map 的函数耗时最长：<code>mapaccess1_fast64</code>，而它出现在一个递归函数中。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68537368-47593980-039d-11ea-8c77-187b4760b866.png><img class=mx-auto alt=web src=https://user-images.githubusercontent.com/7698088/68537368-47593980-039d-11ea-8c77-187b4760b866.png></a></p><p>一眼就能看到框最大的 <code>mapacess1_fast64</code> 函数。执行 <code>web mapaccess1</code> 命令，更聚焦一些：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68537381-88e9e480-039d-11ea-9c7b-3741f791cbc9.png><img class=mx-auto alt="web mapaccess1" src=https://user-images.githubusercontent.com/7698088/68537381-88e9e480-039d-11ea-9c7b-3741f791cbc9.png></a></p><p>调用 <code>mapaccess1_fast64</code> 函数最多的就是 main.FindLoops 和 main.DFS，是时候定位到具体的代码了，执行命令：<code>list DFS</code>，定位到相关的代码。</p><p>优化的方法是将 map 改成 slice，能这样做的原因当然和 key 的类型是 int 而且不是太稀疏有关。</p><blockquote><p>The take away will be that for smaller data sets, you shouldn’t use maps where slices would suffice, as maps have a large overhead.</p></blockquote><p>修改完之后，再次通过 cpu profiling，发现递归函数的耗时已经不在 top5 中了。但是新增了长耗时函数：runtime.mallocgc，占比 54.2%，而这和分存分配以及垃圾回收相关。</p><p>下一步，增加采集内存数据的代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> memprofile = flag.<span style=color:#900;font-weight:700>String</span>(<span style=color:#d14>&#34;memprofile&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, <span style=color:#d14>&#34;write memory profile to this file&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// …………
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>FindHavlakLoops</span>(cfgraph, lsgraph)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> <span style=color:#000;font-weight:700>*</span>memprofile <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> {
</span></span><span style=display:flex><span>        f, err <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>Create</span>(<span style=color:#000;font-weight:700>*</span>memprofile)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#900;font-weight:700>Fatal</span>(err)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pprof.<span style=color:#900;font-weight:700>WriteHeapProfile</span>(f)
</span></span><span style=display:flex><span>        f.<span style=color:#900;font-weight:700>Close</span>()
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// …………
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>继续通过 <code>top5</code>、<code>list</code> 命令找到内存分配最多的代码位置，发现这回是向 map 里插入元素使用的内存比较多。改进方式同样是用 slice 代替 map，但 map 还有一个特点是可以重复插入元素，因此新写了一个向 slice 插入元素的函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>appendUnique</span>(a []<span style=color:#458;font-weight:700>int</span>, x <span style=color:#458;font-weight:700>int</span>) []<span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> _, y <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> a {
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>==</span> y {
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>return</span> a
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>append</span>(a, x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>好了，现在程序比最初的时候快了 2.1 倍。再次查看 cpu profile 数据，发现 <code>runtime.mallocgc</code> 降了一些，但仍然占比 50.9%。</p><blockquote><p>Another way to look at why the system is garbage collecting is to look at the allocations that are causing the collections, the ones that spend most of the time in mallocgc.</p></blockquote><p>因此需要查看垃圾回收到底在回收哪些内容，这些内容就是导致频繁垃圾回收的“罪魁祸首”。</p><p>使用 <code>web mallocgc</code> 命令，将和 mallocgc 相关的函数用矢量图的方式展现出来，但是有太多样本量很少的节点影响观察，增加过滤命令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> tool pprof <span style=color:#000;font-weight:700>--</span>nodefraction=<span style=color:#099>0.1</span> profile
</span></span></code></pre></div><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/68537420-13cadf00-039e-11ea-98d9-f215a0eaabb8.png><img class=mx-auto alt="web mallocgc" src=https://user-images.githubusercontent.com/7698088/68537420-13cadf00-039e-11ea-98d9-f215a0eaabb8.png></a></p><p>将少于 <code>10%</code> 的采样点过滤掉，新的矢量图可以直观地看出，<code>FindLoops</code> 触发了最多的垃圾回收操作。继续使用命令 <code>list FindLoops</code> 直接找到代码的位置。</p><p>原来，每次执行 <code>FindLoops</code> 函数时，都要 <code>make</code> 一些临时变量，这会加重垃圾回收器的负担。改进方式是增加一个全局变量 cache，可以重复利用。坏处是，现在不是线程安全的了。</p><p>使用 pprof 工具进行的优化到这就结束了。最后的结果很不错，基本上能达到和 C++ 同等的速度和同等的内存分配大小。</p><p>我们能得到的启发就是先使用 cpu profile 找出耗时最多的函数，进行优化。如果发现 gc 执行比较多的时候，找出内存分配最多的代码以及引发内存分配的函数，进行优化。</p><p>原文很精彩，虽然写作时间比较久远（最初写于 2011 年）了，但仍然值得一看。另外，参考资料【wolfogre】的实战文章也非常精彩，而且用的招式和这篇文章差不多，但是你可以运行文章提供的样例程序，一步步地解决性能问题，很有意思！</p><h2 id=查找内存泄露>查找内存泄露</h2><p>内存分配既可以发生在堆上也可以在栈上。堆上分配的内存需要垃圾回收或者手动回收（对于没有垃圾回收的语言，例如 C++），栈上的内存则通常在函数退出后自动释放。</p><p>Go 语言通过逃逸分析会将尽可能多的对象分配到栈上，以使程序可以运行地更快。</p><p>这里说明一下，有两种内存分析策略：一种是当前的（这一次采集）内存或对象的分配，称为 <code>inuse</code>；另一种是从程序运行到现在所有的内存分配，不管是否已经被 gc 过了，称为 <code>alloc</code>。</p><blockquote><p>As mentioned above, there are two main memory analysis strategies with pprof. One is around looking at the current allocations (bytes or object count), called inuse. The other is looking at all the allocated bytes or object count throughout the run-time of the program, called alloc. This means regardless if it was gc-ed, a summation of everything sampled.</p></blockquote><p>加上 <code>-sample_index</code> 参数后，可以切换内存分析的类型：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go tool pprof -sample_index<span style=color:#000;font-weight:700>=</span>alloc_space  http://47.93.238.9:8080/debug/pprof/heap
</span></span></code></pre></div><p>共有 4 种：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>inuse_space</td><td>amount of memory allocated and not released yet</td></tr><tr><td>inuse_objects</td><td>amount of objects allocated and not released yet</td></tr><tr><td>alloc_space</td><td>total amount of memory allocated (regardless of released)</td></tr><tr><td>alloc_objects</td><td>total amount of objects allocated (regardless of released)</td></tr></tbody></table><p>参考资料【大彬 实战内存泄露】讲述了如何通过类似于 diff 的方式找到前后两个时刻多出的 goroutine，进而找到 goroutine 泄露的原因，并没有直接使用 heap 或者 goroutine 的 profile 文件。同样推荐阅读！</p><h1 id=总结>总结</h1><p><code>pprof</code> 是进行 Go 程序性能分析的有力工具，它通过采样、收集运行中的 Go 程序性能相关的数据，生成 profile 文件。之后，提供三种不同的展现形式，让我们能更直观地看到相关的性能数据。</p><p>得到性能数据后，可以使用 <code>top</code>、<code>web</code>、<code>list</code>等命令迅速定位到相应的代码处，并进行优化。</p><p>“过早的优化是万恶之源”。实际工作中，很少有人会关注性能，但当你写出的程序存在性能瓶颈，qa 压测时，qps 上不去，为了展示一下技术实力，还是要通过 pprof 观察性能瓶颈，进行相应的性能优化。</p><h1 id=参考资料>参考资料</h1><p>【曹大 pprof】 <a href=https://xargin.com/pprof-and-flamegraph/>https://xargin.com/pprof-and-flamegraph/</a></p><p>【Russ Cox 优化过程，并附上代码】 <a href=https://blog.golang.org/profiling-go-programs>https://blog.golang.org/profiling-go-programs</a></p><p>【google pprof】 <a href=https://github.com/google/pprof>https://github.com/google/pprof</a></p><p>【使用 pprof 和火焰图调试 golang 应用】 <a href=https://cizixs.com/2017/09/11/profiling-golang-program/>https://cizixs.com/2017/09/11/profiling-golang-program/</a></p><p>【资源合集】 <a href=https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/>https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/</a></p><p>【Profiling your Golang app in 3 steps】 <a href=https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/>https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/</a></p><p>【案例，压测 Golang remote profiling and flamegraphs】 <a href=https://matoski.com/article/golang-profiling-flamegraphs/>https://matoski.com/article/golang-profiling-flamegraphs/</a></p><p>【煎鱼 pprof】 <a href=https://segmentfault.com/a/1190000016412013>https://segmentfault.com/a/1190000016412013</a></p><p>【鸟窝 pprof】 <a href=https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/>https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/</a></p><p>【关于 Go 的 7 种性能分析方法】 <a href=https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html>https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html</a></p><p>【pprof 比较全】 <a href=https://juejin.im/entry/5ac9cf3a518825556534c76e>https://juejin.im/entry/5ac9cf3a518825556534c76e</a></p><p>【通过实例来讲解分析、优化过程】 <a href=https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/>https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/</a></p><p>【Go 作者 Dmitry Vyukov】 <a href=https://github.com/golang/go/wiki/Performance>https://github.com/golang/go/wiki/Performance</a></p><p>【wolfogre 非常精彩的实战文章】 <a href=https://blog.wolfogre.com/posts/go-ppof-practice/>https://blog.wolfogre.com/posts/go-ppof-practice/</a></p><p>【dave.cheney】 <a href=https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html>https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html</a></p><p>【实战案例】 <a href=https://www.cnblogs.com/sunsky303/p/11058808.html>https://www.cnblogs.com/sunsky303/p/11058808.html</a></p><p>【大彬 实战内存泄露】 <a href=https://segmentfault.com/a/1190000019222661>https://segmentfault.com/a/1190000019222661</a></p><p>【查找内存泄露】 <a href=https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/>https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/</a></p><p>【雷神 3 性能优化】 <a href=https://diducoder.com/sotry-about-sqrt.html>https://diducoder.com/sotry-about-sqrt.html</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-go-pprof/>https://qcrao.com/post/dive-into-go-pprof/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/how-to-write-a-things3-client/ title="如何写一个 things3 client">如何写一个 things3 client</a></li><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>