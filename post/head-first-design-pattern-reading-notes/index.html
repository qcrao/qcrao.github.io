<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>《Head First 设计模式》读书笔记 | qcrao 的博客</title><meta property="og:title" content="《Head First 设计模式》读书笔记 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-05-10T22:50:12+08:00"><meta property="article:modified_time" content="2020-05-10T22:50:12+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="《Head First 设计模式》读书笔记"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/head-first-design-pattern-reading-notes/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>《Head First 设计模式》读书笔记</h1></header><date class="post-meta meta-date">2020年5月10日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><h1 id=第一章-设计模式入门>第一章 设计模式入门</h1><blockquote><p>使用模式最好的方式是：”把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”</p></blockquote><p>通过一个给 Duck 类型添加 fly 功能的实例，一步步地提出解决方案。</p><p>先是使用继承，但是继承并不能很好地解决问题，因为鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当的。</p><p>接着又提出使用接口，但是 Java 接口不具有实现代码，所以继承接口无法达到代码的复用。这意味着: 无论何时你需要修改某个行为，你必须得往下追踪并在每一个定义此行为的类中修改它，一不小心，可能会造成新的错误!</p><p>进而提出了第一个设计原则：</p><blockquote><p>设计原则一：封装变化。找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p></blockquote><p>这样的概念很简单，几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510222131.png><img class=mx-auto alt=取出易于变化的部分 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510222131.png></a></p><blockquote><p>设计原则二：针对接口编程，而不是针对实现编程。</p></blockquote><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510223436.png><img class=mx-auto alt=接口和对应的类 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510223436.png></a></p><p>关键在于，鸭子现在会将飞行和呱呱叫的动作“委托”(delegate)别人处理，而不是使用定义在 Duck 类(或子类)内的呱呱叫和飞行方法。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510224745.png><img class=mx-auto alt=整合鸭子的行为 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510224745.png></a></p><blockquote><p>设计原则三：多用组合，少用继承。</p></blockquote><h1 id=第二章-观察者模式>第二章 观察者模式</h1><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103228.png><img class=mx-auto alt=观察者模式 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103228.png></a></p><blockquote><p>定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><p>类图如下：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103804.png><img class=mx-auto alt=类图 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103804.png></a></p><blockquote><p>设计原则四：为了交互对象之间的松耦合设计而努力。</p></blockquote><p>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p><h1 id=第三章-装饰者模式>第三章 装饰者模式</h1><blockquote><p>设计原则五：类应该对扩展开放，对修改关闭。</p></blockquote><p>怎么理解呢？允许系统在不修改代码的情况下，进行功能扩展。想想观察者模式（在第 2 章）&mldr;&mldr;通过加入新的观察者，我们可以在任何时候扩展 Subject（主题），而且不需向主题中添加代码。</p><blockquote><p>要让 OO 设计同时具备开放性和关闭性，又不修改现有的代码，需要花费许多时间和努力。一般来说，我们实在没有闲工夫把设计的每个部分都这么设计（而且，就算做得到， 也可能只是一种浪费）。遵循<code>开放-关闭</code>原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用<code>开放-关闭</code>原则。</p></blockquote><blockquote><p>定义：装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><p>类图：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516112728.png><img class=mx-auto alt=类图 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516112728.png></a></p><h1 id=第四章-工厂模式>第四章 工厂模式</h1><h2 id=简单工厂>简单工厂</h2><p>简单工厂并不是一个设计模式，它是一个编程习惯。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525114337.png><img class=mx-auto alt=简单工厂类图 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525114337.png></a></p><h2 id=工厂方法>工厂方法</h2><p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码和子类对象创建代码解耦了。</p><p>通过让子类决定该创建的对象是什么，来达到将对象的创建过程封装的目的。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115100.png><img class=mx-auto alt="工厂方法 —— pizza" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115100.png></a></p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115941.png><img class=mx-auto alt="工厂方法类图 —— pizza" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115941.png></a></p><p>创建者类和产品类可以放平：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120204.png><img class=mx-auto alt=平行的类层级 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120204.png></a></p><blockquote><p>定义：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><p>注意，上面的“决定”并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120706.png><img class=mx-auto alt=工厂方法类图 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120706.png></a></p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525121832.png><img class=mx-auto alt=简单工厂和工厂方法的工区别 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525121832.png></a></p><blockquote><p>设计原则：依赖倒置原则。要依赖抽象，不要依赖具体类。</p></blockquote><p>不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。倒置是指和一般 OO 设计的思考方式完全相反。低层组件现在依赖高层的抽象，而高层组件现在也在依赖相同的抽象。</p><h2 id=抽象工厂>抽象工厂</h2><blockquote><p>定义：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125846.png><img class=mx-auto alt=抽象工厂类图 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125846.png></a></p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125943.png><img class=mx-auto alt="抽象工厂类图 —— pizza" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125943.png></a></p><h1 id=第五章-单件模式>第五章 单件模式</h1><p>也就是我们常说的单例模式，有些对象只能有一个实例，例如线程池、数据库连接等。全局变量也可以做到这一点，但全局变量必须一开始就要创建好对象，如果一直没用到，就形成浪费了。</p><blockquote><p>定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。</p></blockquote><p>应对多线程，有三种应对方法：</p><ol><li>直接加同步原语，在 Java 中是 synchronized。很简单，可能会有一些性能问题。</li><li>使用饿汉式，启动时即创建。</li><li>用双重加锁检查，即 double-checked locking。</li></ol><p>用 Go 来实现，非常简单：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> singleton
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#d14>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//Singleton 是单例模式类
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> Singleton <span style=color:#000;font-weight:700>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> singleton <span style=color:#000;font-weight:700>*</span>Singleton
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> once sync.Once
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//GetInstance 用于获取单例模式对象
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>GetInstance</span>() <span style=color:#000;font-weight:700>*</span>Singleton {
</span></span><span style=display:flex><span>	once.<span style=color:#900;font-weight:700>Do</span>(<span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		singleton = <span style=color:#000;font-weight:700>&amp;</span>Singleton{}
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> singleton
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=第六章-命令模式>第六章 命令模式</h1><blockquote><p>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作。</p></blockquote><p>命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。</p><h1 id=第七章-适配器模式和外观模式>第七章 适配器模式和外观模式</h1><p>这两个模式比较简单，工作中也用得比较多，只是叫不出名字。</p><blockquote><p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p></blockquote><p>有对象适配器和类适配器两类，前者使用组合，后者使用多重继承。后者的好处是不用实现目标类的所有方法。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123621.png><img class=mx-auto alt=对象适配器、类适配器 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123621.png></a></p><blockquote><p>外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><p>两者的区别：只能从意图上来区别。适配器的意图是将接口转换成不同接口；而外观模式的意图是简化接口。另外需要注意的是：虽然大多数教科书所采用的例子中适配器只适配一个类，但是实际上适配器模式也可以将多个类接口转换成客户希望的一个接口。</p><blockquote><p>设计原则七：最少知识原则。只和你的密友谈话。</p></blockquote><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123757.png><img class=mx-auto alt=外观模式 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123757.png></a></p><h1 id=第八章-模板方法模式>第八章 模板方法模式</h1><p>很多模式之前或多或少地用过，像这一章的模板方法模式，去年在重构热力图的时候就用到过。当然，那时并不知道有这么个名字，只是很自然地一个想法。所有很多东西还是最后要上升到理论层次，就感觉不一样了。</p><blockquote><p>定义：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><p>因为 Golang 不提供继承机制，需要使用匿名组合模拟实现继承。</p><p>此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。</p><h1 id=第九章-迭代器与组合模式>第九章 迭代器与组合模式</h1><blockquote><p>定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p></blockquote><blockquote><p>定义：组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p></blockquote><p>组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。</p><h1 id=参考资料>参考资料</h1><p>【读书会】 <a href=https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE>https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE</a></p><p>【设计模式中文网站】 <a href=https://refactoringguru.cn/design-patterns>https://refactoringguru.cn/design-patterns</a></p><p>【Go 设计模式】 <a href=https://github.com/senghoo/golang-design-pattern>https://github.com/senghoo/golang-design-pattern</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/head-first-design-pattern-reading-notes/>https://qcrao.com/post/head-first-design-pattern-reading-notes/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li><li><a href=https://qcrao.com/post/how-to-use-functional-options-pattern/ title="曹大带我学 Go（7）—— 如何优雅地指定配置项">曹大带我学 Go（7）—— 如何优雅地指定配置项</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>