<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>曹大带我学 Go（4）—— 初始 ast 的威力 | qcrao 的博客</title><meta property="og:title" content="曹大带我学 Go（4）—— 初始 ast 的威力 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-06-01T23:26:17+08:00"><meta property="article:modified_time" content="2021-06-01T23:26:17+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="曹大带我学 Go（4）—— 初始 ast 的威力"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/getting-to-know-the-power-of-ast/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>曹大带我学 Go（4）—— 初始 ast 的威力</h1></header><date class="post-meta meta-date">2021年6月1日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>抽象语法树是编译过程中的一个中间产物，一般简单了解一下就行了。但我们可以把 Go 语言的整个 parser 和 ast 包直接拿来用，在一些场景下有很大的威力。</p><p>什么是 ast 呢，我从维基百科上摘录了一段：</p><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p></blockquote><p>核心就是说 ast 能以一种树的形式表示代码结构。有了树结构，就可以对它做遍历，能干很多事。</p><h1 id=假定一个场景>假定一个场景</h1><p>假定一个场景：我们可以从司机平台的某个接口获取司机的各种特征，例如：年龄、订单数、收入、每天驾驶时长、驾龄、平均车速、被投诉次数……数据一般采用 json 来传递。</p><p>司机平台的运营小姐姐经常需要搞一些活动，例如选出：</p><ul><li>订单数超过 10000，且驾龄超过 5 年的老司机</li><li>每天驾驶时小于 3 小时，且收入超过 500 的高效司机</li><li>年龄大于 40，且平均速度大于 70 的“狂野”司机</li><li>……</li></ul><p>这些规则并不是固定的，经常在变化，但总归是各种司机特征的组合。</p><p>为了简化，我们选取 2 个特征，并用一个 <code>Driver</code> 结构体来表示：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Driver <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Orders         <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>	DrivingYears   <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了配合运营搞活动，我们需要根据运营给的规则来判断一个司机是否符合要求。</p><p>如果公司人多，可以安排一个 rd 专门伺候运营小姐姐，每次做活动都来手动修改代码，也不是不可以。并且其实挺简单，我们来写一个示例代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 从第三方获取司机特征，json 表示
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>getDriverRemote</span>() []<span style=color:#458;font-weight:700>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> []<span style=color:#0086b3>byte</span>(<span style=color:#d14>`{&#34;orders&#34;:100000,&#34;driving_years&#34;:18}`</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 判断是否为老司机
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>isOldDriver</span>(d <span style=color:#000;font-weight:700>*</span>Driver) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> d.Orders &gt; <span style=color:#099>10000</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> d.DrivingYears &gt; <span style=color:#099>5</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	bs <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>getDriverRemote</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> d Driver
</span></span><span style=display:flex><span>	json.<span style=color:#900;font-weight:700>Unmarshal</span>(bs, <span style=color:#000;font-weight:700>&amp;</span>d)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#900;font-weight:700>isOldDriver</span>(<span style=color:#000;font-weight:700>&amp;</span>d))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>直接来看 <code>main</code> 函数：<code>getDriverRemote</code> 模拟从第三方 RPC 获取一个司机的特征数据，用 json 表示。接着 <code>json.Unmarshal</code> 来反序列化 <code>Driver</code> 结构体。最后调用 <code>isOldDriver</code> 函数来判断此司机是否符合运营的规则。</p><p><code>isOldDriver</code> 根据 <code>Driver</code> 结构体的 2 个字段使用 if 语句来判断此司机是否为老司机。</p><p>确实还挺简单。</p><p>但是每次更新规则还得经过一次完整的上线流程，也挺麻烦的。有没有更简单的办法呢？使得我们可以直接解析运营小组姐给我们的一个用字符串表示的规则，并直接返回一个 bool 型的值，表示是否满足条件。</p><p>有的！</p><p>接下来就是本文的核心内容，如何使用 ast 来完成同样的功能。</p><h1 id=直观地理解如何用-ast-解析规则>直观地理解如何用 ast 解析规则</h1><p>使用 ast 包提供的一些函数，我们可以非常方便地将如下的规则字符串：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>orders &gt; <span style=color:#099>10000</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> driving_years &gt; <span style=color:#099>5</span>
</span></span></code></pre></div><p>解析成一棵这样的二叉树：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531232645.png><img class=mx-auto alt=规则二叉树 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531232645.png></a></p><p>其中，<code>ast.BinaryExpr</code> 代表一个二元表达式，它由 X 和 Y 以及符号 OP 三部分组成。最上面的一个 <code>BinaryExpr</code> 表示规则的左半部分和右半部分相与。</p><p>很明显，左半部分就是：<code>orders > 10000</code>，而右半部分则是：<code>driving_years > 5</code>。神奇的是，左半部分和右半部分恰好又都是一个二元表达式。</p><p>左半部分的 <code>orders > 10000</code> 其实也是最小的叶子节点，它可以算出来一个 bool 值。把它拆开来之后，又可以分成 X、Y、OP。X 是 <code>orders</code>，OP 是 &ldquo;>"，Y 则是 &ldquo;10000&rdquo;。其中 X 表示一个标识符，是 ast.Ident 类型，Y 表示一个基本类型的字面量，例如 int 型、字符串型……是 ast.BasicLit 类型。</p><p>右半部分的 <code>driving_years > 18</code> 也可以照此拆分。</p><p>然后，从 json 中取出这个司机的 <code>orders</code> 字段的值为 100000，它比 10000 大，所以左半部分算出来为 true。同理，右半部分算出来也为 true。最后，再算最外层的 &ldquo;&&"，结果仍然为 true。</p><p>至此，直接根据规则字符串，我们就可以算出来结果。</p><p>如果写成程序的话，就是一个 dfs 的遍历过程。如果不是叶子结点，那就是二元表达式结点，那就一定有 X、Y、OP 部分。递归地遍历 X，如果 X 是叶子结点，那就结束递归，并计算出 X 的值……</p><p>这里再展示一个用 ast 包打印出来的抽象语法树：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531231824.png><img class=mx-auto alt="Go 打印 ast" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531231824.png></a></p><p>上图中，1、2、3 表示最外层的二元表达式；4、5、6 则表示左边这个二元表达式。</p><p>结合这张图，再参考 ast 包的相关结构体 代码，就非常清晰了。例如 <code>ast.BinaryExpr</code> 的代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// A BinaryExpr node represents a binary expression.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>BinaryExpr <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	X     Expr        <span style=color:#998;font-style:italic>// left operand
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	OpPos token.Pos   <span style=color:#998;font-style:italic>// position of Op
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	Op    token.Token <span style=color:#998;font-style:italic>// operator
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	Y     Expr        <span style=color:#998;font-style:italic>// right operand
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>它有 X、Y、OP，甚至还解析出了 Op 的位置，用 OpPos 表示。</p><p>如果你还对实现感兴趣，那就继续看下面的原理分析部分，否则可以直接跳到结尾总结部分。</p><h1 id=原理分析>原理分析</h1><p>还是用上面那个例子，我们直接写一个表达式：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>orders &gt; <span style=color:#099>10000</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> driving_years &gt; <span style=color:#099>5</span>
</span></span></code></pre></div><p>接下来用 ast 来解析规则并判断真假。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	m <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>int64</span>{<span style=color:#d14>&#34;orders&#34;</span>: <span style=color:#099>100000</span>, <span style=color:#d14>&#34;driving_years&#34;</span>: <span style=color:#099>18</span>}
</span></span><span style=display:flex><span>	rule <span style=color:#000;font-weight:700>:=</span> <span style=color:#d14>`orders &gt; 10000 &amp;&amp; driving_years &gt; 5`</span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#900;font-weight:700>Eval</span>(m, rule))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了简单，我们直接用 map 来代替 json，道理是一样的，仅仅为了方便。</p><p><code>Eval</code> 函数判断 <code>rule</code> 的真假：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// Eval : 计算 expr 的值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Eval</span>(m <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>int64</span>, expr <span style=color:#458;font-weight:700>string</span>) (<span style=color:#458;font-weight:700>bool</span>, <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>	exprAst, err <span style=color:#000;font-weight:700>:=</span> parser.<span style=color:#900;font-weight:700>ParseExpr</span>(expr)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 打印 ast
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	fset <span style=color:#000;font-weight:700>:=</span> token.<span style=color:#900;font-weight:700>NewFileSet</span>()
</span></span><span style=display:flex><span>	ast.<span style=color:#900;font-weight:700>Print</span>(fset, exprAst)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>judge</span>(exprAst, m), <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>先将表达式解析成 <code>Expr</code>，接着调用 judge 函数计算结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// dfs
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>judge</span>(bop ast.Node, m <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>string</span>]<span style=color:#458;font-weight:700>int64</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 叶子结点
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#900;font-weight:700>isLeaf</span>(bop) {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 断言成二元表达式
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		expr <span style=color:#000;font-weight:700>:=</span> bop.(<span style=color:#000;font-weight:700>*</span>ast.BinaryExpr)
</span></span><span style=display:flex><span>		x <span style=color:#000;font-weight:700>:=</span> expr.X.(<span style=color:#000;font-weight:700>*</span>ast.Ident) <span style=color:#998;font-style:italic>// 左边
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		y <span style=color:#000;font-weight:700>:=</span> expr.Y.(<span style=color:#000;font-weight:700>*</span>ast.BasicLit) <span style=color:#998;font-style:italic>// 右边
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 如果是 &#34;&gt;&#34; 符号
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> expr.Op <span style=color:#000;font-weight:700>==</span> token.GTR {
</span></span><span style=display:flex><span>			left <span style=color:#000;font-weight:700>:=</span> m[x.Name]
</span></span><span style=display:flex><span>			right, _ <span style=color:#000;font-weight:700>:=</span> strconv.<span style=color:#900;font-weight:700>ParseInt</span>(y.Value, <span style=color:#099>10</span>, <span style=color:#099>64</span>)
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> left &gt; right
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 不是叶子节点那么一定是 binary expression（我们目前只处理二元表达式）
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	expr, ok <span style=color:#000;font-weight:700>:=</span> bop.(<span style=color:#000;font-weight:700>*</span>ast.BinaryExpr)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> !ok {
</span></span><span style=display:flex><span>		<span style=color:#0086b3>println</span>(<span style=color:#d14>&#34;this cannot be true&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 递归地计算左节点和右节点的值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>switch</span> expr.Op {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>case</span> token.LAND:
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>judge</span>(expr.X, m) <span style=color:#000;font-weight:700>&amp;&amp;</span> <span style=color:#900;font-weight:700>judge</span>(expr.Y, m)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>case</span> token.LOR:
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>judge</span>(expr.X, m) <span style=color:#000;font-weight:700>||</span> <span style=color:#900;font-weight:700>judge</span>(expr.Y, m)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#0086b3>println</span>(<span style=color:#d14>&#34;unsupported operator&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>judge</code> 使用 dfs 递归地计算表达式的值。</p><p>递归地终止条件是叶子节点：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 判断是否是叶子节点
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>isLeaf</span>(bop ast.Node) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	expr, ok <span style=color:#000;font-weight:700>:=</span> bop.(<span style=color:#000;font-weight:700>*</span>ast.BinaryExpr)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> !ok {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 二元表达式的最小单位，左节点是标识符，右节点是值
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	_, okL <span style=color:#000;font-weight:700>:=</span> expr.X.(<span style=color:#000;font-weight:700>*</span>ast.Ident)
</span></span><span style=display:flex><span>	_, okR <span style=color:#000;font-weight:700>:=</span> expr.Y.(<span style=color:#000;font-weight:700>*</span>ast.BasicLit)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> okL <span style=color:#000;font-weight:700>&amp;&amp;</span> okR {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=总结>总结</h1><p>今天这篇文章主要讲了如何用 ast 包和 parser 包解析一个二元表达式，并见识到了它的威力，利用它可以做成一个非常简单的规则引擎。</p><p>其实利用 ast 包还可以做更多有意思的事情。例如批量把 thrift 文件转化成 proto 文件、解析 sql 语句并做一些审计……</p><p>想要更深入的学习，可以看曹大这篇<a href=https://xargin.com/ast/>《golang 和 ast》</a>，据曹大自己说，他可以在 30 分钟内完成一个项目的一个 api 的编写，非常霸气！不服喷他……</p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/getting-to-know-the-power-of-ast/>https://qcrao.com/post/getting-to-know-the-power-of-ast/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>