<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度阅读之《100 Go Mistakes and How to Avoid Them》 | qcrao 的博客</title><meta property="og:title" content="深度阅读之《100 Go Mistakes and How to Avoid Them》 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2022-12-11T22:56:00+08:00"><meta property="article:modified_time" content="2022-12-11T22:56:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度阅读之《100 Go Mistakes and How to Avoid Them》"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/100-go-mistakes-reading-notes/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度阅读之《100 Go Mistakes and How to Avoid Them》</h1></header><date class="post-meta meta-date">2022年12月11日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>继<a href=https://qcrao.com/post/concurrency-in-go-reading-notes/>《Concurrency in Go》</a>之后，这是我精读的第 2 本 Go 主题的英文书了。全书 390+ 页，从开始读到全部读完，快 2 个月了，😓。</p><p>前不久曹大连接发了几个关于《100 mistakes》的视频，多猜他大都是看看标题，看看代码，就知道要说什么了，并且很快就跳过去，速度飞快。我开始设想的是除了读懂内容，还想练习一下英语阅读，慢就慢吧。不过，我过后也确实加快了速度，毕竟人家半小时的进度我要两周，稍微有点离谱。</p><p>简单谈一下这本书：全书“凑”了 100 个关于 Go 的错误。有些是非常经典且常见的错误，例如在 for 循环中保存迭代变量的指针、并发 append slice 等等，书中做了非常详细的讲述。另外有一些错误则见得不多，有凑数的嫌疑，例如很多错误是不知道 xxx、不懂 xxx……读来稍微有点别扭。还有一些瑕疵的地方是第 8 章关于 M 的描述是错误的……</p><p>关于书名，作者还找了几个为什么要从 mistakes 中学习的理由：我们印象最深的知识点一定是在犯错的场景下学到的。</p><blockquote><p>Tell me and I forget. Teach me and I remember. Involve me and I learn.</p></blockquote><p>我们最近正在组织这本书的翻译，估计明年 5 月左右能上市，不过还是建议大家读读英文版。</p><hr><p>以下是我在读书的过程中所做的一些笔记，记下我认为今后可能会遇到的坑。</p><ol><li>Go 很简单，但不容易掌握</li></ol><blockquote><p>Go is simple but not easy.</p></blockquote><p>简单意味着易懂，Go 语法基本上花 2 小时就能全部看完。但是要想掌握它、写好它却不容易。比如，goroutine 和 channel 该简单了吧，但是使用 channel 出错的 case 数不胜数。</p><p>之前有篇讲 Concurrency bugs 的论文<a href=https://songlh.github.io/paper/go-study.pdf>《Understanding Real-World Concurrency Bugs in Go》</a>说：尽管人们普遍认为通过 channel 来传递消息更少出错误，但是论文里研究的 bug 表明，正好相反，用 mutex 才更少出错。</p><ol start=2><li>The bigger the interface, the weaker the abstraction</li></ol><p>Rob Pike说：The bigger the interface, the weaker the abstraction。当一个接口的方法越多，它的抽象能力越弱。像接口 Reader/Writer 为何很强大，因为它们就只有一个方法。</p><p>他还说：Don’t design with interfaces, discover them. 意思就是只有在实现过程中发现需要 interface 时才需要定义。是自下而上的过程，而非相反。</p><ol start=3><li>net 包和 net/http 包并没有层级关系</li></ol><p>可以认为是两个不同的包，它们仅仅是文件位置有层级关系而已。</p><ol start=4><li>包名要反映这个包能提供什么能力，而不是它包含了哪些内容。</li></ol><p>函数名反映它做了什么，而不是怎么做。虽然命名一直是编程界的难题，但不断尝试好的命名也是必要的。日常的 util, common, base 这些包名其实并不好。任何对外暴露的内容：包、函数、方法、变量都应该给出说明。</p><ol start=5><li>nil slice 的几个特点</li></ol><p>不分配内存。对于一个函数的返回值而言，返回 nil slice 比 emtpy slice 要更好。</p><p>在 marshal 时，nil slice 是 null，而 empty slice 是 []。因此在使用相关库函数时，要特别注意这两者的区别。</p><p>nil slice 和 empty slice 不 equal。</p><p>以下代码中前 2 个是 nil slice，后两个不是。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FiHHlPlA6tg.png?alt=media&token=ef5a1cc6-e0c6-4205-a7ee-5ca21806c66f"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FiHHlPlA6tg.png?alt=media&token=ef5a1cc6-e0c6-4205-a7ee-5ca21806c66f"></a></p><ol start=6><li>copy 函数拷贝的元素数量是 min(len(dst), len(min))</li><li>初始化 map 时，指定一个长度</li></ol><p>它能给 runtime 以提示，这样后续可以减少重新分配元素的开销。并且要注意：这个长度并不是说 map 只能放这么多元素，这里面有一个公式会计算。</p><p>map 的 buckets 数只会增，不会降。所以当在流量冲击后，map 的 buckets 数扩容到了一个新高度，之后即使把元素都删除了也无济于事。内存占用还是在，因为基础的 buckets 占用的内存不会少。</p><p>关于这一点，之前专门写过一篇<a href=https://qcrao.com/post/memory-leak-of-go-map/>Go map 竟然也会发生内存泄漏？</a>去讲，私以为比书里讲得更详细。</p><ol start=8><li>不要边遍历 map 边写入 key</li></ol><p>在遍历 map 的过程中，新写入的 key 可能被遍历出来，也可能不被遍历出来，可能会与预期的行为不符，因此不要边遍历边写入。</p><p>下面这个例子输出的结果不确定：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	m <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>map</span>[<span style=color:#458;font-weight:700>int</span>]<span style=color:#458;font-weight:700>bool</span>{
</span></span><span style=display:flex><span>		<span style=color:#099>0</span>: <span style=color:#000;font-weight:700>true</span>,
</span></span><span style=display:flex><span>		<span style=color:#099>1</span>: <span style=color:#000;font-weight:700>false</span>,
</span></span><span style=display:flex><span>		<span style=color:#099>2</span>: <span style=color:#000;font-weight:700>true</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> k, v <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> m {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> v {
</span></span><span style=display:flex><span>			m[<span style=color:#099>10</span><span style=color:#000;font-weight:700>+</span>k] = <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(m)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=9><li>break 可以作用于 for, select, switch</li></ol><p>break 只能跳出一重循环，因此要注意，break 是否跳到了你预想的地方。可以用 break with label 来解决。毕竟标准库里也这样用了：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FafOw4v2lOB.png?alt=media&token=ae7c567f-f138-4e99-9245-707d31d97aef"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FafOw4v2lOB.png?alt=media&token=ae7c567f-f138-4e99-9245-707d31d97aef"></a></p><ol start=10><li>for 循环加指针，老司机也会掉的坑</li></ol><p>在 for range 循环里保存迭代变量的指针是一个非常容易犯的错误，Go 老手也会犯。原因是迭代变量至始至终都是同一个值，对它取地址得到的值也是相同的：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F-R_O2lfAwb.png?alt=media&token=5ae20a6a-1176-4639-b74d-4140d51dfe89"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F-R_O2lfAwb.png?alt=media&token=5ae20a6a-1176-4639-b74d-4140d51dfe89"></a></p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F2rotWfn5Kv.png?alt=media&token=f3bb0228-655f-41a0-8b2d-29a1439ef506"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F2rotWfn5Kv.png?alt=media&token=f3bb0228-655f-41a0-8b2d-29a1439ef506"></a></p><ol start=11><li>rune 代表一个“字”，等于 Unicode 中的 code point。</li></ol><p>因为在 UTF-8 中，一个字被编码成 1-4 个 bytes，因此 rune 被定义成了 int32。例如，汉字的编码是：0xE6, 0xB1, 0x89。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// len 返回的是 Byte 数量
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// 3
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#0086b3>len</span>(<span style=color:#d14>&#34;汉&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	s <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>string</span>([]<span style=color:#458;font-weight:700>byte</span>{<span style=color:#099>0xE6</span>, <span style=color:#099>0xB1</span>, <span style=color:#099>0x89</span>})
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 汉
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#0086b3>println</span>(s)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 查看 rune 数量
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// 1
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	fmt.<span style=color:#900;font-weight:700>Println</span>(utf8.<span style=color:#900;font-weight:700>RuneCountInString</span>(s))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=12><li>TrimLeft, TrimRight 的坑</li></ol><p>TrimLeft, TrimRight 会从 source string 里移除给定字符串里的字符（只要存在就移除），直到碰到一个不存在于给定字符串里的字符时结束；TrimPrefix, TrimSuffix 则要完全匹配，才会移除。Trim 等同于 TrimLeft+TrimRight。
13. 因为 Go 里面的 string 是不可变的，因此使用 += 来连接字符串时，其实是重新分配了一个新字符串。</p><p>使用 strings.Builder 时，可以用 Grow 方法来预分配内存，我自己之前一直忽略了预分配。因为它的底层是一个 slice，所以预分配 slice 是有必要的。</p><ol start=14><li>string 和 []byte 之间的转换会有内存分配发生</li></ol><p>所以除了一些 hack 方式的转换外，另外一个可替代的做法是在一些情况下直接用 bytes 包的方法，从而避免转换成 string：strings 包有的方法，byte 包也基本都有，比如 Split, Contains 等等。</p><p>转 string 的做法在标准库中是这么做的，见 strings.Clone 方法：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FAIfCEvLOHo.png?alt=media&token=5ddebc0b-5e8b-4d34-b16b-d3da4c4891eb"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FAIfCEvLOHo.png?alt=media&token=5ddebc0b-5e8b-4d34-b16b-d3da4c4891eb"></a></p><p>当我们需要取出一个 slice 里的小部分元素时，为了防止取字符串子串时内存泄漏，下面这种做法可能会在编译器中“误伤”，但这种转换是必要的，它发生了内存分配，因此和原字符串脱离了关系。另一种可选的方法是调用 strings.Clone 方法：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FU7W7GnQj5i.png?alt=media&token=42dd78fe-b8b8-4601-85c5-3a1f5ad16801"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FU7W7GnQj5i.png?alt=media&token=42dd78fe-b8b8-4601-85c5-3a1f5ad16801"></a></p><ol start=15><li>关于具名返回值。</li></ol><p>什么时候需要给返回值命名呢？没有一个必须遵循的原则。取名字有两个场景：增加可读性(例如返回经度、纬度两个字段，如果不命名，鬼知道哪个前哪个后)；利用它会自动初始化为零值，能让代码更短一些，当然，代码本身也得比较短。</p><p>另外，关于 return 时加不加名字。函数代码比较长时，还是带上比较好，增加可读性，不然看代码的人一直要记住返回值是什么。</p><p>在同一个函数里，统一返回值的风格，不要一会儿返回带名字的参数，一会儿又直接 return。</p><p>即使给返回值命名了，也不意味着一定要直接 return，还是可以带名字 return。</p><ol start=16><li>方法的语法糖</li></ol><blockquote><p>Having a nil receiver is allowed, and an interface converted from a nil pointer isn’t a nil interface.</p></blockquote><p>这句话非常绕，也很容易犯错。前半句，当 receiver 是 nil 的时候，依然可以调用方法，因为实际上方法是一个语法糖。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FC4egwiEEGs.png?alt=media&token=2c1886e0-c3e5-4842-86cb-89748f9185b6"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FC4egwiEEGs.png?alt=media&token=2c1886e0-c3e5-4842-86cb-89748f9185b6"></a></p><p>当返回参数是一个自定义的 interface 时，尤其是自定义的 Error interface 时，直接返回 nil，而不要返回一个 nil 的 pointer，因为它不是 nil，且这往往造成后续的判空逻辑出错，这同样是一个很常见的错误。</p><ol start=17><li>defer 一个 func 时，参数马上就会求值</li></ol><p>然后这个函数调用就会被压栈，等函数 return 时再来执行，参数值用的是之前已经算好了的，如果参数不是指针，那程序的行为可能就不是预期的那样了。</p><p>这种情况还可以用闭包解决，闭包内里的参数就是在真正执行的时候才去求值的。下面这个闭包同时还包含一个参数：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fgrt9J4p_pj.png?alt=media&token=485b2fe5-8450-42a8-a38e-60467aae8202"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fgrt9J4p_pj.png?alt=media&token=485b2fe5-8450-42a8-a38e-60467aae8202"></a></p><ol start=18><li>panic 和 error</li></ol><p>一般 error 都是作为返回值的最后一个。有些错误处理方案不处理 error，企图直接在 defer 里看有没有 panic，这其实是模拟的 Java/C++ 等语言里对异常的处理方法。Go 一般不这么做。</p><p>panic 发生时，程序执行流程会一直“出栈”直到当前进程退出或者被 recover 掉。</p><p>为什么 recover 一定要写在 defer 里才生效呢？因为只有在 defer 里的语句才能在发生 panic 后也能执行。还有个问题是为什么 recover 非得要包一层才能有效呢？这是 Go 明确规定的。可能有两方面原因：recover 有一个返回值，它表示 panic 的原因，所以得有地方把它“打印”出来；Go 在实现上需要用到栈的层级关系。具体的就需要深入研究下源码。<a href=https://stackoverflow.com/questions/29518109/why-does-defer-recover-not-catch-panics>stackoverflow</a></p><ol start=19><li>当我们要返回一个确定的、预期内的错误时，应该返回一个预先定义的 error value，也被称为 sentinel error；当返回非预期的错误时，返回特定的 error type。前者用 errors.Is 判断，后者用 errors.As 判断。</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FmpMyFotspN.png?alt=media&token=83b65f8f-d2d6-459e-8701-8fba653e1085"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FmpMyFotspN.png?alt=media&token=83b65f8f-d2d6-459e-8701-8fba653e1085"></a></p><ol start=20><li>几种不同错误处理方式。用 %w 是 wrap，用 %v 是转换。前者可以看到 source error，可以用 As/Is 比较，后者看不到。</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FHBtN2Q3sh-.png?alt=media&token=0178dd43-c704-4e0e-9573-e5d22e5303ce"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FHBtN2Q3sh-.png?alt=media&token=0178dd43-c704-4e0e-9573-e5d22e5303ce"></a></p><ol start=21><li>关于 context 取消</li></ol><blockquote><p>A Context carries a deadline, a cancellation signal, and other values across API boundaries.</p></blockquote><p>context 被取消时，可以通过 Done() 方法返回的 channel 感知到。当 cancel 方法被调用、deadline 过期时，context 被取消。Done() 返回的 channel 被关闭。通过 Err() 方法可以感知到 context 为什么会被取消。</p><p>另外，context 是并发安全的。</p><p>channel 有一个魔法是：关闭 channel，可以让所有的 receiver 感知到。而向 channel 发送数据，只能有一个 receiver 能收到。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F5AM01vyWbq.png?alt=media&token=183c526d-9512-4d6f-8940-e2bec72c5276"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F5AM01vyWbq.png?alt=media&token=183c526d-9512-4d6f-8940-e2bec72c5276"></a></p><ol start=22><li>context 的 key 类型如何设置</li></ol><p>当设置 key/value 时，key 和 value 可以是任意类型；对于 key 而言，通常不是直接用字符串，而是用一个非导出的类型，这样不会发生冲突。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F_g5X7Y_VzB.png?alt=media&token=73d98c15-ff81-4e24-bfbe-f2e2c5ad1549"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F_g5X7Y_VzB.png?alt=media&token=73d98c15-ff81-4e24-bfbe-f2e2c5ad1549"></a></p><p>如何通过自定义的方式来继承一个 context 里的 value，而不继承它的信号。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> detach <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	ctx context.Context
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d detach) <span style=color:#900;font-weight:700>Deadline</span>() (time.Time, <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> time.Time{}, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d detach) <span style=color:#900;font-weight:700>Done</span>() <span style=color:#000;font-weight:700>&lt;-</span><span style=color:#000;font-weight:700>chan</span> <span style=color:#000;font-weight:700>struct</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d detach) <span style=color:#900;font-weight:700>Err</span>() <span style=color:#458;font-weight:700>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d detach) <span style=color:#900;font-weight:700>Value</span>(key any) any {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> d.ctx.<span style=color:#900;font-weight:700>Value</span>(key)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=23><li>闭包是一个使用函数体外变量的匿名函数。它和 goroutine, for 循环结合使用时，经常会出现意料之外的问题，老司机也经常在这里翻车。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#d14>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>listing1</span>() {
</span></span><span style=display:flex><span>	s <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, i <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Print</span>(i)
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>listing2</span>() {
</span></span><span style=display:flex><span>	s <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, i <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s {
</span></span><span style=display:flex><span>		val <span style=color:#000;font-weight:700>:=</span> i
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Print</span>(val)
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>listing3</span>() {
</span></span><span style=display:flex><span>	s <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, i <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>(val <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Print</span>(val)
</span></span><span style=display:flex><span>		}(i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>listing1 里因为是闭包，所以 Print 是在打印的时候才会真正求 i 的值，而 goroutine 什么时候执行是不确定的。因此打印时，可能是 2，也可能是 3，且 goroutine 打印的值还可能重复。例如打印出 233 时图解如下：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FWGgii0NjRq.png?alt=media&token=c45df2de-6709-4d38-b769-3cae559378cd"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FWGgii0NjRq.png?alt=media&token=c45df2de-6709-4d38-b769-3cae559378cd"></a></p><p>listing2 用本地变量，可以解决。</p><p>listing3 不用闭包，同样能解决问题。</p><ol start=24><li><p>用 map[K]struct{} 这种形式来表示 set 不光是节省内存，还能明确表达出这是一个 set 的含义；如果把 struct{} 换成 bool 意义就没这么明确了。</p></li><li><p>context 相关的并发问题</p></li></ol><p>书里给了一个etcd里的例子，用 context 里的 k-v 做 key，然后遇到了并发(一个 goroutine 读所有的 value，另一个 goroutine 会更新某个可变的 value，例如 key 是一个指针，指向 struct)的问题，所以就自定义了一个 blankCtx 来拦截 String() 方法，消除并发问题。</p><p>这种问题应该还挺多的。context 里的 value 如果有可变类型，那么就会很容易导致 data race 的问题。</p><p>The fix <a href=https://github.com/etcd-io/etcd/pull/7816>https://github.com/etcd-io/etcd/pull/7816</a> was to not rely on fmt.Sprintf to format the map’s key to prevent traversing and reading the chain of wrapped values in the context. Instead, the solution was to implement a custom streamKeyFromCtx function to extract the key from a specific context value that wasn’t mutable.</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FW8pWfYGws7.png?alt=media&token=5f621d38-fcd5-4456-9152-e0697a2bc774"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FW8pWfYGws7.png?alt=media&token=5f621d38-fcd5-4456-9152-e0697a2bc774"></a></p><ol start=26><li>为什么 slice 不能并发 append？</li></ol><p>其实是看有没有同时 touch 同一个索引，也就是同一块内存。如果有的话就会有 data race 的问题。对于 map 而言，即使不是 touch 同一个 key 也会导致 data race。因为即使是不同的 key 也可能会被分到同一个 bucket。</p><p>当不同的 goroutine 并发写不同的索引时，不会发生 data-race。</p><p>我问chatGPT关于data race有什么坏处，得到的回答：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FP-pqoICiuE.png?alt=media&token=e04d40da-c45d-49e2-a8fc-ba264f95e811"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FP-pqoICiuE.png?alt=media&token=e04d40da-c45d-49e2-a8fc-ba264f95e811"></a></p><ol start=27><li>sync.WaitGroup 的正确用法是：在父 goroutine 中调用 Add 方法，在子 goroutine 中调用 Done 方法。</li></ol><p>sync.Cond 不太常用，它可以重复地给多个 goroutine 发送信号。与之相对的是， 关 channel 只能发送信号只能用一次。</p><blockquote><p>A condition variable is a container of threads (here, goroutines) waiting for a certain condition.</p></blockquote><ol start=28><li>errgroup 是 golang 的一个库，它提供了一种简单的方式来处理多个并发任务的错误。它的主要作用是用来管理多个 goroutine，在所有的 goroutine 都完成后再进行错误处理。有两个方法：</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FxIItxV7qC9.png?alt=media&token=58d80fb9-135e-4f4c-a4fb-082b4e9f39a5"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FxIItxV7qC9.png?alt=media&token=58d80fb9-135e-4f4c-a4fb-082b4e9f39a5"></a></p><ol start=29><li><p>time.After 会创建一个 channel，只会在过期的时候才会释放资源。</p></li><li><p>sql.Open 在有些 driver 下并不会连接到数据库，所以对于强依赖数据库的服务，需要先调用一下 Ping 或 PingContext 方法来保证数据库能连通，然后再启动服务。</p></li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F2GGTO_BPfB.png?alt=media&token=497755ec-800f-43b0-9afe-c7b635c6dc9f"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F2GGTO_BPfB.png?alt=media&token=497755ec-800f-43b0-9afe-c7b635c6dc9f"></a></p><p>这个我之前看项目的代码时，对这个还有一些疑问，认为没有必要。看书还是能涨知识的。</p><p>sql.Open 返回 *sql.DB struct，它的底层是一个连接池，我们需要设置连接池的下面这些属性，否则它们会用默认值(通常不太 work)。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fr4WxpK8uQm.png?alt=media&token=3cd831db-03c9-4db0-a34d-ad026a1ec9ec"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fr4WxpK8uQm.png?alt=media&token=3cd831db-03c9-4db0-a34d-ad026a1ec9ec"></a></p><p>最大连接数，不能太大，否则会把数据库打垮。</p><p>最大空闲连接数，需要增加，否则，流量一来，连接数不够，进而创建了一堆连接，因为 idle conn 数太少，最后又都释放掉。</p><p>最大空闲时间，默认是无限长，一旦碰到突发流量，连接一直保持在内存里，内存会爆掉。所以这个需要减少。</p><p>连接最大生存时间，如果需要负载均衡的话，连接的生存时间就不要太长，因为它会一直请求同一个负载。</p><ol start=31><li>对于 http 包里的 resp，只要 err 为空的话，就可以用 defer 来关闭，而不用根据 resp 是否为空来决定是否关闭 body。</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fb3gornp5qk.png?alt=media&token=6f5e7c8e-ba84-44b9-8c14-b09516d7a1f4"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fb3gornp5qk.png?alt=media&token=6f5e7c8e-ba84-44b9-8c14-b09516d7a1f4"></a></p><p>原因这里有解释：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FF1djpSvAIq.png?alt=media&token=0598cf7c-c1be-4c43-9891-81f21e4d724b"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FF1djpSvAIq.png?alt=media&token=0598cf7c-c1be-4c43-9891-81f21e4d724b"></a></p><p>只要是实现了 io.Closer 接口的资源，都应该在某个时间点调用 Close 方法，防止资源泄漏。</p><p>rows 没关闭的话，该连接不会被再次放到连接池里。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FdGexH4zMg-.png?alt=media&token=4affb40a-b76b-4e95-a6cb-e5fa8aa9bad7"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FdGexH4zMg-.png?alt=media&token=4affb40a-b76b-4e95-a6cb-e5fa8aa9bad7"></a></p><p>一个新手常犯的错误是使用默认的 http client，并且不设置任何超时的参数。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FI74-WrTKBh.png?alt=media&token=b36d02b5-2eca-413f-8783-eed6f66c2fd9"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FI74-WrTKBh.png?alt=media&token=b36d02b5-2eca-413f-8783-eed6f66c2fd9"></a></p><p>正确地如下：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F6-B5azgxf2.png?alt=media&token=3f7ebe3f-0f6e-444e-ac3c-9a20f9d8897a"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F6-B5azgxf2.png?alt=media&token=3f7ebe3f-0f6e-444e-ac3c-9a20f9d8897a"></a></p><p>另外，http client 底层也是有连接池的，所以相关的参数也得设置一下，默认的有问题，例如 http.Transport.MaxIdleConnsPerHost 的默认值是 2，就太小了。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fr4WxpK8uQm.png?alt=media&token=3cd831db-03c9-4db0-a34d-ad026a1ec9ec"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fr4WxpK8uQm.png?alt=media&token=3cd831db-03c9-4db0-a34d-ad026a1ec9ec"></a></p><p>http server 端的几个 timeout 参数设置：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FptyRi3xkGa.png?alt=media&token=d10ccc93-ab8f-4764-9675-f9a650f67020"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FptyRi3xkGa.png?alt=media&token=d10ccc93-ab8f-4764-9675-f9a650f67020"></a></p><p>另外，server 端的连接也可以设置 idle timeout，否则就只有等着 client 来关闭了。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F6sIaMLttnE.png?alt=media&token=5c633c7b-527c-4a38-b2f0-9c3e9baf5f3d"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F6sIaMLttnE.png?alt=media&token=5c633c7b-527c-4a38-b2f0-9c3e9baf5f3d"></a></p><ol start=32><li>发生 false sharing 的原因是，cache line 而非某个变量是 CPU 更新的粒度。</li></ol><blockquote><p>False sharing occurs when a cache line is shared across two cores when at least one goroutine is a writer.</p></blockquote><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fyu73NTBnk9.png?alt=media&token=f1e6b486-be34-4f4a-8a85-a54648090401"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2Fyu73NTBnk9.png?alt=media&token=f1e6b486-be34-4f4a-8a85-a54648090401"></a></p><ol start=33><li>Reader 的 Read 方法的 API 设计成目前这样的好处是：[]byte 不会直接就在堆上分配，而是由调用者决定，它有可能会分配在栈区，从而提升性能。</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FEJhipv9raS.png?alt=media&token=96cf2939-bfe2-4f00-b255-b25966ec28a4"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FEJhipv9raS.png?alt=media&token=96cf2939-bfe2-4f00-b255-b25966ec28a4"></a></p><ol start=34><li>查看函数是否被 inline</li></ol><p>inline 的好处是除了节省函数调用的开销外，还可能让之前逃逸到堆上的变量重新回到 stack。</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F8SL4GmRd9p.png?alt=media&token=ce548157-419f-4862-a853-60a9c1275b52"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F8SL4GmRd9p.png?alt=media&token=ce548157-419f-4862-a853-60a9c1275b52"></a></p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FBxrjssX1to.png?alt=media&token=978a2b42-c696-44ad-ab1c-5e28b642a56c"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FBxrjssX1to.png?alt=media&token=978a2b42-c696-44ad-ab1c-5e28b642a56c"></a></p><ol start=35><li>pprof 可以在查看 heap profile 之前强制 GC，可以直接在命令参数里开启</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FoxuECijB0b.png?alt=media&token=b60b4373-6200-4c8c-ae26-d58a0df5eacf"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2FoxuECijB0b.png?alt=media&token=b60b4373-6200-4c8c-ae26-d58a0df5eacf"></a></p><p>pprof 的 block profile 默认不会开启，需要在代码里手动执行 runtime.SetBlockProfileRate() 设置多少次阻塞上报一次，才会开启，开启之后会在后台一直上报 goroutine 阻塞的事件。阻塞可能发生于：</p><ul><li><p>Sending or receiving on an unbuffered channel</p></li><li><p>Sending to a full channel</p></li><li><p>Receiving from an empty channel</p></li><li><p>Mutex contention</p></li><li><p>Network or filesystem waits</p></li></ul><p>pprof 的 mutex profile 也是默认不开启，开启办法是调用 runtime.SetMutexProfileFraction()。</p><p>如果怀疑有 goroutine 被阻塞了很久，可以用 debug=2 参数 dump 所有的 goroutine，一眼看出是否真被阻塞住了：</p><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F9QXrrWTAkk.png?alt=media&token=ec52400d-eb30-478d-88ca-1287108995fd"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F9QXrrWTAkk.png?alt=media&token=ec52400d-eb30-478d-88ca-1287108995fd"></a></p><ol start=36><li>垫内存对 GC 阈值的影响不是线性的，但是直接改 GOGC 是。</li></ol><p><a data-fancybox=gallery href="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F1fkZ1kX9tj.png?alt=media&token=b16164e4-cac8-4b2e-95da-91d4d97f5b54"><img class=mx-auto alt src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fqcrao%2F1fkZ1kX9tj.png?alt=media&token=b16164e4-cac8-4b2e-95da-91d4d97f5b54"></a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/>https://qcrao.com/post/100-go-mistakes-reading-notes/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>