<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>图解 Go 语言内存分配 | qcrao 的博客</title><meta property="og:title" content="图解 Go 语言内存分配 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-03-13T09:41:00+08:00"><meta property="article:modified_time" content="2019-03-13T09:41:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="图解 Go 语言内存分配"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/graphic-go-memory-allocation/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>图解 Go 语言内存分配</h1></header><date class="post-meta meta-date">2019年3月13日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的<code>TCMalloc算法</code>，全称<code>Thread-Caching Malloc</code>。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h1 id=基础概念>基础概念</h1><p>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p><p>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54165891-9e6cde80-449d-11e9-8947-14e6f75f4089.png><img class=mx-auto alt=堆区总览 src=https://user-images.githubusercontent.com/7698088/54165891-9e6cde80-449d-11e9-8947-14e6f75f4089.png></a></p><p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成<code>8KB</code>大小的页，一些页组合起来称为<code>mspan</code>。</p><p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息。<code>bitmap</code>中一个<code>byte</code>大小的内存对应<code>arena</code>区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是<code>512GB/(4*8B)=16GB</code>。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54197565-3a7b0200-44ff-11e9-92e2-34185ee3e0bc.png><img class=mx-auto alt="bitmap arena" src=https://user-images.githubusercontent.com/7698088/54197565-3a7b0200-44ff-11e9-92e2-34185ee3e0bc.png></a></p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54197295-85484a00-44fe-11e9-9c77-9836120b8454.png><img class=mx-auto alt="bitmap arena" src=https://user-images.githubusercontent.com/7698088/54197295-85484a00-44fe-11e9-9c77-9836120b8454.png></a></p><p>从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。</p><p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。除以8KB是计算<code>arena</code>区域的页数，而最后乘以8是计算<code>spans</code>区域所有指针的大小。创建<code>mspan</code>的时候，按页填充对应的<code>spans</code>区域，在回收<code>object</code>时，根据地址很容易就能找到它所属的<code>mspan</code>。</p><h1 id=内存管理单元>内存管理单元</h1><p><code>mspan</code>：Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p><p>每个<code>mspan</code>按照它自身的属性<code>Size Class</code>的大小分割成若干个<code>object</code>，每个<code>object</code>可存储一个对象。并且会使用一个位图来标记其尚未使用的<code>object</code>。属性<code>Size Class</code>决定<code>object</code>大小，而<code>mspan</code>只会分配给和<code>object</code>尺寸大小接近的对象，当然，对象的大小要小于<code>object</code>大小。还有一个概念：<code>Span Class</code>，它和<code>Size Class</code>的含义差不多，</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>Size_Class <span style=color:#000;font-weight:700>=</span> Span_Class <span style=color:#000;font-weight:700>/</span> <span style=color:#099>2</span>
</span></span></code></pre></div><p>这是因为其实每个 <code>Size Class</code>有两个<code>mspan</code>，也就是有两个<code>Span Class</code>。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。</p><p>如下图，<code>mspan</code>由一组连续的页组成，按照一定大小划分成<code>object</code>。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png><img class=mx-auto alt="page mspan" src=https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png></a></p><p>Go1.9.2里<code>mspan</code>的<code>Size Class</code>共有67种，每种<code>mspan</code>分割的object大小是8*2n的倍数，这个是写死在代码里的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// path: /usr/local/go/src/runtime/sizeclasses.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> _NumSizeClasses = <span style=color:#099>67</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> class_to_size = [_NumSizeClasses]<span style=color:#458;font-weight:700>uint16</span>{<span style=color:#099>0</span>, <span style=color:#099>8</span>, <span style=color:#099>16</span>, <span style=color:#099>32</span>, <span style=color:#099>48</span>, <span style=color:#099>64</span>, <span style=color:#099>80</span>, <span style=color:#099>96</span>, <span style=color:#099>112</span>, <span style=color:#099>128</span>, <span style=color:#099>144</span>, <span style=color:#099>160</span>, <span style=color:#099>176</span>, <span style=color:#099>192</span>, <span style=color:#099>208</span>, <span style=color:#099>224</span>, <span style=color:#099>240</span>, <span style=color:#099>256</span>, <span style=color:#099>288</span>, <span style=color:#099>320</span>, <span style=color:#099>352</span>, <span style=color:#099>384</span>, <span style=color:#099>416</span>, <span style=color:#099>448</span>, <span style=color:#099>480</span>, <span style=color:#099>512</span>, <span style=color:#099>576</span>, <span style=color:#099>640</span>, <span style=color:#099>704</span>, <span style=color:#099>768</span>, <span style=color:#099>896</span>, <span style=color:#099>1024</span>, <span style=color:#099>1152</span>, <span style=color:#099>1280</span>, <span style=color:#099>1408</span>, <span style=color:#099>1536</span>,<span style=color:#099>1792</span>, <span style=color:#099>2048</span>, <span style=color:#099>2304</span>, <span style=color:#099>2688</span>, <span style=color:#099>3072</span>, <span style=color:#099>3200</span>, <span style=color:#099>3456</span>, <span style=color:#099>4096</span>, <span style=color:#099>4864</span>, <span style=color:#099>5376</span>, <span style=color:#099>6144</span>, <span style=color:#099>6528</span>, <span style=color:#099>6784</span>, <span style=color:#099>6912</span>, <span style=color:#099>8192</span>, <span style=color:#099>9472</span>, <span style=color:#099>9728</span>, <span style=color:#099>10240</span>, <span style=color:#099>10880</span>, <span style=color:#099>12288</span>, <span style=color:#099>13568</span>, <span style=color:#099>14336</span>, <span style=color:#099>16384</span>, <span style=color:#099>18432</span>, <span style=color:#099>19072</span>, <span style=color:#099>20480</span>, <span style=color:#099>21760</span>, <span style=color:#099>24576</span>, <span style=color:#099>27264</span>, <span style=color:#099>28672</span>, <span style=color:#099>32768</span>}
</span></span></code></pre></div><p>根据<code>mspan</code>的<code>Size Class</code>可以得到它划分的<code>object</code>大小。 比如<code>Size Class</code>等于3，<code>object</code>大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个<code>object</code>中。</p><p>数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型<code>Size Class</code>为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过<code>mspan</code>来分配。</p><p>对于mspan来说，它的<code>Size Class</code>会决定它所能分到的页数，这也是写死在代码里的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// path: /usr/local/go/src/runtime/sizeclasses.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> _NumSizeClasses = <span style=color:#099>67</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> class_to_allocnpages = [_NumSizeClasses]<span style=color:#458;font-weight:700>uint8</span>{<span style=color:#099>0</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>1</span>, <span style=color:#099>3</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>, <span style=color:#099>1</span>, <span style=color:#099>3</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>, <span style=color:#099>4</span>, <span style=color:#099>5</span>, <span style=color:#099>6</span>, <span style=color:#099>1</span>, <span style=color:#099>7</span>, <span style=color:#099>6</span>, <span style=color:#099>5</span>, <span style=color:#099>4</span>, <span style=color:#099>3</span>, <span style=color:#099>5</span>, <span style=color:#099>7</span>, <span style=color:#099>2</span>, <span style=color:#099>9</span>, <span style=color:#099>7</span>, <span style=color:#099>5</span>, <span style=color:#099>8</span>, <span style=color:#099>3</span>, <span style=color:#099>10</span>, <span style=color:#099>7</span>, <span style=color:#099>4</span>}
</span></span></code></pre></div><p>比如当我们要申请一个<code>object</code>大小为<code>32B</code>的<code>mspan</code>的时候，在class_to_size里对应的索引是3，而索引3在<code>class_to_allocnpages</code>数组里对应的页数就是1。</p><p><code>mspan</code>结构体定义：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// path: /usr/local/go/src/runtime/mheap.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> mspan <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//链表前向指针，用于将span链接起来
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	next <span style=color:#000;font-weight:700>*</span>mspan	
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>//链表前向指针，用于将span链接起来
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	prev <span style=color:#000;font-weight:700>*</span>mspan	
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 起始地址，也即所管理页的地址
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	startAddr <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 管理的页数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	npages <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 块个数，表示有多少个块可供分配
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	nelems <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//分配位图，每一位代表一个块是否已分配
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	allocBits <span style=color:#000;font-weight:700>*</span>gcBits 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 已分配块的个数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	allocCount <span style=color:#458;font-weight:700>uint16</span> 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// class表中的class ID，和Size Classs相关
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	spanclass spanClass  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// class表中的对象大小，也即块大小
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	elemsize <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们将<code>mspan</code>放到更大的视角来看：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png><img class=mx-auto alt=mspan更大视角 src=https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png></a></p><p>上图可以看到有两个<code>S</code>指向了同一个<code>mspan</code>，因为这两个<code>S</code>指向的<code>P</code>是同属一个<code>mspan</code>的。所以，通过<code>arena</code>上的地址可以快速找到指向它的<code>S</code>，通过<code>S</code>就能找到<code>mspan</code>，回忆一下前面我们说的<code>mspan</code>区域的每个指针对应一页。</p><p>假设最左边第一个<code>mspan</code>的<code>Size Class</code>等于10，根据前面的<code>class_to_size</code>数组，得出这个<code>msapn</code>分割的<code>object</code>大小是144B，算出可分配的对象个数是<code>8KB/144B=56.89</code>个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有<code>Size Class</code>的<code>mspan</code>浪费的内存的大小；再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由1个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么<code>spanClass</code>等于20。</p><p><code>startAddr</code>直接指向<code>arena</code>区域的某个位置，表示这个<code>mspan</code>的起始地址，<code>allocBits</code>指向一个位图，每位代表一个块是否被分配了对象；<code>allocCount</code>则表示总共已分配的对象个数。</p><p>这样，左起第一个<code>mspan</code>的各个字段参数就如下图所示：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png><img class=mx-auto alt=左起第一个mspan具体值 src=https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png></a></p><h1 id=内存管理组件>内存管理组件</h1><p>内存分配由内存分配器完成。分配器由3种组件构成：<code>mcache</code>, <code>mcentral</code>, <code>mheap</code>。</p><h2 id=mcache>mcache</h2><p><code>mcache</code>：每个工作线程都会绑定一个mcache，本地缓存可用的<code>mspan</code>资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。</p><p><code>mcache</code>的结构体定义：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>//path: /usr/local/go/src/runtime/mcache.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> mcache <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    alloc [numSpanClasses]<span style=color:#000;font-weight:700>*</span>mspan
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>numSpanClasses = _NumSizeClasses <span style=color:#000;font-weight:700>&lt;&lt;</span> <span style=color:#099>1</span>
</span></span></code></pre></div><p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>67*2=134</code>，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的<code>mspan</code>中分配的对象不包含指针，另一半则包含指针。</p><p>对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png><img class=mx-auto alt=mcache src=https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png></a></p><p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p><h2 id=mcentral>mcentral</h2><p><code>mcentral</code>：为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 每个<code>mcentral</code>对应一种<code>mspan</code>，而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。当工作线程的<code>mcache</code>中没有合适（也就是特定大小的）的<code>mspan</code>时就会从<code>mcentral</code>获取。</p><p><code>mcentral</code>被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>//path: /usr/local/go/src/runtime/mcentral.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> mcentral <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 互斥锁
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    lock mutex 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 规格
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    sizeclass <span style=color:#458;font-weight:700>int32</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 尚有空闲object的mspan链表
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    nonempty mSpanList 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    empty mSpanList 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 已累计分配的对象个数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    nmalloc <span style=color:#458;font-weight:700>uint64</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png><img class=mx-auto alt=mcentral src=https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png></a></p><p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的<code>mspan</code>列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p><p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p><ul><li><p>获取
加锁；从<code>nonempty</code>链表找到一个可用的<code>mspan</code>；并将其从<code>nonempty</code>链表删除；将取出的<code>mspan</code>加入到<code>empty</code>链表；将<code>mspan</code>返回给工作线程；解锁。</p></li><li><p>归还
加锁；将<code>mspan</code>从<code>empty</code>链表删除；将<code>mspan</code>加入到<code>nonempty</code>链表；解锁。</p></li></ul><h2 id=mheap>mheap</h2><p><code>mheap</code>：代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p><p>当<code>mcentral</code>没有空闲的<code>mspan</code>时，会向<code>mheap</code>申请。而<code>mheap</code>没有资源时，会向操作系统申请新内存。<code>mheap</code>主要用于大对象的内存分配，以及管理未切割的<code>mspan</code>，用于给<code>mcentral</code>切割成小对象。</p><p>同时我们也看到，<code>mheap</code>中含有所有规格的<code>mcentral</code>，所以，当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时，只需要在独立的<code>mcentral</code>中使用锁，并不会影响申请其他规格的<code>mspan</code>。</p><p><code>mheap</code>结构体定义：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>//path: /usr/local/go/src/runtime/mheap.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> mheap <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	lock mutex
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// spans: 指向mspans区域，用于映射mspan和page的关系
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	spans []<span style=color:#000;font-weight:700>*</span>mspan 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 指向bitmap首地址，bitmap是从高地址向低地址增长的
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	bitmap <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 指示arena区首地址
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	arena_start <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 指示arena区已使用地址位置
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	arena_used  <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 指示arena区末地址
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	arena_end   <span style=color:#458;font-weight:700>uintptr</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	central [<span style=color:#099>67</span><span style=color:#000;font-weight:700>*</span><span style=color:#099>2</span>]<span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>		mcentral mcentral
</span></span><span style=display:flex><span>		pad [sys.CacheLineSize <span style=color:#000;font-weight:700>-</span> unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(mcentral{})<span style=color:#000;font-weight:700>%</span>sys.CacheLineSize]<span style=color:#458;font-weight:700>byte</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png><img class=mx-auto alt=mheap src=https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png></a></p><p>上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。</p><h1 id=内存分配流程>内存分配流程</h1><p>上一篇文章<a href=https://www.cnblogs.com/qcrao-2018/p/10453260.html>《Golang之变量去哪儿》</a>中我们提到了，变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是"zero garbage"，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。</p><p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。</p><p>大体上的分配流程：</p><ul><li><blockquote><p>32KB 的对象，直接从mheap上分配；</p></blockquote></li><li>&lt;=16B 的对象使用mcache的tiny分配器分配；</li><li>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；<ul><li>如果mcache没有相应规格大小的mspan，则向mcentral申请</li><li>如果mcentral没有相应规格大小的mspan，则向mheap申请</li><li>如果mheap中也没有合适大小的mspan，则向操作系统申请</li></ul></li></ul><h1 id=总结>总结</h1><p>Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。源码很难追，后面可能会再来一篇关于内存分配的源码阅读相关的文章。简单总结一下本文吧。</p><p>文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也可以了。</p><ul><li>Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li><li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</li><li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。</li><li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li></ul><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png><img class=mx-auto alt=QR src=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png></a></p><h1 id=参考资料>参考资料</h1><p>【简单易懂，非常清晰】 <a href=https://yq.aliyun.com/articles/652551>https://yq.aliyun.com/articles/652551</a></p><p>【内存分配器的初始化过程，分配流程图很详细】 <a href=https://www.jianshu.com/p/47691d870756>https://www.jianshu.com/p/47691d870756</a></p><p>【全局的图】 <a href=https://swanspouse.github.io/2018/08/22/golang-memory-model/>https://swanspouse.github.io/2018/08/22/golang-memory-model/</a></p><p>【雨痕 Go1.5源码阅读】 <a href=https://github.com/qyuhen/book>https://github.com/qyuhen/book</a></p><p>【图不错】 <a href=https://www.jianshu.com/p/47691d870756>https://www.jianshu.com/p/47691d870756</a></p><p>【整体感】 <a href=https://juejin.im/post/59f2e19f5188253d6816d504>https://juejin.im/post/59f2e19f5188253d6816d504</a></p><p>【源码解读】 <a href=http://legendtkl.com/2017/04/02/golang-alloc/>http://legendtkl.com/2017/04/02/golang-alloc/</a></p><p>【重点推荐 深入到晶体管了 图很好】 <a href=https://www.linuxzen.com/go-memory-allocator-visual-guide.html>https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></p><p>【总体描述对象分配流程】 <a href=http://gocode.cc/project/4/article/103>http://gocode.cc/project/4/article/103</a></p><p>【实际Linux命令】 <a href=https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/>https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/</a></p><p>【整体流程图 对象分配函数调用链路】 <a href=http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html>http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html</a></p><p>【源码讲解 非常细致】 <a href=https://www.cnblogs.com/zkweb/p/7880099.html>https://www.cnblogs.com/zkweb/p/7880099.html</a></p><p>【源码阅读】 <a href=https://zhuanlan.zhihu.com/p/34930748>https://zhuanlan.zhihu.com/p/34930748</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/graphic-go-memory-allocation/>https://qcrao.com/post/graphic-go-memory-allocation/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>