<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>曹大谈内存重排 | qcrao 的博客</title><meta property="og:title" content="曹大谈内存重排 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-06-17T09:00:00+08:00"><meta property="article:modified_time" content="2019-06-17T09:00:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="曹大谈内存重排"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/cch-says-memory-reorder/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>曹大谈内存重排</h1></header><date class="post-meta meta-date">2019年6月17日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的参考资料都在文章最后一部分，欢迎自行探索。</p><p>在我读曹大给我的中英文参考资料时，我发现英文的我能读懂，读中文却很费劲。经过对比，我发现，英文文章是由一个例子引入，循序渐进，逐步深入。跟着作者的脚步探索，非常有意思。而中文的博客上来就直奔主题，对于第一次接触的人非常不友好。</p><p>两者就像演绎法和归纳法区别。国内的教材通常是演绎法，也就是上来先讲各种概念、原理，再推出另一些定理，比较枯燥；国外的教材更喜欢由例子引入，步步深入，引人入胜。这里，不去评判孰孰劣。多看看一些英文原版材料，总是有益的。据我所知，曹大经常从亚马逊上购买英文书籍，这个侧面也可以反映曹大的水平高啊。据说英文书一般都很贵，可见曹大也是很有钱的。</p><p>所以啊，技术文章写好不容易，我也自省一下。</p><h1 id=什么是内存重排>什么是内存重排</h1><p>分两种，硬件和软件层面的，包括 CPU 重排、编译器重排。</p><h2 id=cpu-重排>CPU 重排</h2><p>引用参考资料 <code>【内存一致模型】</code> 里的例子：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png><img class=mx-auto alt="2 thread" src=https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png></a></p><p>在两个线程里同时执行上面的代码，A 和 B 初始化值都是 0，那最终的输出是什么？</p><p>先说几种显而易见的结果：</p><table><thead><tr><th>执行顺序</th><th>输出结果</th></tr></thead><tbody><tr><td>1-2-3-4</td><td>01</td></tr><tr><td>3-4-1-2</td><td>01</td></tr><tr><td>1-3-2-4</td><td>11</td></tr><tr><td>1-3-4-2</td><td>11</td></tr></tbody></table><p>当然，还有一些对称的情形，和上面表格中列出的输出是一样的。例如，执行为顺序为 3-1-4-2 的输出为 11。</p><p>从 01 的排列组合来看，总共有4种：00、01、10、11。表格中还差两种：10、00。我们来重点分析下这两种结果究竟会不会出现。</p><p>首先是 <code>10</code>，假设 (2) 输出 1，(4) 输出 0。那么首先给 2，3 排个序：(3) -> (2)，因为先要将 B 赋值为 1，(2) 才能打印出 1；同理，(4) -> (1)。另外，因为先打印 1，所以 (2) 要在 (4) 前面，合起来：(3) -> (2) -> (4) -> (1)。(2) 竟然在 (1) 前面执行了，不可能的！</p><p>那我们再分析下 <code>00</code>，要想打印 00，打印语句必须在相应变量赋值前执行：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59549674-b455d800-8f93-11e9-83bb-074f2ab4c490.png><img class=mx-auto alt=00 src=https://user-images.githubusercontent.com/7698088/59549674-b455d800-8f93-11e9-83bb-074f2ab4c490.png></a></p><p>图中箭头表示先后顺序。这就尴尬了，形成了一个环。如果先从 (1) 开始，那顺序就是 (1) -> (2) -> (3) -> (4) -> (1)。(1) 要被执行了 2 次，怎么可能？所以 <code>00</code> 这种情形也是不可能出现的。</p><p>但是，上面说的两种情况在真实世界是有可能发生的。曹大的讲义里有验证的方法，感兴起的同学自己去尝试。总共测试了 100 百万次，测试结果如下：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59570902-5d561d00-90d1-11e9-842d-cf30babbc0a4.png><img class=mx-auto alt="test result" src=https://user-images.githubusercontent.com/7698088/59570902-5d561d00-90d1-11e9-842d-cf30babbc0a4.png></a></p><p>非常反直觉，但是在多线程的世界，各种诡异的问题，只有你想不到，没有计算机做不到的。</p><p>我们知道，用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。</p><p>其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 <code>内存重排</code>，英文为 <code>Memory Reordering</code>。</p><p>这一部分说的是 CPU 重排，其实还有编译器重排。</p><h2 id=编译器重排>编译器重排</h2><p>来看一个代码片段：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>X <span style=color:#000;font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>range</span>(<span style=color:#099>100</span>):
</span></span><span style=display:flex><span>    X <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>    <span style=color:#0086b3>print</span> X
</span></span></code></pre></div><p>这段代码执行的结果是打印 100 个 1。一个聪明的编译器会分析到循环里对 X 的赋值 <code>X = 1</code> 是多余的，每次都要给它赋上 1，完全没必要。因此会把代码优化一下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>X <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>range</span>(<span style=color:#099>100</span>):
</span></span><span style=display:flex><span>    <span style=color:#0086b3>print</span> X
</span></span></code></pre></div><p>优化后的运行结果完全和之前的一样，完美！</p><p>但是，如果这时有另外一个线程同时干了这么一件事：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>X <span style=color:#000;font-weight:700>=</span> <span style=color:#099>0</span>
</span></span></code></pre></div><p>由于这两个线程并行执行，优化前的代码运行的结果可能是这样的：<code>11101111...</code>。出现了 1 个 0，但在下次循环中，又会被重新赋值为 1，而且之后一直都是 1。</p><p>但是优化后的代码呢：<code>11100000...</code>。由于把 <code>X = 1</code> 这一条赋值语句给优化掉了，某个时刻 X 变成 <code>0</code> 之后，再也没机会变回原来的 <code>1</code> 了。</p><blockquote><p>在多核心场景下,没有办法轻易地判断两段程序是“等价”的。</p></blockquote><p>可见编译器的重排也是基于运行效率考虑的，但以多线程运行时，就会出各种问题。</p><h1 id=为什么要内存重排>为什么要内存重排</h1><p>引用曹大的一句话：</p><blockquote><p>软件或硬件系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的。</p></blockquote><p>软件指的是编译器，硬件是 CPU。不可告人的目的就是：</p><blockquote><p>减少程序指令数
最大化提高 CPU 利用率</p></blockquote><p>曹大又皮了！</p><h1 id=内存重排的底层原理>内存重排的底层原理</h1><p>CPU 重排的例子里提到的两种不可能出现的情况，并不是那么显而易见，甚至是难以理解。原因何在？</p><p>因为我们相信在多线程的程序里，虽然是并行执行，但是访问的是同一块内存，所以没有语句，准确说是指令，能“真正”同时执行的。对同一个内存地址的写，一定是有先有后，先写的结果一定会被后来的操作看到。</p><p>当我们写的代码以单线程运行的时候，语句会按我们的本来意图 <code>顺序</code> 地去执行。一旦单线程变成多线程，情况就变了。</p><p>想像一个场景，有两个线程在运行，操作系统会在它们之间进行调度。每个线程在运行的时候，都会顺序地执行它的代码。由于对同一个变量的读写，会访问内存的同一地址，所以同一时刻只能有一个线程在运行，即使 CPU 有多个核心：前一个指令操作的结果要让后一个指令看到。</p><p>这样带来的后果就是效率低下。两个线程没法做到并行，因为一个线程所做的修改会影响到另一个线程，那后者只能在前者的修改所造成的影响“可见”了之后，才能运行，变成了串行。</p><p>重新来思考前面的例子：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png><img class=mx-auto alt="2 thread" src=https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png></a></p><p>考虑一个问题，为什么 (2) 要等待 (1) 执行完之后才能执行呢？它们之间又没有什么联系，影响不到彼此，完全可以并行去做啊！</p><p>由于 (1) 是写语句，所以比 (2) 更耗时，从 <code>a single view of memory</code> 这个视角来看，(2) 应该等 (1) 的“效果”对其他所有线程可见了之后才可以执行。但是，在一个现代 CPU 里，这需要花费上百个 CPU 周期。</p><p>现代 CPU 为了“抚平” 内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59557419-223de600-900c-11e9-8c08-a1ba4b0bbbff.png><img class=mx-auto alt="cpu cache" src=https://user-images.githubusercontent.com/7698088/59557419-223de600-900c-11e9-8c08-a1ba4b0bbbff.png></a></p><p>为了让 (2) 不必等待 (1) 的执行“效果”可见之后才能执行，我们可以把 (1) 的效果保存到 <code>store buffer</code>：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59557443-e3f4f680-900c-11e9-975e-82d9b7da74c7.png><img class=mx-auto alt="store buffer" src=https://user-images.githubusercontent.com/7698088/59557443-e3f4f680-900c-11e9-975e-82d9b7da74c7.png></a></p><p>当 (1) 的“效果”写到了 <code>store buffer</code> 后，(2) 就可以开始执行了，不必等到 <code>A = 1</code> 到达 L3 cache。因为 <code>store buffer</code> 是在内核里完成的，所以速度非常快。在这之后的某个时刻，<code>A = 1</code> 会被逐级写到 L3 cache，从而被其他所有线程看到。<code>store buffer</code> 相当于把写的耗时隐藏了起来。</p><p><code>store buffer</code> 对单线程是完美的，例如：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59557508-e99f0c00-900d-11e9-81d5-5c7a22faecfc.png><img class=mx-auto alt="store buffer 1 thread" src=https://user-images.githubusercontent.com/7698088/59557508-e99f0c00-900d-11e9-81d5-5c7a22faecfc.png></a></p><p>将 (1) 存入 <code>store buffer</code> 后，(2) 开始执行。注意，由于是同一个线程，所以语句的执行顺序还是要保持的。</p><p>(2) 直接从 <code>store buffer</code> 里读出了 <code>A = 1</code>，不必从 L3 Cache 或者内存读取，简直完美！</p><p>有了 <code>store buffer</code> 的概念，我们再来研究前面的那个例子：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/59557535-bf9a1980-900e-11e9-9d19-f84a0f3196db.png><img class=mx-auto alt="store buffer 2 threads" src=https://user-images.githubusercontent.com/7698088/59557535-bf9a1980-900e-11e9-9d19-f84a0f3196db.png></a></p><p>先执行 (1) 和 (3)，将他们直接写入 <code>store buffer</code>，接着执行 (2) 和 (4)。“奇迹”要发生了：(2) 看了下 <code>store buffer</code>，并没有发现有 B 的值，于是从 Memory 读出了 0，(4) 同样从 Memory 读出了 0。最后，打印出了 <code>00</code>。</p><p>所有的现代 CPU 都支持 <code>store buffer</code>，这导致了很多对程序员来说是难以理解的现象。从某种角度来说，不等 <code>A = 1</code> 扩散到 Memory，就去执行 <code>print(B)</code> 语句，可以看成<code>读写指令重排</code>。有些 CPU 甚至优化得更多，几乎所有的操作都可以重排，简直是噩梦。</p><p>因此，对于多线程的程序，所有的 CPU 都会提供“锁”支持，称之为 <code>barrier</code>，或者 <code>fence</code>。它要求：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>A barrier instruction forces all memory operations before it to <span style=color:#0086b3>complete</span> before any memory operation after it can begin.
</span></span></code></pre></div><p>barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。</p><p>barrier 指令要耗费几百个 CPU 周期，而且容易出错。因此，我们可以用高级点的 <code>atomic compare-and-swap</code>，或者直接用更高级的锁，通常是标准库提供。</p><blockquote><p>正是 CPU 提供的 barrier 指令，我们才能实现应用层的各种同步原语，如 atomic，而 atomic 又是各种更上层的 lock 的基础。</p></blockquote><p>以上说的是 CPU 重排的原理。编译器重排主要是依据语言自己的“内存模型”，不深入了。</p><p>出现前面描述的诡异现象的根源在于程序存在 <code>data race</code>，也就是说多个线程会同时访问内存的同一个地方，并且至少有一个是写，而且导致了内存重排。所以，最重要的是当我们在写并发程序的时候，要使用一些“同步”的标准库，简单理解就是各种锁，来避免由于内存重排而带来的一些不可预知的结果。</p><h1 id=总结>总结</h1><p>内存重排是指程序在实际运行时对内存的访问顺序和代码编写时的顺序不一致，主要是为了提高运行效率。分别是硬件层面的 <code>CPU 重排</code> 和软件层面的 <code>编译器重排</code>。</p><p>单线程的程序一般不会有太大问题；多线程情况下，有时会出现诡异的现象，解决办法就是使用标准库里的锁。锁会带来性能问题，为了降低影响，锁应该尽量减小粒度，并且不要在互斥区（锁住的代码）放入耗时长的操作。</p><blockquote><p>lock contention 的本质问题是需要进入互斥区的 goroutine 需要等待独占 goroutine 退出后才能进入互斥区，并行 → 串行。</p></blockquote><p>本文讲的是曹大讲座的一部分，我没有深入研究其他内容，例如 MESI协议、cache contention 等，讲清这些又要牵扯到很多，我还是聚集到深度解密 Go 语言系列吧。有兴趣的话，去曹大博客，给我们提供了很多参考链接，可以自行探索。</p><h1 id=参考资料>参考资料</h1><p>【曹大 github】 <a href=https://github.com/cch123/golang-notes/blob/master/memory_barrier.md>https://github.com/cch123/golang-notes/blob/master/memory_barrier.md</a></p><p>【曹大讲义】 <a href=https://cch123.github.io/ooo/>https://cch123.github.io/ooo/</a></p><p>【内存一致模型】 <a href=https://homes.cs.washington.edu/~bornholt/post/memory-models.html>https://homes.cs.washington.edu/~bornholt/post/memory-models.html</a></p><p>【掘金咔叽咔叽，译】 <a href=https://juejin.im/post/5d0519e05188257a78764d5d#comment>https://juejin.im/post/5d0519e05188257a78764d5d#comment</a></p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png><img class=mx-auto alt=QR src=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png></a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/cch-says-memory-reorder/>https://qcrao.com/post/cch-says-memory-reorder/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>