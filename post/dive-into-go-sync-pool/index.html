<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 Go 语言之 sync.pool | qcrao 的博客</title><meta property="og:title" content="深度解密 Go 语言之 sync.pool - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-04-20T09:34:32+08:00"><meta property="article:modified_time" content="2020-04-20T09:34:32+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 Go 语言之 sync.pool"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-go-sync-pool/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 Go 语言之 sync.pool</h1></header><date class="post-meta meta-date">2020年4月20日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>最近在工作中碰到了 GC 的问题：项目中大量重复地创建许多对象，造成 GC 的工作量巨大，CPU 频繁掉底。准备使用 <code>sync.Pool</code> 来缓存对象，减轻 GC 的消耗。为了用起来更顺畅，我特地研究了一番，形成此文。本文从使用到源码解析，循序渐进，一一道来。</p><blockquote><p>本文基于 Go 1.14</p></blockquote><h1 id=是什么>是什么</h1><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 <code>sync.Cache</code> 是一个更合适的名字。</p><h1 id=有什么用>有什么用</h1><p>对于很多需要重复分配、回收内存的地方，<code>sync.Pool</code> 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 <code>sync.Pool</code> 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</p><h1 id=怎么用>怎么用</h1><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。</p></blockquote><blockquote><p>在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><h2 id=简单的例子>简单的例子</h2><p>首先来看一个简单的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> pool <span style=color:#000;font-weight:700>*</span>sync.Pool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Person <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	Name <span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>initPool</span>() {
</span></span><span style=display:flex><span>	pool = <span style=color:#000;font-weight:700>&amp;</span>sync.Pool {
</span></span><span style=display:flex><span>		New: <span style=color:#000;font-weight:700>func</span>()<span style=color:#000;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>			fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Creating a new Person&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>new</span>(Person)
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>initPool</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> pool.<span style=color:#900;font-weight:700>Get</span>().(<span style=color:#000;font-weight:700>*</span>Person)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;首次从 pool 里获取：&#34;</span>, p)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	p.Name = <span style=color:#d14>&#34;first&#34;</span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Printf</span>(<span style=color:#d14>&#34;设置 p.Name = %s\n&#34;</span>, p.Name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pool.<span style=color:#900;font-weight:700>Put</span>(p)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Pool 里已有一个对象：&amp;{first}，调用 Get: &#34;</span>, pool.<span style=color:#900;font-weight:700>Get</span>().(<span style=color:#000;font-weight:700>*</span>Person))
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Pool 没有对象了，调用 Get: &#34;</span>, pool.<span style=color:#900;font-weight:700>Get</span>().(<span style=color:#000;font-weight:700>*</span>Person))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>Creating a new Person
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>首次从</span> pool <span style=color:#a61717;background-color:#e3d2d2>里获取：</span> <span style=color:#000;font-weight:700>&amp;</span>{}
</span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>设置</span> p.Name = first
</span></span><span style=display:flex><span>Pool <span style=color:#a61717;background-color:#e3d2d2>里已有一个对象：</span><span style=color:#000;font-weight:700>&amp;</span>{first}<span style=color:#a61717;background-color:#e3d2d2>，</span>Get:  <span style=color:#000;font-weight:700>&amp;</span>{first}
</span></span><span style=display:flex><span>Creating a new Person
</span></span><span style=display:flex><span>Pool <span style=color:#a61717;background-color:#e3d2d2>没有对象了，</span>Get:  <span style=color:#000;font-weight:700>&amp;</span>{}
</span></span></code></pre></div><p>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，最好的做法是在 Put 前，将对象清空。</p><h2 id=fmt-包如何用>fmt 包如何用</h2><p>这部分主要看 <code>fmt.Printf</code> 如何使用：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Printf</span>(format <span style=color:#458;font-weight:700>string</span>, a <span style=color:#000;font-weight:700>...</span><span style=color:#000;font-weight:700>interface</span>{}) (n <span style=color:#458;font-weight:700>int</span>, err <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>Fprintf</span>(os.Stdout, format, a<span style=color:#000;font-weight:700>...</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>继续看 <code>Fprintf</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Fprintf</span>(w io.Writer, format <span style=color:#458;font-weight:700>string</span>, a <span style=color:#000;font-weight:700>...</span><span style=color:#000;font-weight:700>interface</span>{}) (n <span style=color:#458;font-weight:700>int</span>, err <span style=color:#458;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>newPrinter</span>()
</span></span><span style=display:flex><span>	p.<span style=color:#900;font-weight:700>doPrintf</span>(format, a)
</span></span><span style=display:flex><span>	n, err = w.<span style=color:#900;font-weight:700>Write</span>(p.buf)
</span></span><span style=display:flex><span>	p.<span style=color:#900;font-weight:700>free</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// newPrinter allocates a new pp struct or grabs a cached one.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>newPrinter</span>() <span style=color:#000;font-weight:700>*</span>pp {
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> ppFree.<span style=color:#900;font-weight:700>Get</span>().(<span style=color:#000;font-weight:700>*</span>pp)
</span></span><span style=display:flex><span>	p.panicking = <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	p.erroring = <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	p.wrapErrs = <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	p.fmt.<span style=color:#900;font-weight:700>init</span>(<span style=color:#000;font-weight:700>&amp;</span>p.buf)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> p
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> ppFree = sync.Pool{
</span></span><span style=display:flex><span>	New: <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>interface</span>{} { <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>new</span>(pp) },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// free saves used pp structs in ppFree; avoids an allocation per invocation.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>pp) <span style=color:#900;font-weight:700>free</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>cap</span>(p.buf) &gt; <span style=color:#099>64</span><span style=color:#000;font-weight:700>&lt;&lt;</span><span style=color:#099>10</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	p.buf = p.buf[:<span style=color:#099>0</span>]
</span></span><span style=display:flex><span>	p.arg = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	p.value = reflect.Value{}
</span></span><span style=display:flex><span>	p.wrappedErr = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	ppFree.<span style=color:#900;font-weight:700>Put</span>(p)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>归还到 Pool 前将对象的一些字段清零，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h2 id=pool_test>pool_test</h2><p>通过 test 文件学习源码是一个很好的途径，因为它代表了“官方”的用法。更重要的是，测试用例会故意测试一些“坑”，学习这些坑，也会让自己在使用的时候就能学会避免。</p><p><code>pool_test</code> <a href=https://github.com/golang/go/blob/release-branch.go1.14/src/sync/pool_test.go>文件</a>里共有 7 个测试，4 个 BechMark。</p><p><code>TestPool</code> 和 <code>TestPoolNew</code> 比较简单，主要是测试 Get/Put 的功能。我们来看下 <code>TestPoolNew</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestPoolNew</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// disable GC so we can control when it happens.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>defer</span> debug.<span style=color:#900;font-weight:700>SetGCPercent</span>(debug.<span style=color:#900;font-weight:700>SetGCPercent</span>(<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> Pool{
</span></span><span style=display:flex><span>		New: <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>			i<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> i
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> v <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>Get</span>(); v <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>1</span> {
</span></span><span style=display:flex><span>		t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;got %v; want 1&#34;</span>, v)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> v <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>Get</span>(); v <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>2</span> {
</span></span><span style=display:flex><span>		t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;got %v; want 2&#34;</span>, v)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Make sure that the goroutine doesn&#39;t migrate to another P
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// between Put and Get calls.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#900;font-weight:700>Runtime_procPin</span>()
</span></span><span style=display:flex><span>	p.<span style=color:#900;font-weight:700>Put</span>(<span style=color:#099>42</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> v <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>Get</span>(); v <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>42</span> {
</span></span><span style=display:flex><span>		t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;got %v; want 42&#34;</span>, v)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>Runtime_procUnpin</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> v <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>Get</span>(); v <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>3</span> {
</span></span><span style=display:flex><span>		t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;got %v; want 3&#34;</span>, v)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先设置了 <code>GC=-1</code>，作用就是停止 GC。那为啥要用 defer？函数都跑完了，还要 defer 干啥。注意到，<code>debug.SetGCPercent</code> 这个函数被调用了两次，而且这个函数返回的是上一次 GC 的值。因此，defer 在这里的用途是还原到调用此函数之前的 GC 设置，也就是恢复现场。</p><p>接着，调置了 Pool 的 New 函数：直接返回一个 int，变且每次调用 New，都会自增 1。然后，连续调用了两次 Get 函数，因为这个时候 Pool 里没有缓存的对象，因此每次都会调用 New 创建一个，所以第一次返回 1，第二次返回 2。</p><p>然后，调用 <code>Runtime_procPin()</code> 防止 goroutine 被强占，目的是保护接下来的一次 Put 和 Get 操作，使得它们操作的对象都是同一个 P 的“池子”。并且，这次调用 Get 的时候并没有调用 New，因为之前有一次 Put 的操作。</p><p>最后，再次调用 Get 操作，因为没有“存货”，因此还是会再次调用 New 创建一个对象。</p><p><code>TestPoolGC</code> 和 <code>TestPoolRelease</code> 则主要测试 GC 对 Pool 里对象的影响。这里用了一个函数，用于计数有多少对象会被 GC 回收：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>runtime.<span style=color:#900;font-weight:700>SetFinalizer</span>(v, <span style=color:#000;font-weight:700>func</span>(vv <span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>	atomic.<span style=color:#900;font-weight:700>AddUint32</span>(<span style=color:#000;font-weight:700>&amp;</span>fin, <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>当垃圾回收检测到 <code>v</code> 是一个不可达的对象时，并且 <code>v</code> 又有一个关联的 <code>Finalizer</code>，就会另起一个 goroutine 调用设置的 finalizer 函数，也就是上面代码里的参数 func。这样，就会让对象 v 重新可达，从而在这次 GC 过程中不被回收。之后，解绑对象 v 和它所关联的 <code>Finalizer</code>，当下次 GC 再次检测到对象 v 不可达时，才会被回收。</p><p><code>TestPoolStress</code> 从名字看，主要是想测一下“压力”，具体操作就是起了 10 个 goroutine 不断地向 Pool 里 Put 对象，然后又 Get 对象，看是否会出错。</p><p><code>TestPoolDequeue</code> 和 <code>TestPoolChain</code>，都调用了 <code>testPoolDequeue</code>，这是具体干活的。它需要传入一个 <code>PoolDequeue</code> 接口：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// poolDequeue testing.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> PoolDequeue <span style=color:#000;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>PushHead</span>(val <span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>PopHead</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>PopTail</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>PoolDequeue</code> 是一个双端队列，可以从头部入队元素，从头部和尾部出队元素。调用函数时，前者传入 <code>NewPoolDequeue(16)</code>，后者传入 <code>NewPoolChain()</code>，底层其实都是 <code>poolDequeue</code> 这个结构体。具体来看 <code>testPoolDequeue</code> 做了什么：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200410125923.png><img class=mx-auto alt=双端队列 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200410125923.png></a></p><p>总共起了 10 个 goroutine：1 个生产者，9 个消费者。生产者不断地从队列头 pushHead 元素到双端队列里去，并且每 push 10 次，就 popHead 一次；消费者则一直从队列尾取元素。不论是从队列头还是从队列尾取元素，都会在 map 里做标记，最后检验每个元素是不是只被取出过一次。</p><p>剩下的就是 Benchmark 测试了。第一个 <code>BenchmarkPool</code> 比较简单，就是不停地 Put/Get，测试性能。</p><p><code>BenchmarkPoolSTW</code> 函数会先关掉 GC，再向 pool 里 put 10 个对象，然后强制触发 GC，记录 GC 的停顿时间，并且做一个排序，计算 P50 和 P95 的 STW 时间。这个函数可以加入个人的代码库了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>BenchmarkPoolSTW</span>(b <span style=color:#000;font-weight:700>*</span>testing.B) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Take control of GC.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>defer</span> debug.<span style=color:#900;font-weight:700>SetGCPercent</span>(debug.<span style=color:#900;font-weight:700>SetGCPercent</span>(<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> mstats runtime.MemStats
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> pauses []<span style=color:#458;font-weight:700>uint64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> p Pool
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; b.N; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Put a large number of items into a pool.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>const</span> N = <span style=color:#099>100000</span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>var</span> item <span style=color:#000;font-weight:700>interface</span>{} = <span style=color:#099>42</span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; N; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>			p.<span style=color:#900;font-weight:700>Put</span>(item)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Do a GC.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		runtime.<span style=color:#900;font-weight:700>GC</span>()
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Record pause time.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		runtime.<span style=color:#900;font-weight:700>ReadMemStats</span>(<span style=color:#000;font-weight:700>&amp;</span>mstats)
</span></span><span style=display:flex><span>		pauses = <span style=color:#0086b3>append</span>(pauses, mstats.PauseNs[(mstats.NumGC<span style=color:#000;font-weight:700>+</span><span style=color:#099>255</span>)<span style=color:#000;font-weight:700>%</span><span style=color:#099>256</span>])
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Get pause time stats.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	sort.<span style=color:#900;font-weight:700>Slice</span>(pauses, <span style=color:#000;font-weight:700>func</span>(i, j <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> pauses[i] &lt; pauses[j] })
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> total <span style=color:#458;font-weight:700>uint64</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, ns <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> pauses {
</span></span><span style=display:flex><span>		total <span style=color:#000;font-weight:700>+=</span> ns
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// ns/op for this benchmark is average STW time.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	b.<span style=color:#900;font-weight:700>ReportMetric</span>(<span style=color:#0086b3>float64</span>(total)<span style=color:#000;font-weight:700>/</span><span style=color:#0086b3>float64</span>(b.N), <span style=color:#d14>&#34;ns/op&#34;</span>)
</span></span><span style=display:flex><span>	b.<span style=color:#900;font-weight:700>ReportMetric</span>(<span style=color:#0086b3>float64</span>(pauses[<span style=color:#0086b3>len</span>(pauses)<span style=color:#000;font-weight:700>*</span><span style=color:#099>95</span><span style=color:#000;font-weight:700>/</span><span style=color:#099>100</span>]), <span style=color:#d14>&#34;p95-ns/STW&#34;</span>)
</span></span><span style=display:flex><span>	b.<span style=color:#900;font-weight:700>ReportMetric</span>(<span style=color:#0086b3>float64</span>(pauses[<span style=color:#0086b3>len</span>(pauses)<span style=color:#000;font-weight:700>*</span><span style=color:#099>50</span><span style=color:#000;font-weight:700>/</span><span style=color:#099>100</span>]), <span style=color:#d14>&#34;p50-ns/STW&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我在 mac 上跑了一下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go <span style=color:#0086b3>test</span> -v -run<span style=color:#000;font-weight:700>=</span>none -bench<span style=color:#000;font-weight:700>=</span>BenchmarkPoolSTW
</span></span></code></pre></div><p>得到输出：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: sync
</span></span><span style=display:flex><span>BenchmarkPoolSTW-12    <span style=color:#099>361</span>    <span style=color:#099>3708</span> ns/op    <span style=color:#099>3583</span> p50-ns/STW    <span style=color:#099>5008</span> p95-ns/STW
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      sync    1.481s
</span></span></code></pre></div><p>最后一个 <code>BenchmarkPoolExpensiveNew</code> 测试当 New 的代价很高时，Pool 的表现。也可以加入个人的代码库。</p><h2 id=其他>其他</h2><p>标准库中 <code>encoding/json</code> 也用到了 sync.Pool 来提升性能。著名的 <code>gin</code> 框架，对 context 取用也到了 <code>sync.Pool</code>。</p><p>来看下 <code>gin</code> 如何使用 sync.Pool。设置 New 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>engine.pool.New = <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> engine.<span style=color:#900;font-weight:700>allocateContext</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (engine <span style=color:#000;font-weight:700>*</span>Engine) <span style=color:#900;font-weight:700>allocateContext</span>() <span style=color:#000;font-weight:700>*</span>Context {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>Context{engine: engine, KeysMutex: <span style=color:#000;font-weight:700>&amp;</span>sync.RWMutex{}}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// ServeHTTP conforms to the http.Handler interface.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (engine <span style=color:#000;font-weight:700>*</span>Engine) <span style=color:#900;font-weight:700>ServeHTTP</span>(w http.ResponseWriter, req <span style=color:#000;font-weight:700>*</span>http.Request) {
</span></span><span style=display:flex><span>	c <span style=color:#000;font-weight:700>:=</span> engine.pool.<span style=color:#900;font-weight:700>Get</span>().(<span style=color:#000;font-weight:700>*</span>Context)
</span></span><span style=display:flex><span>	c.writermem.<span style=color:#900;font-weight:700>reset</span>(w)
</span></span><span style=display:flex><span>	c.Request = req
</span></span><span style=display:flex><span>	c.<span style=color:#900;font-weight:700>reset</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	engine.<span style=color:#900;font-weight:700>handleHTTPRequest</span>(c)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	engine.pool.<span style=color:#900;font-weight:700>Put</span>(c)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>先调用 Get 取出来缓存的对象，然后会做一些 reset 操作，再执行 <code>handleHTTPRequest</code>，最后再 Put 回 Pool。</p><p>另外，Echo 框架也使⽤了 <code>sync.Pool</code> 来管理 <code>context</code>，并且⼏乎达到了零堆内存分配：</p><blockquote><p>It leverages sync pool to reuse memory and achieve zero dynamic memory allocation with no GC overhead.</p></blockquote><h1 id=源码分析>源码分析</h1><h2 id=pool-结构体>Pool 结构体</h2><p>首先来看 Pool 的结构体：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Pool <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	noCopy noCopy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 每个 P 的本地队列，实际类型为 [P]poolLocal
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	local     unsafe.Pointer <span style=color:#998;font-style:italic>// local fixed-size per-P pool, actual type is [P]poolLocal
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// [P]poolLocal的大小
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	localSize <span style=color:#458;font-weight:700>uintptr</span>        <span style=color:#998;font-style:italic>// size of the local array
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	victim     unsafe.Pointer <span style=color:#998;font-style:italic>// local from previous cycle
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	victimSize <span style=color:#458;font-weight:700>uintptr</span>        <span style=color:#998;font-style:italic>// size of victims array
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 自定义的对象创建回调函数，当 pool 中无可用对象时会调用此函数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	New <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 Pool 不希望被复制，所以结构体里有一个 noCopy 的字段，使用 <code>go vet</code> 工具可以检测到用户代码是否复制了 Pool。</p><blockquote><p><code>noCopy</code> 是 go1.7 开始引入的一个静态检查机制。它不仅仅工作在运行时或标准库，同时也对用户代码有效。</p></blockquote><blockquote><p>用户只需实现这样的不消耗内存、仅用于静态分析的结构，来保证一个对象在第一次使用后不会发生复制。</p></blockquote><p>实现非常简单：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// noCopy 用于嵌入一个结构体中来保证其第一次使用后不会被复制
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 见 https://golang.org/issues/8005#issuecomment-190753527
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> noCopy <span style=color:#000;font-weight:700>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Lock 是一个空操作用来给 `go vet` 的 -copylocks 静态分析
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (<span style=color:#000;font-weight:700>*</span>noCopy) <span style=color:#900;font-weight:700>Lock</span>()   {}
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (<span style=color:#000;font-weight:700>*</span>noCopy) <span style=color:#900;font-weight:700>Unlock</span>() {}
</span></span></code></pre></div><p><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针，<code>localSize</code> 则表示 local 数组的大小。访问时，P 的 id 对应 <code>[P]poolLocal</code> 下标索引。通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</p><p>在一轮 GC 到来时，victim 和 victimSize 会分别“接管” local 和 localSize。<code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑。</p><blockquote><p>Victim Cache 本来是计算机架构里面的一个概念，是 CPU 硬件处理缓存的一种技术，<code>sync.Pool</code> 引入的意图在于降低 GC 压力的同时提高命中率。</p></blockquote><p>当 Pool 没有缓存的对象时，调用 <code>New</code> 方法生成一个新的对象。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> poolLocal <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	poolLocalInternal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 将 poolLocal 补齐至两个缓存行的倍数，防止 false sharing,
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 每个缓存行具有 64 bytes，即 512 bit
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 目前我们的处理器一般拥有 32 * 1024 / 64 = 512 条缓存行
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	pad [<span style=color:#099>128</span> <span style=color:#000;font-weight:700>-</span> unsafe.<span style=color:#900;font-weight:700>Sizeof</span>(poolLocalInternal{})<span style=color:#000;font-weight:700>%</span><span style=color:#099>128</span>]<span style=color:#458;font-weight:700>byte</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Local per-P Pool appendix.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> poolLocalInternal <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// P 的私有缓存区，使用时无需要加锁
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	private <span style=color:#000;font-weight:700>interface</span>{}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 公共缓存区。本地 P 可以 pushHead/popHead；其他 P 则只能 popTail
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	shared  poolChain
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>字段 <code>pad</code> 主要是防止 <code>false sharing</code>，董大的<a href=https://www.jianshu.com/p/dc4b5562aad2>《什么是 cpu cache》</a>里讲得比较好：</p><blockquote><p>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。</p></blockquote><blockquote><p>程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><p><code>poolChain</code> 是一个双端队列的实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> poolChain <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 只有生产者会 push to，不用加锁
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	head <span style=color:#000;font-weight:700>*</span>poolChainElt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 读写需要原子控制。 pop from
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	tail <span style=color:#000;font-weight:700>*</span>poolChainElt
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> poolChainElt <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	poolDequeue
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// next 被 producer 写，consumer 读。所以只会从 nil 变成 non-nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// prev 被 consumer 写，producer 读。所以只会从 non-nil 变成 nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	next, prev <span style=color:#000;font-weight:700>*</span>poolChainElt
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> poolDequeue <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// The head index is stored in the most-significant bits so
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// that we can atomically add to it and the overflow is
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// harmless.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// headTail 包含一个 32 位的 head 和一个 32 位的 tail 指针。这两个值都和 len(vals)-1 取模过。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// tail 是队列中最老的数据，head 指向下一个将要填充的 slot
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// slots 的有效范围是 [tail, head)，由 consumers 持有。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	headTail <span style=color:#458;font-weight:700>uint64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// vals 是一个存储 interface{} 的环形队列，它的 size 必须是 2 的幂
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 如果 slot 为空，则 vals[i].typ 为空；否则，非空。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 一个 slot 在这时宣告无效：tail 不指向它了，vals[i].typ 为 nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 由 consumer 设置成 nil，由 producer 读
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	vals []eface
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。</p></blockquote><blockquote><p><code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p></blockquote><p>我们用一幅图来完整地描述 Pool 结构体：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125200.png><img class=mx-auto alt="Pool 结构体" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125200.png></a></p><p>结合木白的技术私厨的<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487149&idx=1&sn=f38f2d72fd7112e19e97d5a2cd304430&source=41#wechat_redirect">《请问sync.Pool有什么缺点?》</a>里的一张图，对于双端队列的理解会更容易一些：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/image-20190805225842592.png><img class=mx-auto alt="Pool 结构体" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/image-20190805225842592.png></a></p><p>我们看到 Pool 并没有直接使用 poolDequeue，原因是它的大小是固定的，而 Pool 的大小是没有限制的。因此，在 poolDequeue 之上包装了一下，变成了一个 <code>poolChainElt</code> 的双向链表，可以动态增长。</p><h2 id=get>Get</h2><p>直接上源码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Pool) <span style=color:#900;font-weight:700>Get</span>() <span style=color:#000;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// ......
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	l, pid <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>pin</span>()
</span></span><span style=display:flex><span>	x <span style=color:#000;font-weight:700>:=</span> l.private
</span></span><span style=display:flex><span>	l.private = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		x, _ = l.shared.<span style=color:#900;font-weight:700>popHead</span>()
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			x = p.<span style=color:#900;font-weight:700>getSlow</span>(pid)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>runtime_procUnpin</span>()
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// ......
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> p.New <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		x = p.<span style=color:#900;font-weight:700>New</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> x
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>省略号的内容是 <code>race</code> 相关的，属于阅读源码过程中的一些噪音，暂时注释掉。这样，Get 的整个过程就非常清晰了：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除非抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><p>我用一张流程图来展示整个过程：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418091935.png><img class=mx-auto alt="Get 流程图" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418091935.png></a></p><p>整体流程梳理完了，我们再来看一下其中的一些关键函数。</p><h3 id=pin>pin</h3><p>先来看 <code>Pool.pin()</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/pool.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用方必须在完成取值后调用 runtime_procUnpin() 来取消抢占。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Pool) <span style=color:#900;font-weight:700>pin</span>() (<span style=color:#000;font-weight:700>*</span>poolLocal, <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	pid <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>runtime_procPin</span>()
</span></span><span style=display:flex><span>	s <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUintptr</span>(<span style=color:#000;font-weight:700>&amp;</span>p.localSize) <span style=color:#998;font-style:italic>// load-acquire
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	l <span style=color:#000;font-weight:700>:=</span> p.local                          <span style=color:#998;font-style:italic>// load-consume
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 因为可能存在动态的 P（运行时调整 P 的个数）
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>uintptr</span>(pid) &lt; s {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>indexLocal</span>(l, pid), pid
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> p.<span style=color:#900;font-weight:700>pinSlow</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>pin</code> 的作用就是将当前 groutine 和 P 绑定在一起，禁止抢占。并且返回对应的 poolLocal 以及 P 的 id。</p><p>如果 G 被抢占，则 G 的状态从 running 变成 runnable，会被放回 P 的 localq 或 globaq，等待下一次调度。下次再执行时，就不一定是和现在的 P 相结合了。因为之后会用到 pid，如果被抢占了，有可能接下来使用的 pid 与所绑定的 P 并非同一个。</p><p>“绑定”的任务最终交给了 <code>procPin</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/runtime/proc.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>procPin</span>() <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>	_g_ <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>getg</span>()
</span></span><span style=display:flex><span>	mp <span style=color:#000;font-weight:700>:=</span> _g_.m
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	mp.locks<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>int</span>(mp.p.<span style=color:#900;font-weight:700>ptr</span>().id)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实现的代码很简洁：将当前 goroutine 绑定的 m 上的一个锁字段 locks 值加 1，即完成了“绑定”。关于 pin 的原理，可以参考<a href=https://zhuanlan.zhihu.com/p/99710992>《golang的对象池sync.pool源码解读》</a>，文章详细分析了为什么执行 <code>procPin</code> 之后，不可抢占，且 GC 不会清扫 Pool 里的对象。</p><p>我们再回到 <code>p.pin()</code>，原子操作取出 <code>p.localSize</code> 和 <code>p.local</code>，如果当前 <code>pid</code> 小于 <code>p.localSize</code>，则直接取 poolLocal 数组中的 pid 索引处的元素。否则，说明 Pool 还没有创建 poolLocal，调用 <code>p.pinSlow()</code> 完成创建工作。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Pool) <span style=color:#900;font-weight:700>pinSlow</span>() (<span style=color:#000;font-weight:700>*</span>poolLocal, <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Retry under the mutex.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// Can not lock the mutex while pinned.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#900;font-weight:700>runtime_procUnpin</span>()
</span></span><span style=display:flex><span>	allPoolsMu.<span style=color:#900;font-weight:700>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>defer</span> allPoolsMu.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>	pid <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>runtime_procPin</span>()
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// poolCleanup won&#39;t be called while we are pinned.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 没有使用原子操作，因为已经加了全局锁了
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	s <span style=color:#000;font-weight:700>:=</span> p.localSize
</span></span><span style=display:flex><span>	l <span style=color:#000;font-weight:700>:=</span> p.local
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 因为 pinSlow 中途可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查。 如果 pid 在 p.local 大小范围内，则不用创建 poolLocal 切片，直接返回。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>uintptr</span>(pid) &lt; s {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>indexLocal</span>(l, pid), pid
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> p.local <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		allPools = <span style=color:#0086b3>append</span>(allPools, p)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 当前 P 的数量
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	size <span style=color:#000;font-weight:700>:=</span> runtime.<span style=color:#900;font-weight:700>GOMAXPROCS</span>(<span style=color:#099>0</span>)
</span></span><span style=display:flex><span>	local <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>([]poolLocal, size)
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 旧的 local 会被回收
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	atomic.<span style=color:#900;font-weight:700>StorePointer</span>(<span style=color:#000;font-weight:700>&amp;</span>p.local, unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>local[<span style=color:#099>0</span>])) <span style=color:#998;font-style:italic>// store-release
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	atomic.<span style=color:#900;font-weight:700>StoreUintptr</span>(<span style=color:#000;font-weight:700>&amp;</span>p.localSize, <span style=color:#0086b3>uintptr</span>(size))         <span style=color:#998;font-style:italic>// store-release
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>local[pid], pid
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为要上一把大锁 <code>allPoolsMu</code>，所以函数名带有 <code>slow</code>。我们知道，锁粒度越大，竞争越多，自然就越“slow”。不过要想上锁的话，得先解除“绑定”，锁上之后，再执行“绑定”。原因是锁越大，被阻塞的概率就越大，如果还占着 P，那就浪费资源。</p><p>在解除绑定后，pinSlow 可能被其他的线程调用过了，p.local 可能会发生变化。因此这时候需要再次对 pid 进行检查。如果 pid 在 p.localSize 大小范围内，则不用再创建 poolLocal 切片，直接返回。</p><p>之后，根据 P 的个数，使用 make 创建切片，包含 <code>runtime.GOMAXPROCS(0)</code> 个 poolLocal，并且使用原子操作设置 p.local 和 p.localSize。</p><p>最后，返回 p.local 对应 pid 索引处的元素。</p><p>关于这把大锁 <code>allPoolsMu</code>，曹大在<a href=https://xargin.com/lock-contention-in-go/>《几个 Go 系统可能遇到的锁问题》</a>里讲了一个例子。第三方库用了 <code>sync.Pool</code>，内部有一个结构体 <code>fasttemplate.Template</code>，包含 <code>sync.Pool</code> 字段。而 rd 在使用时，每个请求都会新建这样一个结构体。于是，处理每个请求时，都会尝试从一个空的 Pool 里取缓存的对象，最后 goroutine 都阻塞在了这把大锁上，因为都在尝试执行：<code>allPools = append(allPools, p)</code>，从而造成性能问题。</p><h3 id=pophead>popHead</h3><p>回到 Get 函数，再来看另一个关键的函数：<code>poolChain.popHead()</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>poolChain) <span style=color:#900;font-weight:700>popHead</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	d <span style=color:#000;font-weight:700>:=</span> c.head
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> d <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> val, ok <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>popHead</span>(); ok {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> val, ok
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// There may still be unconsumed elements in the
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>// previous dequeue, so try backing up.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		d = <span style=color:#900;font-weight:700>loadPoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>d.prev)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>popHead</code> 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 popHead 方法。注意这两个 popHead 方法实际上并不相同，一个是 <code>poolChain</code> 的，一个是 <code>poolDequeue</code> 的，有疑惑的，不妨回头再看一下 Pool 结构体的图。我们来看 <code>poolDequeue.popHead()</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// /usr/local/go/src/sync/poolqueue.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d <span style=color:#000;font-weight:700>*</span>poolDequeue) <span style=color:#900;font-weight:700>popHead</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> slot <span style=color:#000;font-weight:700>*</span>eface
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>		ptrs <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail)
</span></span><span style=display:flex><span>		head, tail <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>unpack</span>(ptrs)
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 判断队列是否为空
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> tail <span style=color:#000;font-weight:700>==</span> head {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// Queue is empty.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// head 位置是队头的前一个位置，所以此处要先退一位。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>// 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		head<span style=color:#000;font-weight:700>--</span>
</span></span><span style=display:flex><span>		ptrs2 <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>pack</span>(head, tail)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail, ptrs, ptrs2) {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// We successfully took back slot.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			slot = <span style=color:#000;font-weight:700>&amp;</span>d.vals[head<span style=color:#000;font-weight:700>&amp;</span><span style=color:#0086b3>uint32</span>(<span style=color:#0086b3>len</span>(d.vals)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>)]
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 取出 val
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	val <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{})(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(slot))
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> val <span style=color:#000;font-weight:700>==</span> <span style=color:#900;font-weight:700>dequeueNil</span>(<span style=color:#000;font-weight:700>nil</span>) {
</span></span><span style=display:flex><span>		val = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 重置 slot，typ 和 val 均为 nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 这里清空的方式与 popTail 不同，与 pushHead 没有竞争关系，所以不用太小心
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>*</span>slot = eface{}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> val, <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 <code>unpack</code> 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 <code>nil，false</code>。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 <code>pack</code> 打包 head 和 tail 指针。使用 <code>atomic.CompareAndSwapUint64</code> 比较 headTail 在这之间是否有变化，如果没变化，相当于获取到了这把锁，那就更新 headTail 的值。并且把 vals 相应索引处的元素赋值给 slot。</p><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 相与，实际就是取 head 低 n 位的值。</p><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// /usr/local/go/src/sync/poolqueue.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 因为使用 nil 代表空的 slots，因此使用 dequeueNil 表示 interface{}(nil)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> dequeueNil <span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>struct</span>{}
</span></span></code></pre></div><p>最后，返回 val 之前，将 slot “归零”：<code>*slot = eface{}</code>。</p><p>回到 <code>poolChain.popHead()</code>，调用 <code>poolDequeue.popHead()</code> 拿到缓存的对象后，直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h3 id=getslow>getSlow</h3><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Pool) <span style=color:#900;font-weight:700>getSlow</span>(pid <span style=color:#458;font-weight:700>int</span>) <span style=color:#000;font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// See the comment in pin regarding ordering of the loads.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	size <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUintptr</span>(<span style=color:#000;font-weight:700>&amp;</span>p.localSize) <span style=color:#998;font-style:italic>// load-acquire
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	locals <span style=color:#000;font-weight:700>:=</span> p.local                        <span style=color:#998;font-style:italic>// load-consume
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// Try to steal one element from other procs.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 从其他 P 中窃取对象
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; <span style=color:#0086b3>int</span>(size); i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		l <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>indexLocal</span>(locals, (pid<span style=color:#000;font-weight:700>+</span>i<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>)<span style=color:#000;font-weight:700>%</span><span style=color:#0086b3>int</span>(size))
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> x, _ <span style=color:#000;font-weight:700>:=</span> l.shared.<span style=color:#900;font-weight:700>popTail</span>(); x <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> x
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 尝试从victim cache中取对象。这发生在尝试从其他 P 的 poolLocal 偷去失败后，
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// 因为这样可以使 victim 中的对象更容易被回收。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	size = atomic.<span style=color:#900;font-weight:700>LoadUintptr</span>(<span style=color:#000;font-weight:700>&amp;</span>p.victimSize)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>uintptr</span>(pid) <span style=color:#000;font-weight:700>&gt;=</span> size {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	locals = p.victim
</span></span><span style=display:flex><span>	l <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>indexLocal</span>(locals, pid)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>:=</span> l.private; x <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		l.private = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> x
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; <span style=color:#0086b3>int</span>(size); i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		l <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>indexLocal</span>(locals, (pid<span style=color:#000;font-weight:700>+</span>i)<span style=color:#000;font-weight:700>%</span><span style=color:#0086b3>int</span>(size))
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> x, _ <span style=color:#000;font-weight:700>:=</span> l.shared.<span style=color:#900;font-weight:700>popTail</span>(); x <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> x
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 清空 victim cache。下次就不用再从这里找了
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	atomic.<span style=color:#900;font-weight:700>StoreUintptr</span>(<span style=color:#000;font-weight:700>&amp;</span>p.victimSize, <span style=color:#099>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h3 id=poptail>popTail</h3><p>最后，还剩一个 popTail 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>poolChain) <span style=color:#900;font-weight:700>popTail</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	d <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>loadPoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tail)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> d <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>		d2 <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>loadPoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>d.next)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> val, ok <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>popTail</span>(); ok {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> val, ok
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> d2 <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// 双向链表只有一个尾节点，现在为空
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 双向链表的尾节点里的双端队列被“掏空”，所以继续看下一个节点。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>// 并且由于尾节点已经被“掏空”，所以要甩掉它。这样，下次 popHead 就不会再看它有没有缓存对象了。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapPointer</span>((<span style=color:#000;font-weight:700>*</span>unsafe.Pointer)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tail)), unsafe.<span style=color:#900;font-weight:700>Pointer</span>(d), unsafe.<span style=color:#900;font-weight:700>Pointer</span>(d2)) {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// 甩掉尾节点
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#900;font-weight:700>storePoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>d2.prev, <span style=color:#000;font-weight:700>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		d = d2
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>for</code> 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 <code>c.tail</code> 更新为 <code>d2</code>，可以防止下次 <code>popTail</code> 的时候查看一个空的 <code>dequeue</code>；而将 <code>d2.prev</code> 设置为 <code>nil</code>，可以防止下次 <code>popHead</code> 时查看一个空的 <code>dequeue</code>。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/poolqueue.go:147
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d <span style=color:#000;font-weight:700>*</span>poolDequeue) <span style=color:#900;font-weight:700>popTail</span>() (<span style=color:#000;font-weight:700>interface</span>{}, <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> slot <span style=color:#000;font-weight:700>*</span>eface
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>		ptrs <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail)
</span></span><span style=display:flex><span>		head, tail <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>unpack</span>(ptrs)
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 判断队列是否空
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> tail <span style=color:#000;font-weight:700>==</span> head {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// Queue is empty.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 先搞定 head 和 tail 指针位置。如果搞定，那么这个 slot 就归属我们了
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		ptrs2 <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>pack</span>(head, tail<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail, ptrs, ptrs2) {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// Success.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			slot = <span style=color:#000;font-weight:700>&amp;</span>d.vals[tail<span style=color:#000;font-weight:700>&amp;</span><span style=color:#0086b3>uint32</span>(<span style=color:#0086b3>len</span>(d.vals)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>)]
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// We now own slot.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	val <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{})(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(slot))
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> val <span style=color:#000;font-weight:700>==</span> <span style=color:#900;font-weight:700>dequeueNil</span>(<span style=color:#000;font-weight:700>nil</span>) {
</span></span><span style=display:flex><span>		val = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	slot.val = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	atomic.<span style=color:#900;font-weight:700>StorePointer</span>(<span style=color:#000;font-weight:700>&amp;</span>slot.typ, <span style=color:#000;font-weight:700>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// At this point pushHead owns the slot.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> val, <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>popTail</code> 从队列尾部移除一个元素，如果队列为空，返回 false。此函数可能同时被多个<code>消费者</code>调用。</p><p>函数的核心是一个无限循环，又是一个无锁编程。先解出 head，tail 指针值，如果两者相等，说明队列为空。</p><p>因为要从尾部移除一个元素，所以 tail 指针前进 1，然后使用原子操作设置 headTail。</p><p>最后，将要移除的 slot 的 val 和 typ “归零”：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>slot.val = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>atomic.<span style=color:#900;font-weight:700>StorePointer</span>(<span style=color:#000;font-weight:700>&amp;</span>slot.typ, <span style=color:#000;font-weight:700>nil</span>)
</span></span></code></pre></div><h2 id=put>Put</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/pool.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Put 将对象添加到 Pool 
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Pool) <span style=color:#900;font-weight:700>Put</span>(x <span style=color:#000;font-weight:700>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// ……
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	l, _ <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>pin</span>()
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> l.private <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		l.private = x
</span></span><span style=display:flex><span>		x = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> x <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		l.shared.<span style=color:#900;font-weight:700>pushHead</span>(x)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>runtime_procUnpin</span>()
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>//…… 
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>同样删掉了 race 相关的函数，看起来清爽多了。整个 Put 的逻辑也很清晰：</p><ol><li><p>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</p></li><li><p>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。</p></li></ol><p>同样用流程图来展示整个过程：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418092028.png><img class=mx-auto alt="Put 流程图" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418092028.png></a></p><h3 id=pushhead>pushHead</h3><p>我们来看 <code>pushHead</code> 的源码，比较清晰：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/poolqueue.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>poolChain) <span style=color:#900;font-weight:700>pushHead</span>(val <span style=color:#000;font-weight:700>interface</span>{}) {
</span></span><span style=display:flex><span>	d <span style=color:#000;font-weight:700>:=</span> c.head
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> d <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// poolDequeue 初始长度为8
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>const</span> initSize = <span style=color:#099>8</span> <span style=color:#998;font-style:italic>// Must be a power of 2
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		d = <span style=color:#0086b3>new</span>(poolChainElt)
</span></span><span style=display:flex><span>		d.vals = <span style=color:#0086b3>make</span>([]eface, initSize)
</span></span><span style=display:flex><span>		c.head = d
</span></span><span style=display:flex><span>		<span style=color:#900;font-weight:700>storePoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>c.tail, d)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> d.<span style=color:#900;font-weight:700>pushHead</span>(val) {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 前一个 poolDequeue 长度的 2 倍
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	newSize <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>len</span>(d.vals) <span style=color:#000;font-weight:700>*</span> <span style=color:#099>2</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> newSize <span style=color:#000;font-weight:700>&gt;=</span> dequeueLimit {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Can&#39;t make it any bigger.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		newSize = dequeueLimit
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// 首尾相连，构成链表
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	d2 <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>poolChainElt{prev: d}
</span></span><span style=display:flex><span>	d2.vals = <span style=color:#0086b3>make</span>([]eface, newSize)
</span></span><span style=display:flex><span>	c.head = d2
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>storePoolChainElt</span>(<span style=color:#000;font-weight:700>&amp;</span>d.next, d2)
</span></span><span style=display:flex><span>	d2.<span style=color:#900;font-weight:700>pushHead</span>(val)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> dequeueBits = <span style=color:#099>32</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> dequeueLimit = (<span style=color:#099>1</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> dequeueBits) <span style=color:#000;font-weight:700>/</span> <span style=color:#099>4</span>
</span></span></code></pre></div><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/poolqueue.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 将 val 添加到双端队列头部。如果队列已满，则返回 false。此函数只能被一个生产者调用
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (d <span style=color:#000;font-weight:700>*</span>poolDequeue) <span style=color:#900;font-weight:700>pushHead</span>(val <span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	ptrs <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail)
</span></span><span style=display:flex><span>	head, tail <span style=color:#000;font-weight:700>:=</span> d.<span style=color:#900;font-weight:700>unpack</span>(ptrs)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> (tail<span style=color:#000;font-weight:700>+</span><span style=color:#0086b3>uint32</span>(<span style=color:#0086b3>len</span>(d.vals)))<span style=color:#000;font-weight:700>&amp;</span>(<span style=color:#099>1</span><span style=color:#000;font-weight:700>&lt;&lt;</span>dequeueBits<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>) <span style=color:#000;font-weight:700>==</span> head {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 队列满了
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	slot <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>d.vals[head<span style=color:#000;font-weight:700>&amp;</span><span style=color:#0086b3>uint32</span>(<span style=color:#0086b3>len</span>(d.vals)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 检测这个 slot 是否被 popTail 释放
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	typ <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>slot.typ)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> typ <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 另一个 groutine 正在 popTail 这个 slot，说明队列仍然是满的
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// The head slot is free, so we own it.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> val <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		val = <span style=color:#900;font-weight:700>dequeueNil</span>(<span style=color:#000;font-weight:700>nil</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// slot占位，将val存入vals中
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{})(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(slot)) = val
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// head 增加 1
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	atomic.<span style=color:#900;font-weight:700>AddUint64</span>(<span style=color:#000;font-weight:700>&amp;</span>d.headTail, <span style=color:#099>1</span><span style=color:#000;font-weight:700>&lt;&lt;</span>dequeueBits)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先判断队列是否已满：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> (tail<span style=color:#000;font-weight:700>+</span><span style=color:#0086b3>uint32</span>(<span style=color:#0086b3>len</span>(d.vals)))<span style=color:#000;font-weight:700>&amp;</span>(<span style=color:#099>1</span><span style=color:#000;font-weight:700>&lt;&lt;</span>dequeueBits<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>) <span style=color:#000;font-weight:700>==</span> head {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Queue is full.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是将尾部指针加上 <code>d.vals</code> 的长度，再取低 31 位，看它是否和 head 相等。我们知道，<code>d.vals</code> 的长度实际上是固定的，因此如果队列已满，那么 if 语句的两边就是相等的。如果队列满了，直接返回 false。</p><p>否则，队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// Check if the head slot has been released by popTail.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>typ <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>slot.typ)
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> typ <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Another goroutine is still cleaning up the tail, so
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// the queue is actually still full.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// popTail 是先设置 val，再将 typ 设置为 nil。设置完 typ 之后，popHead 才可以操作这个 slot
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面这一段用来判断是否和 popTail 有冲突发生，如果有，则直接返回 false。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// slot占位，将val存入vals中
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{})(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(slot)) = val
</span></span></code></pre></div><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h2 id=packunpack>pack/unpack</h2><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/poolqueue.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> dequeueBits = <span style=color:#099>32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d <span style=color:#000;font-weight:700>*</span>poolDequeue) <span style=color:#900;font-weight:700>pack</span>(head, tail <span style=color:#458;font-weight:700>uint32</span>) <span style=color:#458;font-weight:700>uint64</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>const</span> mask = <span style=color:#099>1</span><span style=color:#000;font-weight:700>&lt;&lt;</span>dequeueBits <span style=color:#000;font-weight:700>-</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> (<span style=color:#0086b3>uint64</span>(head) <span style=color:#000;font-weight:700>&lt;&lt;</span> dequeueBits) |
</span></span><span style=display:flex><span>		<span style=color:#0086b3>uint64</span>(tail<span style=color:#000;font-weight:700>&amp;</span>mask)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>mask</code> 的低 31 位为全 1，其他位为 0，它和 tail 相与，就是只看 tail 的低 31 位。而 head 向左移 32 位之后，低 32 位为全 0。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</p><p>相应的解绑函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (d <span style=color:#000;font-weight:700>*</span>poolDequeue) <span style=color:#900;font-weight:700>unpack</span>(ptrs <span style=color:#458;font-weight:700>uint64</span>) (head, tail <span style=color:#458;font-weight:700>uint32</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>const</span> mask = <span style=color:#099>1</span><span style=color:#000;font-weight:700>&lt;&lt;</span>dequeueBits <span style=color:#000;font-weight:700>-</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>	head = <span style=color:#0086b3>uint32</span>((ptrs <span style=color:#000;font-weight:700>&gt;&gt;</span> dequeueBits) <span style=color:#000;font-weight:700>&amp;</span> mask)
</span></span><span style=display:flex><span>	tail = <span style=color:#0086b3>uint32</span>(ptrs <span style=color:#000;font-weight:700>&amp;</span> mask)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h2 id=gc>GC</h2><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。</p><blockquote><p>几乎所有的池技术中，都会在某个时刻清空或清除部分缓存对象，那么在 Go 中何时清理未使用的对象呢？</p></blockquote><p>答案是 GC 发生时。</p><p>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/sync/pool.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#900;font-weight:700>runtime_registerPoolCleanup</span>(poolCleanup)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器在背后做了一些动作：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// src/runtime/mgc.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Hooks for other packages
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> poolcleanup <span style=color:#000;font-weight:700>func</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 利用编译器标志将 sync 包中的清理注册到运行时
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>sync_runtime_registerPoolCleanup</span>(f <span style=color:#000;font-weight:700>func</span>()) {
</span></span><span style=display:flex><span>	poolcleanup = f
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体来看下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>poolCleanup</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> _, p <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> oldPools {
</span></span><span style=display:flex><span>		p.victim = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>		p.victimSize = <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Move primary cache to victim cache.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>for</span> _, p <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> allPools {
</span></span><span style=display:flex><span>		p.victim = p.local
</span></span><span style=display:flex><span>		p.victimSize = p.localSize
</span></span><span style=display:flex><span>		p.local = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>		p.localSize = <span style=color:#099>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	oldPools, allPools = allPools, <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>poolCleanup</code> 会在 STW 阶段被调用。整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><blockquote><p>如果 <code>sync.Pool</code> 的获取、释放速度稳定，那么就不会有新的池对象进行分配。如果获取的速度下降了，那么对象可能会在两个 <code>GC</code> 周期内被释放，而不是以前的一个 <code>GC</code> 周期。</p></blockquote><blockquote><p>鸟窝的<a href=https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/>【Go 1.13中 sync.Pool 是如何优化的?】</a>讲了 1.13 中的优化。</p></blockquote><p>参考资料<a href=https://zhuanlan.zhihu.com/p/110140126>【理解 Go 1.13 中 sync.Pool 的设计与实现】</a> 手动模拟了一下调用 <code>poolCleanup</code> 函数前后 oldPools，allPools，p.vitcim 的变化过程，很精彩：</p><blockquote><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li></ol></blockquote><ol start=2><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。</li></ol><p>我根据这个流程画了一张图，可以理解地更清晰一些：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125040.png><img class=mx-auto alt="poolCleanup 过程" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125040.png></a></p><p>需要指出的是，<code>allPools</code> 和 <code>oldPools</code> 都是切片，切片的元素是指向 Pool 的指针，Get/Put 操作不需要通过它们。在第 6 步，如果还有其他 Pool 执行了 Put 操作，<code>allPools</code> 这时就会有多个元素。</p><p>在 Go 1.13 之前的实现中，<code>poolCleanup</code> 比较“简单粗暴”：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>poolCleanup</span>() {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> i, p <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> allPools {
</span></span><span style=display:flex><span>        allPools[i] = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; <span style=color:#0086b3>int</span>(p.localSize); i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>            l <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>indexLocal</span>(p.local, i)
</span></span><span style=display:flex><span>            l.private = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>for</span> j <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> l.shared {
</span></span><span style=display:flex><span>                l.shared[j] = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            l.shared = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        p.local = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>        p.localSize = <span style=color:#099>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    allPools = []<span style=color:#000;font-weight:700>*</span>Pool{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>直接清空了所有 Pool 的 <code>p.local</code> 和 <code>poolLocal.shared</code>。</p><blockquote><p>通过两者的对比发现，新版的实现相比 Go 1.13 之前，GC 的粒度拉大了，由于实际回收的时间线拉长，单位时间内 GC 的开销减小。</p></blockquote><blockquote><p>由此基本明白 p.victim 的作用。它的定位是次级缓存，GC 时将对象放入其中，下一次 GC 来临之前如果有 Get 调用则会从 p.victim 中取，直到再一次 GC 来临时回收。</p></blockquote><blockquote><p>同时由于从 p.victim 中取出对象使用完毕之后并未放回 p.victim 中，在一定程度也减小了下一次 GC 的开销。原来 1 次 GC 的开销被拉长到 2 次且会有一定程度的开销减小，这就是 p.victim 引入的意图。</p></blockquote><p><a href=https://zhuanlan.zhihu.com/p/110140126>【理解 Go 1.13 中 sync.Pool 的设计与实现】</a> 这篇文章最后还总结了 <code>sync.Pool</code> 的设计理念，包括：无锁、操作对象隔离、原子操作代替锁、行为隔离——链表、Victim Cache 降低 GC 开销。写得非常不错，推荐阅读。</p><p>另外，关于 <code>sync.Pool</code> 中锁竞争优化的文章，推荐阅读芮大神的<a href=http://xiaorui.cc/archives/5878>【优化锁竞争】</a>。</p><h1 id=总结>总结</h1><p>本文先是介绍了 Pool 是什么，有什么作用，接着给出了 Pool 的用法以及在标准库、一些第三方库中的用法，还介绍了 pool_test 中的一些测试用例。最后，详细解读了 <code>sync.Pool</code> 的源码。</p><p>本文的结尾部分，再来详细地总结一下关于 <code>sync.Pool</code> 的要点：</p><ol><li><p>关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p><code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>Go 语言内置的 fmt 包，encoding/json 包都可以看到 sync.Pool 的身影；<code>gin</code>，<code>Echo</code> 等框架也都使用了 sync.Pool。</p></li><li><p>不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li><li><p>Pool 不可以指定⼤⼩，⼤⼩只受制于 GC 临界值。</p></li><li><p><code>procPin</code> 将 G 和 P 绑定，防止 G 被抢占。在绑定期间，GC 无法清理缓存的对象。</p></li><li><p>在加入 <code>victim</code> 机制前，sync.Pool 里对象的最⼤缓存时间是一个 GC 周期，当 GC 开始时，没有被引⽤的对象都会被清理掉；加入 <code>victim</code> 机制后，最大缓存时间为两个 GC 周期。</p></li><li><p>Victim Cache 本来是计算机架构里面的一个概念，是 CPU 硬件处理缓存的一种技术，<code>sync.Pool</code> 引入的意图在于降低 GC 压力的同时提高命中率。</p></li><li><p><code>sync.Pool</code> 的最底层使用切片加链表来实现双端队列，并将缓存的对象存储在切片中。</p></li></ol><h1 id=参考资料>参考资料</h1><p>【欧神 源码分析】 <a href=https://changkun.us/archives/2018/09/256/>https://changkun.us/archives/2018/09/256/</a></p><p>【Go 夜读】 <a href=https://reading.hidevops.io/reading/20180817/2018-08-17-sync-pool-reading.pdf>https://reading.hidevops.io/reading/20180817/2018-08-17-sync-pool-reading.pdf</a></p><p>【夜读第 14 期视频】 <a href="https://www.youtube.com/watch?v=jaepwn2PWPk&amp;amp;list=PLe5svQwVF1L5bNxB0smO8gNfAZQYWdIpI">https://www.youtube.com/watch?v=jaepwn2PWPk&amp;amp;list=PLe5svQwVF1L5bNxB0smO8gNfAZQYWdIpI</a></p><p>【源码分析，伪共享】 <a href=https://juejin.im/post/5d4087276fb9a06adb7fbe4a>https://juejin.im/post/5d4087276fb9a06adb7fbe4a</a></p><p>【golang的对象池sync.pool源码解读】 <a href=https://zhuanlan.zhihu.com/p/99710992>https://zhuanlan.zhihu.com/p/99710992</a></p><p>【理解 Go 1.13 中 sync.Pool 的设计与实现】 <a href=https://zhuanlan.zhihu.com/p/110140126>https://zhuanlan.zhihu.com/p/110140126</a></p><p>【优缺点，图】 <a href=http://cbsheng.github.io/posts/golang%E6%A0%87%E5%87%86%E5%BA%93sync.pool%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/>http://cbsheng.github.io/posts/golang%E6%A0%87%E5%87%86%E5%BA%93sync.pool%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</a></p><p>【xiaorui 优化锁竞争】 <a href=http://xiaorui.cc/archives/5878>http://xiaorui.cc/archives/5878</a></p><p>【性能优化之路，自定义多种规格的缓存】 <a href=https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool>https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool</a></p><p>【sync.Pool 有什么缺点】 <a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487149&amp;amp;idx=1&amp;amp;sn=f38f2d72fd7112e19e97d5a2cd304430&source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487149&amp;amp;idx=1&amp;amp;sn=f38f2d72fd7112e19e97d5a2cd304430&source=41#wechat_redirect</a></p><p>【1.12 和 1.13 的演变】 <a href=https://github.com/watermelo/dailyTrans/blob/master/golang/sync_pool_understand.md>https://github.com/watermelo/dailyTrans/blob/master/golang/sync_pool_understand.md</a></p><p>【董泽润 演进】 <a href=https://www.jianshu.com/p/2e08332481c5>https://www.jianshu.com/p/2e08332481c5</a></p><p>【noCopy】 <a href=https://github.com/golang/go/issues/8005#issuecomment-190753527>https://github.com/golang/go/issues/8005#issuecomment-190753527</a></p><p>【董泽润 cpu cache】 <a href=https://www.jianshu.com/p/dc4b5562aad2>https://www.jianshu.com/p/dc4b5562aad2</a></p><p>【gomemcache 例子】 <a href=https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter16/16.01.html>https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter16/16.01.html</a></p><p>【鸟窝 1.13 优化】 <a href=https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</a></p><p>【A journey with go】 <a href=https://medium.com/a-journey-with-go/go-understand-the-design-of-sync-pool-2dde3024e277>https://medium.com/a-journey-with-go/go-understand-the-design-of-sync-pool-2dde3024e277</a></p><p>【封装了一个计数组件】 <a href=https://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/>https://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/</a></p><p>【伪共享】 <a href=http://ifeve.com/falsesharing/>http://ifeve.com/falsesharing/</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-go-sync-pool/>https://qcrao.com/post/dive-into-go-sync-pool/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>