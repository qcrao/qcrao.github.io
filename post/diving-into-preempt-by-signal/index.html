<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 Go 语言之基于信号的抢占式调度 | qcrao 的博客</title><meta property="og:title" content="深度解密 Go 语言之基于信号的抢占式调度 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-05-12T23:12:56+08:00"><meta property="article:modified_time" content="2021-05-12T23:12:56+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 Go 语言之基于信号的抢占式调度"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/diving-into-preempt-by-signal/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css integrity=sha384-KyZXEAg3QhqLMpG8r+Knujsl5wVI+KzIO2G2Z4h4z2g5zF0VyQDq7V2E6Z8D6pv crossorigin=anonymous><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 Go 语言之基于信号的抢占式调度</h1></header><date class="post-meta meta-date">2021年5月12日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>不知道大家在实际工作中有没有遇到过老版本 Go 调度器的坑：死循环导致程序“死机”。我去年就遇到过，并且搞出了一起 P0 事故，还写了篇弱智的找 bug <a href=https://mp.weixin.qq.com/s/xe8KXD39YlJdDG4cLT0veA>文章</a>。</p><p>识别事故的本质，并且用一个非常简单的示例展示出来，是功力的一种体现。那次事故的原因可以简化成如下的 demo：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230327.png><img class=mx-auto alt=demo-1 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230327.png></a></p><p>我来简单解释一下上面这个程序。在主 goroutine 里，先用 GoMAXPROCS 函数拿到 CPU 的逻辑核心数 threads。这意味着 Go 进程会创建 threads 个数的 P。接着，启动了 threads 个数的 goroutine，每个 goroutine 都在执行一个无限循环，并且这个无限循环只是简单地执行 <code>x++</code>。</p><p>接着，主 goroutine sleep 了 1 秒钟；最后，打印 x 的值。</p><p>你可以自己思考一下，输出会是什么？</p><p>如果你想出了答案，接着再看下面这个 demo：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230413.png><img class=mx-auto alt=demo-2 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230413.png></a></p><p>我也来解释一下，在主 goroutine 里，只启动了一个 goroutine（虽然程序里用了一个 for 循环，但其实只循环了一次，完全是为了和前面的 demo 看起来更协调一些），同样执行了一个 <code>x++</code> 的无限 for 循环。</p><p>和前一个 demo 的不同点在于，在主 goroutine 里，我们手动执行了一次 GC；最后，打印 x 的值。</p><p>如果你能答对第一题，大概率也能答对第二题。</p><p>下面我就来揭晓答案。</p><p>其实我留了一个坑，我没说用哪个版本的 Go 来运行代码。所以，正确的答案是：</p><table><thead><tr><th>Go 版本</th><th>demo-1</th><th>demo-2</th></tr></thead><tbody><tr><td>1.13</td><td>卡死</td><td>卡死</td></tr><tr><td>1.14</td><td>0</td><td>0</td></tr></tbody></table><p>这个其实就是 Go 调度器的坑了。</p><p>假设在 demo-1 中，共有 4 个 P，于是创建了 4 个 goroutine。当主 goroutine 执行 sleep 的时候，刚刚创建的 4 个 goroutine 马上就把 4 个 P 霸占了，执行死循环，而且竟然没有进行函数调用，就只有一个简单的赋值语句。Go 1.13 对这种情况是无能为力的，没有任何办法让这些 goroutine 停下来，进程对外表现出“死机”。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507231301.png><img class=mx-auto alt="demo-1 示意图" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507231301.png></a></p><p>由于 Go 1.14 实现了基于信号的抢占式调度，这些执行无限循环的 goroutine 会被调度器“拿下”，P 就会空出来。所以当主 goroutine sleep 时间到了之后，马上就能获得 P，并得以打印出 x 的值。至于 x 为什么输出的是 0，不太好解释，因为这是一种未定义（有数据竞争，正常情况下要加锁）的行为，可能的一个原因是 CPU 的 cache 没有来得及更新，不过不太好验证。</p><p>理解了这个 demo，第二个 demo 其实是类似的道理：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507232036.png><img class=mx-auto alt="demo-2 示意图" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507232036.png></a></p><p>当主 goroutine 主动触发 GC 时，需要把所有当前正在运行的 goroutine 停止下来，即 stw（stop the world），但是 goroutine 正在执行无限循环，没法让它停下来。当然，Go 1.14 还是可以抢占掉这个 goroutine，从而打印出 x 的值，也是 0。</p><p>Go 1.14 之前的版本，能否抢占一个正在执行死循环的 goroutine 其实是有讲究的：</p><blockquote><p>能否被抢占，不是看有没有调用函数，而是看函数的序言部分有没有插入扩栈检测指令。</p></blockquote><blockquote><p>如果没有调用函数，肯定不会被抢占。</p></blockquote><blockquote><p>有些虽然也调用了函数，但其实不会插入检测指令，这个时候也不会被抢占。</p></blockquote><p>像前面的两个 demo，不可能有机会在函数扩栈检测期间主动放弃 CPU 使用权，从而完成抢占，因为没有函数调用。具体的过程后面有机会再写一篇文章详细讲，本文主要看基于信号的抢占式调度如何实现。</p><h1 id=preemptone>preemptone</h1><p>一方面，Go 进程在启动的时候，会开启一个后台线程 sysmon，监控执行时间过长的 goroutine，进而发出抢占。另一方面，GC 执行 stw 时，会让所有的 goroutine 都停止，其实就是抢占。这两者都会调用 <code>preemptone()</code> 函数。</p><p><code>preemptone()</code> 函数会沿着下面这条路径：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>preemptone-&gt;preemptM-&gt;signalM-&gt;tgkill
</span></span></code></pre></div><p>向正在运行的 goroutine 所绑定的的那个 M（也可以说是线程）发出 <code>SIGURG</code> 信号。</p><h1 id=注册-sighandler>注册 sighandler</h1><p>每个 M 在初始化的时候都会设置信号处理函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>initsig-&gt;setsig-&gt;sighandler
</span></span></code></pre></div><h1 id=信号执行过程>信号执行过程</h1><p>我们从“宏观”层面看一下信号的执行过程：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507233951.png><img class=mx-auto alt=信号执行过程 src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507233951.png></a></p><p>主程序（线程）正在“勤勤恳恳”地执行指令：它已经执行完了指令 <code>m</code>，接着就要执行指令 <code>m+1</code> 了……不幸在这个时候发生了，线程收到了一个信号，对应图中的 <code>①</code>。</p><p>接着，内核会接管执行流，转而去执行预先设置好的信号处理器程序，对应到 Go 里，就是执行 sighandler，对应图中的 <code>②</code> 和 <code>③</code>。</p><p>最后，执行流又交到线程手上，继续执行指令 <code>m+1</code>，对应图中的 <code>④</code>。</p><p>这里其实涉及到了一些现场的保护和恢复，内核都帮我们搞定了，我们不用操心。</p><h1 id=dosigpreempt>dosigPreempt</h1><p>当线程收到 <code>SIGURG</code> 信号的时候，就会去执行 sighandler 函数，核心是 doSigPreempt 函数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>sighandler</span>(sig <span style=color:#458;font-weight:700>uint32</span>, info <span style=color:#000;font-weight:700>*</span>siginfo, ctxt unsafe.Pointer, gp <span style=color:#000;font-weight:700>*</span>g) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> sig <span style=color:#000;font-weight:700>==</span> sigPreempt <span style=color:#000;font-weight:700>&amp;&amp;</span> debug.asyncpreemptoff <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#900;font-weight:700>doSigPreempt</span>(gp, c)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>doSigPreempt</code> 这个函数其实很短，一会儿就执行完了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>doSigPreempt</span>(gp <span style=color:#000;font-weight:700>*</span>g, ctxt <span style=color:#000;font-weight:700>*</span>sigctxt) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> ok, newpc <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>isAsyncSafePoint</span>(gp, ctxt.<span style=color:#900;font-weight:700>sigpc</span>(), ctxt.<span style=color:#900;font-weight:700>sigsp</span>(), ctxt.<span style=color:#900;font-weight:700>siglr</span>()); ok {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// Adjust the PC and inject a call to asyncPreempt.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		ctxt.<span style=color:#900;font-weight:700>pushCall</span>(<span style=color:#900;font-weight:700>funcPC</span>(asyncPreempt), newpc)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>isAsyncSafePoint</code> 函数会返回当前 goroutine 能否被抢占，以及从哪条指令开始抢占，返回的 newpc 表示安全的抢占地址。</p><p>接着，<code>pushCall</code> 调整了一下 SP，设置了几个寄存器的值就返回了。按理说，返回之后，就会接着执行指令 <code>m+1</code> 了，但那还怎么实现抢占呢？其实魔法都在 <code>pushCall</code> 这个函数里。</p><h1 id=pushcall>pushCall</h1><p>在分析这个函数之前，我们需要先复习一下 Go 函数的调用规约，重点回顾一下 CALL 和 RET 指令就行了。</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509114734.png><img class=mx-auto alt="call 和 ret 指令" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509114734.png></a></p><p><code>call</code> 指令可以简单地理解为 <code>push ip</code> + <code>JMP</code>。这个 ip 其实就是返回地址，也就是调用完子函数接下来该执行啥指令的地址。所以 <code>push ip</code> 就是在 call 一个子函数之前，将返回地址压入栈中，然后 JMP 到子函数的地址执行。</p><p><code>ret</code> 指令和 <code>call</code> 指令刚好相反，它将返回地址从栈上 pop 到 IP 寄存器，使得 CPU 从这个地址继续执行。</p><p>理解了 <code>call</code> 和 <code>ret</code>，我们再来分析 <code>pushCall</code> 函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (c <span style=color:#000;font-weight:700>*</span>sigctxt) <span style=color:#900;font-weight:700>pushCall</span>(targetPC, resumePC <span style=color:#458;font-weight:700>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// Make it look like we called target at resumePC.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	sp <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>uintptr</span>(c.<span style=color:#900;font-weight:700>rsp</span>())
</span></span><span style=display:flex><span>	sp <span style=color:#000;font-weight:700>-=</span> sys.PtrSize
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>uintptr</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(sp)) = resumePC
</span></span><span style=display:flex><span>	c.<span style=color:#900;font-weight:700>set_rsp</span>(<span style=color:#0086b3>uint64</span>(sp))
</span></span><span style=display:flex><span>	c.<span style=color:#900;font-weight:700>set_rip</span>(<span style=color:#0086b3>uint64</span>(targetPC))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意看这行注释：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>// Make it look like we called target at resumePC.
</span></span></code></pre></div><p>它清晰地说明了这个函数的作用：让 CPU 误以为是 resumePC 调用了 targetPC。而这个 resumePC 就是上一步调用 isAsyncSafePoint 函数返回的 newpc，它代表我们抢占 goroutine 的指令地址。</p><p>前两行代码将 SP 下移了 8 个字节，并且把 resumePC 入栈（注意，它其实是一个返回地址），接着把 targetPC 设置到 ip 寄存器，sp 设置到 SP 寄存器。这使得从内核返回到用户态执行时，不是从指令 <code>m+1</code>，而是直接从 targetPC 开始执行，等到 targetPC 执行完，才会返回到 resumePC 继续执行。整个过程就像是 resumePC 调用了 targetPC 一样。而 targetPC 其实就是 <code>funcPC(asyncPreempt)</code>，也就是抢占函数。</p><p>于是我们可以看到，信号处理器程序 sighandler 只是将一个异步抢占函数给“安插”进来了，而真正的抢占过程则是在 asyncPreempt 函数中完成。</p><h1 id=异步抢占>异步抢占</h1><p>当执行完 sighandler，执行流再次回到线程。由于 sighandler 插入了一个 asyncPreempt 的函数调用，所以 goroutine 原本的任务就得不到推进，转而执行 asyncPreempt 去了：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160026.png><img class=mx-auto alt="asyncPreempt 调用链路" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160026.png></a></p><p><code>mcall(fn)</code> 的作用是切到 g0 栈去执行函数 <code>fn</code>, <code>fn</code> 永不返回。在 <code>mcall(gopreempt_m)</code> 这里，fn 就是 gopreempt_m。</p><p><code>gopreempt_m</code> 直接调用 <code>goschedImpl</code>：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160534.png><img class=mx-auto alt=goschedImpl src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160534.png></a></p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160551.png><img class=mx-auto alt=dropg src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160551.png></a></p><p>最精彩的部分就在 goschedImpl 函数。它首先将 goroutine 的状态从 running 改成 runnable；接着调 dropg 将 g 和 m 解绑；然后调用 globrunqput 将 goroutine 丢到全局可运行队列，由于是全局可运行队列，所以需要加锁。最后，调用 <code>schedule()</code> 函数进入调度循环。关于调度循环，可以看这篇<a href=https://mp.weixin.qq.com/s/QFmh0wq50H9-4ZrtEknpCQ>文章</a>。</p><p>运行 <code>schedule</code> 函数用的是 g0 栈，它会去寻找其他可运行的 goroutine，包括从当前 P 本地可运行队列获取、从全局可运行队列获取、从其他 P 偷等方式找到下一个可运行的 goroutine 并执行。</p><p>至此，这个线程就转而去执行其他的 goroutine，当前的 goroutine 也就被抢占了。</p><p>那被抢占的这个 goroutine 什么时候会再次得到执行呢？</p><p>因为它已经被丢到全局可运行队列了，所以它的优先级就会降低，得到调度的机会也就降低，但总还是有机会再次执行的，并且它会从调用 mcall 的下一条指令接着执行。</p><p>还记得 mcall 函数的作用吗？它会切到 g0 栈执行 gopreempt_m，自然它也会保存 goroutine 的执行进度，其实就是 SP、BP、PC 寄存器的值，当 goroutine 再次被调度执行时，就会从原来的执行流断点处继续执行下去。</p><h1 id=总结>总结</h1><p>本文讲述了 Go 语言基于信号的异步抢占的全过程，一起来回顾下：</p><ol><li>M 注册一个 SIGURG 信号的处理函数：sighandler。</li><li>sysmon 线程检测到执行时间过长的 goroutine、GC stw 时，会向相应的 M（或者说线程，每个线程对应一个 M）发送 SIGURG 信号。</li><li>收到信号后，内核执行 sighandler 函数，通过 pushCall 插入 asyncPreempt 函数调用。</li><li>回到当前 goroutine 执行 asyncPreempt 函数，通过 mcall 切到 g0 栈执行 gopreempt_m。</li><li>将当前 goroutine 插入到全局可运行队列，M 则继续寻找其他 goroutine 来运行。</li><li>被抢占的 goroutine 再次调度过来执行时，会继续原来的执行流。</li></ol></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/diving-into-preempt-by-signal/>https://qcrao.com/post/diving-into-preempt-by-signal/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/how-to-be-a-TO/ title="项目 TO 的自我修养">项目 TO 的自我修养</a></li><li><a href=https://qcrao.com/post/how-to-write-a-things3-client/ title="如何写一个 things3 client">如何写一个 things3 client</a></li><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>