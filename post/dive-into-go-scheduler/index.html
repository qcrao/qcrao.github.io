<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 Go 语言之 scheduler | qcrao 的博客</title><meta property="og:title" content="深度解密 Go 语言之 scheduler - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-09-02T17:06:06+08:00"><meta property="article:modified_time" content="2019-09-02T17:06:06+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 Go 语言之 scheduler"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-go-scheduler/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.0/css/all.min.css integrity=sha384-KyZXEAg3QhqLMpG8r+Knujsl5wVI+KzIO2G2Z4h4z2g5zF0VyQDq7V2E6Z8D6pv crossorigin=anonymous><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 Go 语言之 scheduler</h1></header><date class="post-meta meta-date">2019年9月2日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>好久不见，你还好吗？距离上一篇文章已经过去了一个多月了，迟迟未更新文章，我也很着急啊。</p><p>跟大家汇报一下，这段时间我在看 <code>proc.go</code> 的源码，其实就是调度器的源码。代码有几千行之多，不像以往的 map，channel 等等。想把这些代码都看明白，是一个庞大的工程。到今天为止，我也不敢说我都看明白了。</p><p>要深挖下去的话，会无穷无尽，所以阶段性的探索就到这里。接下来就把这段时间的探索分享出来。</p><p>其实，今天这篇文章仅仅算是一个引子，接下来会连续发布十篇系列文章。目录如下：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/64062086-50978e80-cc15-11e9-8689-23b0989b8d7b.png><img class=mx-auto alt=系列文章目录 src=https://user-images.githubusercontent.com/7698088/64062086-50978e80-cc15-11e9-8689-23b0989b8d7b.png></a></p><p>而这个系列的文章主要是受公众号“go 语言核心编程技术”的启发，它有一个 Go 调度器的系列教程，写得非常赞，强烈推荐大家去看，后面会经常引用到它的文章。我忍不住在这贴上公众号的二维码，一定要去关注啊。这是我在找资料的过程中发现的一个宝藏，本来想私藏着，但是好东西还是要分享给大家，不能固步自封。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/64062187-2c887d00-cc16-11e9-8519-00b29f05933c.png><img class=mx-auto alt="Go 语言核心编程技术" src=https://user-images.githubusercontent.com/7698088/64062187-2c887d00-cc16-11e9-8519-00b29f05933c.png></a></p><p>开始我们今天的正题。</p><p>一个月前，《Go 语言高级编程》作者柴树杉老师在 CSDN 上发表了一篇《Go 语言十年而立，Go2 蓄势待发》，视角十分宏大。我们既要低头看路，有时也要抬头看天，这篇文章就属于“抬头”看天类的，推荐阅读。</p><p>文章中提到了第一本写 Go 的小说《胡文 Go》。我找来看了下，嬉笑怒骂，还挺有意思的。书中有这样一句话：</p><blockquote><p>在 Go 语言里，go func 是并发的单元，chan 是协调并发单元的机制，panic 和 recover 是出错处理的机制，而 defer 是神来之笔，大大简化了出错的管理。</p></blockquote><p>Goroutines 在同一个用户空间里同时独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。</p><p>上一篇文章里我们讲了 channel，并且提到，goroutine 和 channel 是 Go 并发编程的两大基石，那这篇文章就聚焦到 goroutine，以及调度 goroutine 的 go scheduler。</p><h1 id=前置知识>前置知识</h1><h2 id=os-scheduler>os scheduler</h2><p>从操作系统角度看，我们写的程序最终都会转换成一系列的机器指令，机器只要按顺序执行完所有的指令就算完成了任务。完成“按顺序执行指令”任务的实体就是线程，也就是说，线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p><p>每个程序启动的时候，都会创建一个初始进程，并且启动一个线程。而线程可以去创建更多的线程，这些线程可以独立地执行，CPU 在这一层进行调度，而非进程。</p><p>OS scheduler 保证如果有可以执行的线程时，就不会让 CPU 闲着。并且它还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p><h2 id=线程切换>线程切换</h2><p>OS scheduler 调度线程的依据就是它的状态，线程有三种状态（简化模型）：<code>Waiting</code>, <code>Runnable</code> or <code>Executing</code>。</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>Waiting</td><td>等待状态。线程在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes</td></tr><tr><td>Runnable</td><td>就绪状态。只要给 CPU 资源我就能运行</td></tr><tr><td>Executing</td><td>运行状态。线程在执行指令，这是我们想要的</td></tr></tbody></table><p>线程能做的事一般分为两种：计算型、IO 型。</p><p>计算型主要是占用 CPU 资源，一直在做计算任务，例如对一个大数做质数分解。这种类型的任务不会让线程跳到 Waiting 状态。</p><p>IO 型则是要获取外界资源，例如通过网络、系统调用等方式。内存同步访问控制原语：mutexes 也可以看作这种类型。共同特点是需要等待外界资源就绪。IO 型的任务会让线程跳到 Waiting 状态。</p><p>线程切换就是操作系统用一个处于 Runnable 的线程将 CPU 上正在运行的处于 Executing 状态的线程换下来的过程。新上场的线程会变成 Executing 状态，而下场的线程则可能变成 Waiting 或 Runnable 状态。正在做计算型任务的线程，会变成 Runnable 状态；正在做 IO 型任务的线程，则会变成 Waiting 状态。</p><p>因此，计算密集型任务和 IO 密集型任务对线程切换的“态度”是不一样的。由于计算型密集型任务一直都有任务要做，或者说它一直有指令要执行，线程切换的过程会让它停掉当前的任务，损失非常大。</p><p>相反，专注于 IO 密集型的任务的线程，如果它因为某个操作而跳到 Waiting 状态，那么把它从 CPU 上换下，对它而言是没有影响的。而且，新换上来的线程可以继续利用 CPU 完成任务。从整个操作系统来看，“工作进度”是往前的。</p><p>记住，对于 OS scheduler 来说，最重要的是不要让一个 CPU 核心闲着，尽量让每个 CPU 核心都有任务可做。</p><blockquote><p>If you have a program that is focused on IO-Bound work, then context switches are going to be an advantage. Once a Thread moves into a Waiting state, another Thread in a Runnable state is there to take its place. This allows the core to always be doing work. This is one of the most important aspects of scheduling. Don’t allow a core to go idle if there is work (Threads in a Runnable state) to be done.</p></blockquote><h2 id=函数调用过程分析>函数调用过程分析</h2><p>要想理解 Go scheduler 的底层原理，对于函数调用过程的理解是必不可少的。它涉及到函数参数的传递，CPU 的指令跳转，函数返回值的传递等等。这需要对汇编语言有一定的了解，因为只有汇编语言才能进行像寄存器赋值这样的底层操作。之前的一些文章里也有说明，这里再来复习一遍。</p><blockquote><p>函数栈帧的空间主要由函数参数和返回值、局部变量和被调用其它函数的参数和返回值空间组成。</p></blockquote><p>宏观看一下，Go 语言中函数调用的规范，引用曹大博客里的一张图：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/64062685-390fd400-cc1c-11e9-86e5-a2646ce3ae1f.png><img class=mx-auto alt="曹大 asmshare 函数调用规范" src=https://user-images.githubusercontent.com/7698088/64062685-390fd400-cc1c-11e9-86e5-a2646ce3ae1f.png></a></p><p>Go plan9 汇编通过栈传递函数参数和返回值。</p><p>调用子函数时，先将参数在栈顶准备好，再执行 CALL 指令。CALL 指令会将 IP 寄存器的值压栈，这个值就是函数调用完成后即将执行的下一条指令。</p><p>然后，就会进入被调用者的栈帧。首先会将 caller BP 压栈，这表示栈基址，也就是栈底。栈顶和栈基址定义函数的栈帧。</p><blockquote><p>CALL 指令类似 PUSH IP 和 JMP somefunc 两个指令的组合，首先将当前的 IP 指令寄存器的值压入栈中，然后通过 JMP 指令将要调用函数的地址写入到 IP 寄存器实现跳转。</p></blockquote><blockquote><p>而 RET 指令则是和 CALL 相反的操作，基本和 POP IP 指令等价，也就是将执行 CALL 指令时保存在 SP 中的返回地址重新载入到 IP 寄存器，实现函数的返回。</p></blockquote><blockquote><p>首先是调用函数前准备的输入参数和返回值空间。然后 CALL 指令将首先触发返回地址入栈操作。在进入到被调用函数内之后，汇编器自动插入了 BP 寄存器相关的指令，因此 BP 寄存器和返回地址是紧挨着的。再下面就是当前函数的局部变量的空间，包含再次调用其它函数需要准备的调用参数空间。被调用的函数执行 RET 返回指令时，先从栈恢复 BP 和 SP 寄存器，接着取出的返回地址跳转到对应的指令执行。</p></blockquote><p>上面两段描述来自《Go 语言高级编程》一书的汇编语言章节，说得很好，再次推荐阅读。</p><h1 id=goroutine-是怎么工作的>goroutine 是怎么工作的</h1><h2 id=什么是-goroutine>什么是 goroutine</h2><p>Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。</p><h2 id=goroutine-和-thread-的区别>goroutine 和 thread 的区别</h2><p>谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？</p><p>参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、切换。</p><ul><li>内存占用</li></ul><p>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</p><p>对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。</p><ul><li>创建和销毀</li></ul><p>Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</p><ul><li>切换</li></ul><p>当 threads 切换时，需要保存各种寄存器，以便将来恢复：</p><blockquote><p>16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.</p></blockquote><p>而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。</p><p>一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。</p><p>Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。</p><p>因此，goroutines 切换成本比 threads 要小得多。</p><h2 id=mn-模型>M:N 模型</h2><p>我们都知道，Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png><img class=mx-auto alt="M:N scheduling" src=https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png></a></p><p>在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞（例如上篇文章提到的向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着，榨干 CPU 的每一滴油水。</p><h1 id=什么是-scheduler>什么是 scheduler</h1><p>Go 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutines 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。</p><p>一个展现了全景式的关系如下图：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62172655-9981cc00-b365-11e9-8912-b16b83930ad0.png><img class=mx-auto alt="runtime overall" src=https://user-images.githubusercontent.com/7698088/62172655-9981cc00-b365-11e9-8912-b16b83930ad0.png></a></p><h1 id=为什么要-scheduler>为什么要 scheduler</h1><p>Go scheduler 可以说是 Go 运行时的一个最重要的部分了。Runtime 维护所有的 goroutines，并通过 scheduler 来进行调度。Goroutines 和 threads 是独立的，但是 goroutines 要依赖 threads 才能执行。</p><p>Go 程序执行的高效和 scheduler 的调度是分不开的。</p><h1 id=scheduler-底层原理>scheduler 底层原理</h1><p>实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutines 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面。</p><p>有三个基础的结构体来实现 goroutines 的调度。g，m，p。</p><p><code>g</code> 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。</p><p><code>m</code> 表示内核线程，包含正在运行的 goroutine 等字段。</p><p><code>p</code> 代表一个虚拟的 Processor，它维护一个处于 Runnable 状态的 g 队列，<code>m</code> 需要获得 <code>p</code> 才能运行 <code>g</code>。</p><p>当然还有一个核心的结构体：<code>sched</code>，它总览全局。</p><p>Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。</p><p>当然，在 Go 的早期版本，并没有 p 这个结构体，<code>m</code> 必须从一个全局的队列里获取要运行的 <code>g</code>，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来在大神 Dmitry Vyokov 的实现里，加上了 <code>p</code> 结构体。每个 <code>p</code> 自己维护一个处于 Runnable 状态的 <code>g</code> 的队列，解决了原来的全局锁问题。</p><p>Go scheduler 的目标：</p><blockquote><p>For scheduling goroutines onto kernel threads.</p></blockquote><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/61874535-3f26dc80-af1b-11e9-9d9c-127edf90fff9.png><img class=mx-auto alt="Go scheduler goals" src=https://user-images.githubusercontent.com/7698088/61874535-3f26dc80-af1b-11e9-9d9c-127edf90fff9.png></a></p><p>Go scheduler 的核心思想是：</p><ol><li>reuse threads；</li><li>限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目；</li><li>线程私有的 runqueues，并且可以从其他线程 stealing goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程。</li></ol><p>为什么需要 P 这个组件，直接把 runqueues 放到 M 不行吗？</p><blockquote><p>You might wonder now, why have contexts at all? Can&rsquo;t we just put the runqueues on the threads and get rid of contexts? Not really. The reason we have contexts is so that we can hand them off to other threads if the running thread needs to block for some reason.</p></blockquote><blockquote><p>An example of when we need to block, is when we call into a syscall. Since a thread cannot both be executing code and be blocked on a syscall, we need to hand off the context so it can keep scheduling.</p></blockquote><p>翻译一下，当一个线程阻塞的时候，将和它绑定的 P 上的 goroutines 转移到其他线程。</p><p>Go scheduler 会启动一个后台线程 sysmon，用来检测长时间（超过 10 ms）运行的 goroutine，将其调度到 global runqueues。这是一个全局的 runqueue，优先级比较低，以示惩罚。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/61874781-d55b0280-af1b-11e9-9965-da4efe53d2db.png><img class=mx-auto alt="Go scheduler limitations" src=https://user-images.githubusercontent.com/7698088/61874781-d55b0280-af1b-11e9-9965-da4efe53d2db.png></a></p><h2 id=总览>总览</h2><p>通常讲到 Go scheduler 都会提到 GPM 模型，我们来一个个地看。</p><p>下图是我使用的 mac 的硬件信息，只有 2 个核。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62016049-63680f00-b1e2-11e9-9b6f-8566fd5e3963.png><img class=mx-auto alt="mac 硬件信息" src=https://user-images.githubusercontent.com/7698088/62016049-63680f00-b1e2-11e9-9b6f-8566fd5e3963.png></a></p><p>但是配上 CPU 的超线程，1 个核可以变成 2 个，所以当我在 mac 上运行下面的程序时，会打印出 4。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// NumCPU 返回当前进程可以用到的逻辑核心数
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	fmt.<span style=color:#900;font-weight:700>Println</span>(runtime.<span style=color:#900;font-weight:700>NumCPU</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 NumCPU 返回的是逻辑核心数，而非物理核心数，所以最终结果是 4。</p><p>Go 程序启动后，会给每个逻辑核心分配一个 P（Logical Processor）；同时，会给每个 P 分配一个 M（Machine，表示内核线程），这些内核线程仍然由 OS scheduler 来调度。</p><p>总结一下，当我在本地启动一个 Go 程序时，会得到 4 个系统线程去执行任务，每个线程会搭配一个 P。</p><p>在初始化时，Go 程序会有一个 G（initial Goroutine），执行指令的单位。G 会在 M 上得到执行，内核线程是在 CPU 核心上调度，而 G 则是在 M 上进行调度。</p><p>G、P、M 都说完了，还有两个比较重要的组件没有提到： 全局可运行队列（GRQ）和本地可运行队列（LRQ）。 LRQ 存储本地（也就是具体的 P）的可运行 goroutine，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62016513-336e3b00-b1e5-11e9-8923-d5d1743a531b.png><img class=mx-auto alt="GPM global review" src=https://user-images.githubusercontent.com/7698088/62016513-336e3b00-b1e5-11e9-8923-d5d1743a531b.png></a></p><p>Go scheduler 是 Go runtime 的一部分，它内嵌在 Go 程序里，和 Go 程序一起运行。因此它运行在用户空间，在 kernel 的上一层。和 Os scheduler 抢占式调度（preemptive）不一样，Go scheduler 采用协作式调度（cooperating）。</p><blockquote><p>Being a cooperating scheduler means the scheduler needs well-defined user space events that happen at safe points in the code to make scheduling decisions.</p></blockquote><p>协作式调度一般会由用户设置调度点，例如 python 中的 yield 会告诉 Os scheduler 可以将我调度出去了。</p><p>但是由于在 Go 语言里，goroutine 调度的事情是由 Go runtime 来做，并非由用户控制，所以我们依然可以将 Go scheduler 看成是抢占式调度，因为用户无法预测调度器下一步的动作是什么。</p><p>和线程类似，goroutine 的状态也是三种（简化版的）：</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>Waiting</td><td>等待状态，goroutine 在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes</td></tr><tr><td>Runnable</td><td>就绪状态，只要给 M 我就可以运行</td></tr><tr><td>Executing</td><td>运行状态。goroutine 在 M 上执行指令，这是我们想要的</td></tr></tbody></table><p>下面这张 GPM 全局的运行示意图见得比较多，可以留着，看完后面的系列文章之后再回头来看，还是很有感触的：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62260181-a7a61a00-b443-11e9-849b-b597addeca57.png><img class=mx-auto alt="goroutine workflow" src=https://user-images.githubusercontent.com/7698088/62260181-a7a61a00-b443-11e9-849b-b597addeca57.png></a></p><h2 id=goroutine-调度时机>goroutine 调度时机</h2><p>在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。</p><table><thead><tr><th>情形</th><th>说明</th></tr></thead><tbody><tr><td>使用关键字 <code>go</code></td><td>go 创建一个新的 goroutine，Go scheduler 会考虑调度</td></tr><tr><td>GC</td><td>由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</td></tr><tr><td>系统调用</td><td>当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</td></tr><tr><td>内存同步访问</td><td>atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</td></tr></tbody></table><h2 id=work-stealing>work stealing</h2><p>Go scheduler 的职责就是将所有处于 runnable 的 goroutines 均匀分布到在 P 上运行的 M。</p><p>当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。看看这是什么精神！自己的工作做完了，为了全局的利益，主动为别人分担。这被称为 <code>Work-stealing</code>，Go 从 1.1 开始实现。</p><p>Go scheduler 使用 M:N 模型，在任一时刻，M 个 goroutines（G） 要分配到 N 个内核线程（M），这些 M 跑在个数最多为 GOMAXPROCS 的逻辑处理器（P）上。每个 M 必须依附于一个 P，每个 P 在同一时刻只能运行一个 M。如果 P 上的 M 阻塞了，那它就需要其他的 M 来运行 P 的 LRQ 里的 goroutines。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62031928-02a8f880-b21b-11e9-96a9-96820452463e.png><img class=mx-auto alt="GPM relatioship" src=https://user-images.githubusercontent.com/7698088/62031928-02a8f880-b21b-11e9-96a9-96820452463e.png></a></p><p>个人感觉，上面这张图比常见的那些用三角形表示 M，圆形表示 G，矩形表示 P 的那些图更生动形象。</p><p>实际上，Go scheduler 每一轮调度要做的工作就是找到处于 runnable 的 goroutines，并执行它。找的顺序如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>runtime.<span style=color:#900;font-weight:700>schedule</span>() {
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic>// only 1/61 of the time, check the global runnable queue for a G.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// if not found, check the local queue.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>// if not found,
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>//     try to steal from other Ps.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>//     if not, check the global runnable queue.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>    <span style=color:#998;font-style:italic>//     if not found, poll network.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>找到一个可执行的 goroutine 后，就会一直执行下去，直到被阻塞。</p><p>当 P2 上的一个 G 执行结束，它就会去 LRQ 获取下一个 G 来执行。如果 LRQ 已经空了，就是说本地可运行队列已经没有 G 需要执行，并且这时 GRQ 也没有 G 了。这时，P2 会随机选择一个 P（称为 P1），P2 会从 P1 的 LRQ “偷”过来一半的 G。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62033338-4ea96c80-b21e-11e9-9167-98767c03d2d9.png><img class=mx-auto alt="Work Stealing" src=https://user-images.githubusercontent.com/7698088/62033338-4ea96c80-b21e-11e9-9167-98767c03d2d9.png></a></p><p>这样做的好处是，有更多的 P 可以一起工作，加速执行完所有的 G。</p><h2 id=同步异步系统调用>同步/异步系统调用</h2><p>当 G 需要进行系统调用时，根据调用的类型，它所依附的 M 有两种情况：<code>同步</code>和<code>异步</code>。</p><p>对于同步的情况，M 会被阻塞，进而从 P 上调度下来，P 可不养闲人，G 仍然依附于 M。之后，一个新的 M 会被调用到 P 上，接着执行 P 的 LRQ 里嗷嗷待哺的 G 们。一旦系统调用完成，G 还会加入到 P 的 LRQ 里，M 则会被“雪藏”，待到需要时再“放”出来。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62091677-b904f000-b2a4-11e9-8972-60ace0807ba4.png><img class=mx-auto alt=同步系统调用 src=https://user-images.githubusercontent.com/7698088/62091677-b904f000-b2a4-11e9-8972-60ace0807ba4.png></a></p><p>对于异步的情况，M 不会被阻塞，G 的异步请求会被“代理人” network poller 接手，G 也会被绑定到 network poller，等到系统调用结束，G 才会重新回到 P 上。M 由于没被阻塞，它因此可以继续执行 LRQ 里的其他 G。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62091486-c2da2380-b2a3-11e9-8cf9-0e63d7f774d8.png><img class=mx-auto alt=异步系统调用 src=https://user-images.githubusercontent.com/7698088/62091486-c2da2380-b2a3-11e9-8cf9-0e63d7f774d8.png></a></p><p>可以看到，异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</p><blockquote><p>The ability to turn IO/Blocking work into CPU-bound work at the OS level is where we get a big win in leveraging more CPU capacity over time.</p></blockquote><p>Go scheduler 像一个非常苛刻的监工一样，不会让一个 M 闲着，总是会通过各种办法让你干更多的事。</p><blockquote><p>In Go, it’s possible to get more work done, over time, because the Go scheduler attempts to use less Threads and do more on each Thread, which helps to reduce load on the OS and the hardware.</p></blockquote><h2 id=scheduler-的陷阱>scheduler 的陷阱</h2><p>由于 Go 语言是协作式的调度，不会像线程那样，在时间片用完后，由 CPU 中断任务强行将其调度走。对于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的“抢占标志位”，之后调度器会处理。但是设置标志位的时机只有在函数“序言”部分，对于没有函数调用的就没有办法了。</p><blockquote><p>Golang implements a co-operative partially preemptive scheduler.</p></blockquote><p>所以在某些极端情况下，会掉进一些陷阱。下面这个例子来自参考资料【scheduler 的陷阱】。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> x <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>	threads <span style=color:#000;font-weight:700>:=</span> runtime.<span style=color:#900;font-weight:700>GOMAXPROCS</span>(<span style=color:#099>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; threads; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>for</span> { x<span style=color:#000;font-weight:700>++</span> }
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	time.<span style=color:#900;font-weight:700>Sleep</span>(time.Second)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;x =&#34;</span>, x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果是：在死循环里出不来，不会输出最后的那条打印语句。</p><p>为什么？上面的例子会启动和机器的 CPU 核心数相等的 goroutine，每个 goroutine 都会执行一个无限循环。</p><p>创建完这些 goroutines 后，main 函数里执行一条 <code>time.Sleep(time.Second)</code> 语句。Go scheduler 看到这条语句后，简直高兴坏了，要来活了。这是调度的好时机啊，于是主 goroutine 被调度走。先前创建的 <code>threads</code> 个 goroutines，刚好“一个萝卜一个坑”，把 M 和 P 都占满了。</p><p>在这些 goroutine 内部，又没有调用一些诸如 <code>channel</code>，<code>time.sleep</code> 这些会引发调度器工作的事情。麻烦了，只能任由这些无限循环执行下去了。</p><p>解决的办法也有，把 threads 减小 1：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> x <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>	threads <span style=color:#000;font-weight:700>:=</span> runtime.<span style=color:#900;font-weight:700>GOMAXPROCS</span>(<span style=color:#099>0</span>) <span style=color:#000;font-weight:700>-</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>; i &lt; threads; i<span style=color:#000;font-weight:700>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>for</span> { x<span style=color:#000;font-weight:700>++</span> }
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	time.<span style=color:#900;font-weight:700>Sleep</span>(time.Second)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;x =&#34;</span>, x)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:teal>x</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#099>0</span>
</span></span></code></pre></div><p>不难理解了吧，主 goroutine 休眠一秒后，被 go schduler 重新唤醒，调度到 M 上继续执行，打印一行语句后，退出。主 goroutine 退出后，其他所有的 goroutine 都必须跟着退出。所谓“覆巢之下 焉有完卵”，一损俱损。</p><p>至于为什么最后打印出的 x 为 0，之前的文章<a href=https://qcrao.com/2019/06/17/cch-says-memory-reorder/>《曹大谈内存重排》</a>里有讲到过，这里不再深究了。</p><p>还有一种解决办法是在 for 循环里加一句：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {
</span></span><span style=display:flex><span>	time.<span style=color:#900;font-weight:700>Sleep</span>(time.Second)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> { x<span style=color:#000;font-weight:700>++</span> }
</span></span><span style=display:flex><span>}()
</span></span></code></pre></div><p>同样可以让 main goroutine 有机会调度执行。</p><h1 id=总结>总结</h1><p>这篇文章，从宏观角度来看 Go 调度器，讲到了很多方面。接下来连续的 10 篇文章，我会深入源码，层层解析。敬请期待！</p><p>参考资料里有很多篇英文博客写得很好，当你掌握了基本原理后，看这些文章会有一种熟悉的感觉，讲得真好！</p><h1 id=参考资料>参考资料</h1><p>【知乎回答，怎样理解阻塞非阻塞与同步异步的区别】 <a href=https://www.zhihu.com/question/19732473/answer/241673170>https://www.zhihu.com/question/19732473/answer/241673170</a></p><p>【从零开始学架构 Reactor与Proactor】 <a href=https://book.douban.com/subject/30335935/>https://book.douban.com/subject/30335935/</a></p><p>【思否上 goalng 排名第二的大佬译文】 <a href=https://segmentfault.com/a/1190000016038785>https://segmentfault.com/a/1190000016038785</a></p><p>【ardan labs】 <a href=https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html>https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html</a></p><p>【论文 Analysis of the Go runtime scheduler】 <a href=http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf>http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</a></p><p>【译文传播很广的】 <a href=https://morsmachine.dk/go-scheduler>https://morsmachine.dk/go-scheduler</a></p><p>【码农翻身文章】 <a href=https://mp.weixin.qq.com/s/BV25ngvWgbO3_yMK7eHhew>https://mp.weixin.qq.com/s/BV25ngvWgbO3_yMK7eHhew</a></p><p>【goroutine 资料合集】 <a href=https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/goroutines>https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/goroutines</a></p><p>【大彬调度器系列文章】 <a href=http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/>http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/</a></p><p>【Scalable scheduler design doc 2012】 <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.rvfa6uqbq68u">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.rvfa6uqbq68u</a></p><p>【Go scheduler blog post】 <a href=https://morsmachine.dk/go-scheduler>https://morsmachine.dk/go-scheduler</a></p><p>【work stealing】 <a href=https://rakyll.org/scheduler/>https://rakyll.org/scheduler/</a></p><p>【Tony Bai 也谈goroutine调度器】 <a href=https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/>https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></p><p>【Tony Bai 调试实例分析】 <a href=https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/>https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/</a></p><p>【Tony Bai goroutine 是如何工作的】 <a href=https://tonybai.com/2014/11/15/how-goroutines-work/>https://tonybai.com/2014/11/15/how-goroutines-work/</a></p><p>【How Goroutines Work】 <a href=https://blog.nindalf.com/posts/how-goroutines-work/>https://blog.nindalf.com/posts/how-goroutines-work/</a></p><p>【知乎回答 什么是阻塞，非阻塞，同步，异步？】 <a href=https://www.zhihu.com/question/26393784/answer/328707302>https://www.zhihu.com/question/26393784/answer/328707302</a></p><p>【知乎文章 完全理解同步/异步与阻塞/非阻塞】 <a href=https://zhuanlan.zhihu.com/p/22707398>https://zhuanlan.zhihu.com/p/22707398</a></p><p>【The Go netpoller】 <a href=https://morsmachine.dk/netpoller>https://morsmachine.dk/netpoller</a></p><p>【知乎专栏 Head First of Golang Scheduler】 <a href=https://zhuanlan.zhihu.com/p/42057783>https://zhuanlan.zhihu.com/p/42057783</a></p><p>【鸟窝 五种 IO 模型】 <a href=https://colobu.com/2019/07/26/IO-models/>https://colobu.com/2019/07/26/IO-models/</a></p><p>【Go Runtime Scheduler】 <a href="https://speakerdeck.com/retervision/go-runtime-scheduler?slide=32">https://speakerdeck.com/retervision/go-runtime-scheduler?slide=32</a></p><p>【go-scheduler】 <a href=https://povilasv.me/go-scheduler/#>https://povilasv.me/go-scheduler/#</a></p><p>【追踪 scheduler】 <a href=https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html>https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html</a></p><p>【go tool trace 使用】 <a href=https://making.pusher.com/go-tool-trace/>https://making.pusher.com/go-tool-trace/</a></p><p>【goroutine 之旅】 <a href=https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c>https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c</a></p><p>【介绍 concurreny 和 parallelism 区别的视频】 <a href="https://www.youtube.com/watch?v=cN_DpYBzKso&amp;t=422s">https://www.youtube.com/watch?v=cN_DpYBzKso&amp;t=422s</a></p><p>【scheduler 的陷阱】 <a href=http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler>http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler</a></p><p>【boya 源码阅读】 <a href=https://github.com/zboya/golang_runtime_reading/blob/master/src/runtime/proc.go>https://github.com/zboya/golang_runtime_reading/blob/master/src/runtime/proc.go</a></p><p>【阿波张调度器系列教程】 <a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect">http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect</a></p><p>【曹大 asmshare】 <a href=https://github.com/cch123/asmshare/blob/master/layout.md>https://github.com/cch123/asmshare/blob/master/layout.md</a></p><p>【Go调度器介绍和容易忽视的问题】 <a href=https://www.cnblogs.com/CodeWithTxT/p/11370215.html>https://www.cnblogs.com/CodeWithTxT/p/11370215.html</a></p><p>【最近发现的一位大佬的源码分析】 <a href=https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/TOC.md>https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/TOC.md</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-go-scheduler/>https://qcrao.com/post/dive-into-go-scheduler/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2023 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/how-to-be-a-TO/ title="项目 TO 的自我修养">项目 TO 的自我修养</a></li><li><a href=https://qcrao.com/post/how-to-write-a-things3-client/ title="如何写一个 things3 client">如何写一个 things3 client</a></li><li><a href=https://qcrao.com/post/some-convenient-settings-of-mac/ title="几个小设置让 mac 更好用">几个小设置让 mac 更好用</a></li><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>