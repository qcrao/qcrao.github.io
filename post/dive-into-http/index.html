<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 HTTP 通信细节 | qcrao 的博客</title><meta property="og:title" content="深度解密 HTTP 通信细节 - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-01-18T10:13:00+08:00"><meta property="article:modified_time" content="2019-01-18T10:13:00+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 HTTP 通信细节"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-http/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 HTTP 通信细节</h1></header><date class="post-meta meta-date">2019年1月18日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>上一篇<a href=https://www.cnblogs.com/qcrao-2018/p/10182185.html>文章</a>中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的<code>锤子</code>，拿着<code>锤子</code>，看什么都像<code>钉子</code>！在这篇文章中，我对准了<code>HTTP</code>这颗钉子砸下去，咳咳。</p><p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p><p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p><h1 id=http报文截获>HTTP报文截获</h1><h2 id=背景介绍>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是<code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度>表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p><p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p><p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>http:</span><span style=color:#998;font-style:italic>//docker_ip:7080/data?cmd=Fence2Area&amp;meta={&#34;caller&#34;:&#34;test&#34;,&#34;TraceId&#34;:&#34;test&#34;}&amp;request={&#34;fence&#34;:[{&#34;lng&#34;:10.2,&#34;lat&#34;:10.2}, {&#34;lng&#34;:10.2,&#34;lat&#34;:8.2}, {&#34;lng&#34;:8.2,&#34;lat&#34;:8.2}, {&#34;lng&#34;:8.2,&#34;lat&#34;:10.2}],&#34;coordtype&#34;:2}
</span></span></span></code></pre></div><p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;data&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;area&#34;</span>: <span style=color:#099>48764135597.842606</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;errstr&#34;</span>: <span style=color:#d14>&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>area</code>字段表示面积，<code>errstr</code>表示出错信息，空说明没有出错。</p><h2 id=抓包>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p><h3 id=mac本地>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ip.addr eq docker_ip
</span></span></code></pre></div><p>点击开始捕获。</p><h3 id=远程docker>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpdump -w /tmp/testHttp.cap port <span style=color:#099>7080</span> -s0
</span></span></code></pre></div><h2 id=请求--分析>请求 && 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>http:</span><span style=color:#998;font-style:italic>//docker_ip:7080/data?cmd=Fence2Area&amp;meta={&#34;caller&#34;:&#34;test&#34;,&#34;TraceId&#34;:&#34;test&#34;}&amp;request={&#34;fence&#34;:[{&#34;lng&#34;:10.2,&#34;lat&#34;:10.2}, {&#34;lng&#34;:10.2,&#34;lat&#34;:8.2}, {&#34;lng&#34;:8.2,&#34;lat&#34;:8.2}, {&#34;lng&#34;:8.2,&#34;lat&#34;:10.2}],&#34;coordtype&#34;:2}
</span></span></span></code></pre></div><p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p><h3 id=关闭服务进程>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p><p>首先，关闭gcs服务进程，请求直接返回RST报文。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51288531-97929400-1a37-11e9-8425-c6a2ca6405ad.png><img class=mx-auto alt=rst src=https://user-images.githubusercontent.com/7698088/51288531-97929400-1a37-11e9-8425-c6a2ca6405ad.png></a></p><p>如上图，我在请求的时候，访问服务端的另一个端口<code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p><h3 id=关闭docker>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/50555866-08823e00-0d0d-11e9-97cd-f1cdcca2f641.png><img class=mx-auto alt="mac retry" src=https://user-images.githubusercontent.com/7698088/50555866-08823e00-0d0d-11e9-97cd-f1cdcca2f641.png></a></p><p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p><h3 id=重启docker>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p><h3 id=正常请求>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/50638281-2e6f4300-0f98-11e9-8d8b-0f3c0cc7eb85.png><img class=mx-auto alt=normal_req_wireshark src=https://user-images.githubusercontent.com/7698088/50638281-2e6f4300-0f98-11e9-8d8b-0f3c0cc7eb85.png></a></p><p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为<code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在<code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p><p>重点来关注后面几个包，先看第四个包，</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>0x0000:  <span style=color:#099>4500</span> <span style=color:#099>0295</span> <span style=color:#099>0000</span> <span style=color:#099>4000</span> <span style=color:#099>3606</span> 623b ac17 ccdc
</span></span><span style=display:flex><span>0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d
</span></span><span style=display:flex><span>0x0020:  <span style=color:#099>8018</span> <span style=color:#099>1015</span> 0ee7 <span style=color:#099>0000</span> <span style=color:#099>0101</span> 080a 2e4c b2ef
</span></span><span style=display:flex><span>0x0030:  0f20 3acf <span style=color:#099>4745</span> <span style=color:#099>5420</span> 2f64 <span style=color:#099>6174</span> 613f 636d
</span></span><span style=display:flex><span>0x0040:  643d <span style=color:#099>4665</span> 6e63 <span style=color:#099>6532</span> <span style=color:#099>4172</span> <span style=color:#099>6561</span> 266d <span style=color:#099>6574</span>
</span></span><span style=display:flex><span>0x0050:  613d 7b25 <span style=color:#099>3232</span> <span style=color:#099>6361</span> 6c6c <span style=color:#099>6572</span> <span style=color:#099>2532</span> 323a
</span></span><span style=display:flex><span>0x0060:  <span style=color:#099>2532</span> <span style=color:#099>3274</span> <span style=color:#099>6573</span> <span style=color:#099>7425</span> <span style=color:#099>3232</span> 2c25 <span style=color:#099>3232</span> <span style=color:#099>5472</span>
</span></span><span style=display:flex><span>0x0070:  <span style=color:#099>6163</span> <span style=color:#099>6549</span> <span style=color:#099>6425</span> <span style=color:#099>3232</span> 3a25 <span style=color:#099>3232</span> <span style=color:#099>7465</span> <span style=color:#099>7374</span>
</span></span><span style=display:flex><span>0x0080:  <span style=color:#099>2532</span> 327d <span style=color:#099>2672</span> <span style=color:#099>6571</span> <span style=color:#099>7565</span> <span style=color:#099>7374</span> 3d7b <span style=color:#099>2532</span>
</span></span><span style=display:flex><span>0x0090:  <span style=color:#099>3266</span> 656e <span style=color:#099>6365</span> <span style=color:#099>2532</span> 323a 5b7b <span style=color:#099>2532</span> 326c
</span></span><span style=display:flex><span>0x00a0:  6e67 <span style=color:#099>2532</span> 323a <span style=color:#099>3130</span> 2e32 2c25 <span style=color:#099>3232</span> 6c61
</span></span><span style=display:flex><span>0x00b0:  <span style=color:#099>7425</span> <span style=color:#099>3232</span> 3a31 302e 327d 2c25 <span style=color:#099>3230</span> 7b25
</span></span><span style=display:flex><span>0x00c0:  <span style=color:#099>3232</span> 6c6e <span style=color:#099>6725</span> <span style=color:#099>3232</span> 3a31 302e 322c <span style=color:#099>2532</span>
</span></span><span style=display:flex><span>0x00d0:  326c <span style=color:#099>6174</span> <span style=color:#099>2532</span> 323a 382e 327d 2c25 <span style=color:#099>3230</span>
</span></span><span style=display:flex><span>0x00e0:  7b25 <span style=color:#099>3232</span> 6c6e <span style=color:#099>6725</span> <span style=color:#099>3232</span> 3a38 2e32 2c25
</span></span><span style=display:flex><span>0x00f0:  <span style=color:#099>3232</span> 6c61 <span style=color:#099>7425</span> <span style=color:#099>3232</span> 3a38 2e32 7d2c <span style=color:#099>2532</span>
</span></span><span style=display:flex><span>0x0100:  307b <span style=color:#099>2532</span> 326c 6e67 <span style=color:#099>2532</span> 323a 382e 322c
</span></span><span style=display:flex><span>0x0110:  <span style=color:#099>2532</span> 326c <span style=color:#099>6174</span> <span style=color:#099>2532</span> 323a <span style=color:#099>3130</span> 2e32 7d5d
</span></span><span style=display:flex><span>0x0120:  2c25 <span style=color:#099>3232</span> 636f 6f72 <span style=color:#099>6474</span> <span style=color:#099>7970</span> <span style=color:#099>6525</span> <span style=color:#099>3232</span>
</span></span><span style=display:flex><span>0x0130:  3a32 7d20 <span style=color:#099>4854</span> <span style=color:#099>5450</span> 2f31 2e31 0d0a 486f
</span></span><span style=display:flex><span>0x0140:  <span style=color:#099>7374</span> 3a20 <span style=color:#099>3130</span> 2e39 362e <span style=color:#099>3932</span> 2e32 <span style=color:#099>3132</span>
</span></span><span style=display:flex><span>0x0150:  3a37 <span style=color:#099>3038</span> 300d 0a55 <span style=color:#099>7067</span> <span style=color:#099>7261</span> <span style=color:#099>6465</span> 2d49
</span></span><span style=display:flex><span>0x0160:  6e73 <span style=color:#099>6563</span> <span style=color:#099>7572</span> 652d <span style=color:#099>5265</span> <span style=color:#099>7175</span> <span style=color:#099>6573</span> <span style=color:#099>7473</span>
</span></span><span style=display:flex><span>0x0170:  3a20 310d 0a41 <span style=color:#099>6363</span> <span style=color:#099>6570</span> 743a <span style=color:#099>2074</span> <span style=color:#099>6578</span>
</span></span><span style=display:flex><span>0x0180:  742f <span style=color:#099>6874</span> 6d6c 2c61 <span style=color:#099>7070</span> 6c69 <span style=color:#099>6361</span> <span style=color:#099>7469</span>
</span></span><span style=display:flex><span>0x0190:  6f6e 2f78 <span style=color:#099>6874</span> 6d6c 2b78 6d6c 2c61 <span style=color:#099>7070</span>
</span></span><span style=display:flex><span>0x01a0:  6c69 <span style=color:#099>6361</span> <span style=color:#099>7469</span> 6f6e 2f78 6d6c 3b71 3d30
</span></span><span style=display:flex><span>0x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a <span style=color:#099>5573</span>
</span></span><span style=display:flex><span>0x01c0:  <span style=color:#099>6572</span> 2d41 <span style=color:#099>6765</span> 6e74 3a20 4d6f 7a69 6c6c
</span></span><span style=display:flex><span>0x01d0:  612f 352e <span style=color:#099>3020</span> 284d <span style=color:#099>6163</span> 696e 746f <span style=color:#099>7368</span>
</span></span><span style=display:flex><span>0x01e0:  3b20 496e <span style=color:#099>7465</span> 6c20 4d61 <span style=color:#099>6320</span> 4f53 <span style=color:#099>2058</span>
</span></span><span style=display:flex><span>0x01f0:  <span style=color:#099>2031</span> 305f <span style=color:#099>3133</span> 5f36 <span style=color:#099>2920</span> <span style=color:#099>4170</span> 706c <span style=color:#099>6557</span>
</span></span><span style=display:flex><span>0x0200:  <span style=color:#099>6562</span> 4b69 742f <span style=color:#099>3630</span> 352e 312e <span style=color:#099>3135</span> <span style=color:#099>2028</span>
</span></span><span style=display:flex><span>0x0210:  4b48 544d 4c2c 206c 696b <span style=color:#099>6520</span> <span style=color:#099>4765</span> 636b
</span></span><span style=display:flex><span>0x0220:  6f29 <span style=color:#099>2056</span> <span style=color:#099>6572</span> <span style=color:#099>7369</span> 6f6e 2f31 322e 302e
</span></span><span style=display:flex><span>0x0230:  <span style=color:#099>3220</span> <span style=color:#099>5361</span> <span style=color:#099>6661</span> <span style=color:#099>7269</span> 2f36 <span style=color:#099>3035</span> 2e31 2e31
</span></span><span style=display:flex><span>0x0240:  350d 0a41 <span style=color:#099>6363</span> <span style=color:#099>6570</span> 742d 4c61 6e67 <span style=color:#099>7561</span>
</span></span><span style=display:flex><span>0x0250:  <span style=color:#099>6765</span> 3a20 7a68 2d63 6e0d 0a41 <span style=color:#099>6363</span> <span style=color:#099>6570</span>
</span></span><span style=display:flex><span>0x0260:  742d 456e 636f <span style=color:#099>6469</span> 6e67 3a20 677a <span style=color:#099>6970</span>
</span></span><span style=display:flex><span>0x0270:  2c20 <span style=color:#099>6465</span> 666c <span style=color:#099>6174</span> 650d 0a43 6f6e 6e65
</span></span><span style=display:flex><span>0x0280:  <span style=color:#099>6374</span> 696f 6e3a 206b <span style=color:#099>6565</span> 702d 616c <span style=color:#099>6976</span>
</span></span><span style=display:flex><span>0x0290:  650d 0a0d 0a
</span></span></code></pre></div><p>我们来逐字节分析。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0295</td><td>总长度为661字节，即整个包的长度是661字节</td></tr><tr><td>0x0000</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x623b</td><td>16bitIP首部校验和。</td></tr><tr><td>0xac17 ccdc</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0xdb9b</td><td style=text-align:left>16bit源端口。56219</td></tr><tr><td style=text-align:left>0x1ba8</td><td style=text-align:left>16bit目的端口7080</td></tr><tr><td style=text-align:left>0xa59a 46ce</td><td style=text-align:left>32bit序列号。2778351310</td></tr><tr><td style=text-align:left>0x6d03 e87d</td><td style=text-align:left>32bit确认号。1828972669</td></tr><tr><td style=text-align:left>0x8</td><td style=text-align:left>4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td style=text-align:left>0b000000</td><td style=text-align:left>6bit保留位。目前置为0.</td></tr><tr><td style=text-align:left>0b011000</td><td style=text-align:left>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效</td></tr><tr><td style=text-align:left>0x1015</td><td style=text-align:left>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117</td></tr><tr><td style=text-align:left>0x0ee7</td><td style=text-align:left>16bit校验和。</td></tr><tr><td style=text-align:left>0x0000</td><td style=text-align:left>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x0402</td><td style=text-align:left>表示支持SACK</td></tr><tr><td style=text-align:left>0x080a 2e4c b2ef 0f20 3acf</td><td style=text-align:left>时间戳。Ts val=0x2e4c b2ef=776778479, ecr=0x0f20 3acf=253770447</td></tr></tbody></table><p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>man ascii
</span></span></code></pre></div><p>可以得到ascii码，我们直接看十六进制的结果：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51357121-5f06bf00-1af8-11e9-9171-fa1e7a8b0228.png><img class=mx-auto alt=ascii src=https://user-images.githubusercontent.com/7698088/51357121-5f06bf00-1af8-11e9-9171-fa1e7a8b0228.png></a></p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62196186-22255a00-b3b0-11e9-978a-fbda020ad9a6.png><img class=mx-auto alt="HTTP 数据" src=https://user-images.githubusercontent.com/7698088/62196186-22255a00-b3b0-11e9-978a-fbda020ad9a6.png></a></p><p>把上表的最后一列连起来，就是：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/62195131-ec7f7180-b3ad-11e9-9b2d-22d466c322d0.png><img class=mx-auto alt="HTTP 数据" src=https://user-images.githubusercontent.com/7698088/62195131-ec7f7180-b3ad-11e9-9b2d-22d466c322d0.png></a></p><p>其中，cr nl表示回车，换行。</p><p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p><p>再来看第5个包，字节流如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>0x0000:  <span style=color:#099>4500</span> <span style=color:#099>0034</span> d28b <span style=color:#099>4000</span> <span style=color:#099>4006</span> <span style=color:#099>8810</span> 0a60 5cd4
</span></span><span style=display:flex><span>0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
</span></span><span style=display:flex><span>0x0020:  <span style=color:#099>8010</span> 00ec e04e <span style=color:#099>0000</span> <span style=color:#099>0101</span> 080a 0f20 3af7
</span></span><span style=display:flex><span>0x0030:  2e4c b2ef
</span></span></code></pre></div><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0034</td><td>总长度为52字节，即整个包的长度是52字节</td></tr><tr><td>0xd28b</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x40</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x8810</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit源ip地址。</td></tr><tr><td>0xac17 ccdc</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x1ba8</td><td style=text-align:left>16bit源端口7080</td></tr><tr><td style=text-align:left>0xdb9b</td><td style=text-align:left>16bit目的端口。56219</td></tr><tr><td style=text-align:left>0x6d03 e87d</td><td style=text-align:left>32bit序列号。1828972669</td></tr><tr><td style=text-align:left>0xa59a 492f</td><td style=text-align:left>32bit确认号。2778351919. 第三个包的序列号为2778351310, 加上数据长度609, 正好相等。</td></tr><tr><td style=text-align:left>0x8</td><td style=text-align:left>4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td style=text-align:left>0b000000</td><td style=text-align:left>6bit保留位。目前置为0.</td></tr><tr><td style=text-align:left>0b010000</td><td style=text-align:left>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效</td></tr><tr><td style=text-align:left>0x00ec</td><td style=text-align:left>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117</td></tr><tr><td style=text-align:left>0xe04e</td><td style=text-align:left>16bit校验和。</td></tr><tr><td style=text-align:left>0x0000</td><td style=text-align:left>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x0402</td><td style=text-align:left>表示支持SACK</td></tr><tr><td style=text-align:left>0x080a 2e4c b2ef 0f20 3acf</td><td style=text-align:left>时间戳。Ts val=253770487, ecr=776778479</td></tr></tbody></table><p>数据部分为空，这个包仅为确认包。</p><p>再来看第六个包，字节流如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>0x0000:  <span style=color:#099>4500</span> 00f9 d28c <span style=color:#099>4000</span> <span style=color:#099>4006</span> 874a 0a60 5cd4
</span></span><span style=display:flex><span>0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
</span></span><span style=display:flex><span>0x0020:  <span style=color:#099>8018</span> 00ec e113 <span style=color:#099>0000</span> <span style=color:#099>0101</span> 080a 0f20 3af8
</span></span><span style=display:flex><span>0x0030:  2e4c b2ef <span style=color:#099>4854</span> <span style=color:#099>5450</span> 2f31 2e31 <span style=color:#099>2032</span> <span style=color:#099>3030</span>
</span></span><span style=display:flex><span>0x0040:  204f 4b0d 0a41 <span style=color:#099>6363</span> <span style=color:#099>6573</span> 732d 436f 6e74
</span></span><span style=display:flex><span>0x0050:  726f 6c2d 416c 6c6f 772d 4f72 <span style=color:#099>6967</span> 696e
</span></span><span style=display:flex><span>0x0060:  3a20 2a0d 0a44 <span style=color:#099>6174</span> 653a <span style=color:#099>2054</span> <span style=color:#099>6875</span> 2c20
</span></span><span style=display:flex><span>0x0070:  <span style=color:#099>3033</span> 204a 616e <span style=color:#099>2032</span> <span style=color:#099>3031</span> <span style=color:#099>3920</span> <span style=color:#099>3132</span> 3a32
</span></span><span style=display:flex><span>0x0080:  333a <span style=color:#099>3437</span> <span style=color:#099>2047</span> 4d54 0d0a 436f 6e74 656e
</span></span><span style=display:flex><span>0x0090:  742d 4c65 6e67 <span style=color:#099>7468</span> 3a20 <span style=color:#099>3438</span> 0d0a 436f
</span></span><span style=display:flex><span>0x00a0:  6e74 656e 742d <span style=color:#099>5479</span> <span style=color:#099>7065</span> 3a20 <span style=color:#099>7465</span> <span style=color:#099>7874</span>
</span></span><span style=display:flex><span>0x00b0:  2f70 6c61 696e 3b20 <span style=color:#099>6368</span> <span style=color:#099>6172</span> <span style=color:#099>7365</span> 743d
</span></span><span style=display:flex><span>0x00c0:  <span style=color:#099>7574</span> 662d 380d 0a0d 0a7b <span style=color:#099>2264</span> <span style=color:#099>6174</span> <span style=color:#099>6122</span>
</span></span><span style=display:flex><span>0x00d0:  3a7b <span style=color:#099>2261</span> <span style=color:#099>7265</span> <span style=color:#099>6122</span> 3a34 <span style=color:#099>3837</span> <span style=color:#099>3634</span> <span style=color:#099>3133</span>
</span></span><span style=display:flex><span>0x00e0:  <span style=color:#099>3535</span> <span style=color:#099>3937</span> 2e38 <span style=color:#099>3432</span> <span style=color:#099>3630</span> 367d 2c22 <span style=color:#099>6572</span>
</span></span><span style=display:flex><span>0x00f0:  <span style=color:#099>7273</span> <span style=color:#099>7472</span> 223a <span style=color:#099>2222</span> 7d
</span></span></code></pre></div><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x00f9</td><td>总长度为249字节，即整个包的长度是249字节</td></tr><tr><td>0xd28c</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x40</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为64.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x874a</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit源ip地址。</td></tr><tr><td>0xac17 ccdc</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x1ba8</td><td style=text-align:left>16bit源端口7080</td></tr><tr><td style=text-align:left>0xdb9b</td><td style=text-align:left>16bit目的端口。56219</td></tr><tr><td style=text-align:left>0x6d03 e87d</td><td style=text-align:left>32bit序列号。1828972669</td></tr><tr><td style=text-align:left>0xa59a 492f</td><td style=text-align:left>32bit确认号。2778351919</td></tr><tr><td style=text-align:left>0x8</td><td style=text-align:left>4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td style=text-align:left>0b000000</td><td style=text-align:left>6bit保留位。目前置为0.</td></tr><tr><td style=text-align:left>0b011000</td><td style=text-align:left>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效</td></tr><tr><td style=text-align:left>0x00ec</td><td style=text-align:left>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。236</td></tr><tr><td style=text-align:left>0xe113</td><td style=text-align:left>16bit校验和。</td></tr><tr><td style=text-align:left>0x0000</td><td style=text-align:left>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x0402</td><td style=text-align:left>表示支持SACK</td></tr><tr><td style=text-align:left>0x080a 0f20 3af8 2e4c b2ef</td><td style=text-align:left>时间戳。Ts val=0x2e4c b2ef=253770488, ecr=0x0f20 3acf=776778479</td></tr></tbody></table><p>剩下来的就是数据部分了。我们一行一行地看。</p><table><thead><tr><th style=text-align:left>首地址</th><th style=text-align:left>字节流</th><th style=text-align:left>字符</th></tr></thead><tbody><tr><td style=text-align:left>0x0030</td><td style=text-align:left>4854 5450 2f31 2e31 2032 3030</td><td style=text-align:left>HTTP/1.1 200</td></tr><tr><td style=text-align:left>0x0040</td><td style=text-align:left>204f 4b0d 0a41 6363 6573 732d 436f 6e74</td><td style=text-align:left>OK \r\n Access-Cont</td></tr><tr><td style=text-align:left>0x0050</td><td style=text-align:left>726f 6c2d 416c 6c6f 772d 4f72 6967 696e</td><td style=text-align:left>rol-Allow-Origin</td></tr><tr><td style=text-align:left>0x0060</td><td style=text-align:left>3a20 2a0d 0a44 6174 653a 2054 6875 2c20</td><td style=text-align:left>: * \r\n Date: Thu,</td></tr><tr><td style=text-align:left>0x0070</td><td style=text-align:left>3033 204a 616e 2032 3031 3920 3132 3a32</td><td style=text-align:left>03 Jan 2019 12:2</td></tr><tr><td style=text-align:left>0x0080</td><td style=text-align:left>333a 3437 2047 4d54 0d0a 436f 6e74 656e</td><td style=text-align:left>3:47 GMT \r\n Conten</td></tr><tr><td style=text-align:left>0x0090</td><td style=text-align:left>742d 4c65 6e67 7468 3a20 3438 0d0a 436f</td><td style=text-align:left>t-Length: 48\r\n Co</td></tr><tr><td style=text-align:left>0x00a0</td><td style=text-align:left>6e74 656e 742d 5479 7065 3a20 7465 7874</td><td style=text-align:left>ntent-Type: text</td></tr><tr><td style=text-align:left>0x00b0</td><td style=text-align:left>2f70 6c61 696e 3b20 6368 6172 7365 743d</td><td style=text-align:left>/plain; charset=</td></tr><tr><td style=text-align:left>0x00c0</td><td style=text-align:left>7574 662d 380d 0a0d 0a7b 2264 6174 6122</td><td style=text-align:left>utf-8\r\n\r\n{&ldquo;data&rdquo;</td></tr><tr><td style=text-align:left>0x00d0</td><td style=text-align:left>3a7b 2261 7265 6122 3a34 3837 3634 3133</td><td style=text-align:left>:{&ldquo;area&rdquo;:4876413</td></tr><tr><td style=text-align:left>0x00e0</td><td style=text-align:left>3535 3937 2e38 3432 3630 367d 2c22 6572</td><td style=text-align:left>5597.842606},&ldquo;er</td></tr><tr><td style=text-align:left>0x00f0</td><td style=text-align:left>7273 7472 223a 2222 7d</td><td style=text-align:left>rstr&rdquo;:""}</td></tr></tbody></table><p>把上表的最后一列连起来，就是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>HTTP/1.1 <span style=color:#099>200</span> OK 
</span></span><span style=display:flex><span>Access-Control-Allow-Origin: * 
</span></span><span style=display:flex><span>Date: Thu, <span style=color:#099>03</span> Jan <span style=color:#099>2019</span> 12:23:47 GMT 
</span></span><span style=display:flex><span>Content-Length: <span style=color:#099>48</span> 
</span></span><span style=display:flex><span>Content-Type: text/plain; <span style=color:teal>charset</span><span style=color:#000;font-weight:700>=</span>utf-8 
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span><span style=color:#d14>&#34;data&#34;</span>:<span style=color:#000;font-weight:700>{</span><span style=color:#d14>&#34;area&#34;</span>:48764135597.842606<span style=color:#000;font-weight:700>}</span>,<span style=color:#d14>&#34;errstr&#34;</span>:<span style=color:#d14>&#34;&#34;</span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Content-Length: 48，最后一行的长度即为48个字节。</p><p>最后，第七个包，字节流如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>0x0000:  <span style=color:#099>4500</span> <span style=color:#099>0034</span> <span style=color:#099>0000</span> <span style=color:#099>4000</span> <span style=color:#099>3606</span> 649c ac17 ccdc
</span></span><span style=display:flex><span>0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e942
</span></span><span style=display:flex><span>0x0020:  <span style=color:#099>8010</span> 100f 1eb9 <span style=color:#099>0000</span> <span style=color:#099>0101</span> 080a 2e4c b314
</span></span><span style=display:flex><span>0x0030:  0f20 3af8
</span></span></code></pre></div><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0034</td><td>总长度为52字节，即整个包的长度是52字节</td></tr><tr><td>0x0000</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x649c</td><td>16bitIP首部校验和。</td></tr><tr><td>0xac17 ccdc</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0xdb9b</td><td style=text-align:left>16bit源端口。56219</td></tr><tr><td style=text-align:left>0x1ba8</td><td style=text-align:left>16bit目的端口7080</td></tr><tr><td style=text-align:left>0xa59a 492f</td><td style=text-align:left>32bit序列号。2778351919</td></tr><tr><td style=text-align:left>0x6d03 e942</td><td style=text-align:left>32bit确认号号。1828972866. 第六个包的序列号为1828972669, 加上数据长度197, 正好相等</td></tr><tr><td style=text-align:left>0x8</td><td style=text-align:left>4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td style=text-align:left>0b000000</td><td style=text-align:left>6bit保留位。目前置为0</td></tr><tr><td style=text-align:left>0b010000</td><td style=text-align:left>6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效</td></tr><tr><td style=text-align:left>0x100f</td><td style=text-align:left>滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4111</td></tr><tr><td style=text-align:left>0x1eb9</td><td style=text-align:left>16bit校验和。</td></tr><tr><td style=text-align:left>0x0000</td><td style=text-align:left>紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th style=text-align:left>字节值</th><th style=text-align:left>字节含义</th></tr></thead><tbody><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>无操作</td></tr><tr><td style=text-align:left>0x080a 2e4c b314 0f20 3af8</td><td style=text-align:left>时间戳。Ts val=0x2e4c b314=776778516, ecr=0x0f20 3af8=253770488</td></tr></tbody></table><p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p><h1 id=http协议分析>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p><h2 id=整体介绍>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点：<code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p><p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51079842-4b2f1780-170a-11e9-9b22-ad68fe4541cc.png><img class=mx-auto alt=HTTP层次 src=https://user-images.githubusercontent.com/7698088/51079842-4b2f1780-170a-11e9-9b22-ad68fe4541cc.png></a></p><p>HTTP在传输一段报文时，会以<code>流</code>的形式将报文数据的内容通过<code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/50802850-15adb700-1323-11e9-87b8-892139c3104d.png><img class=mx-auto alt="tcp http structure" src=https://user-images.githubusercontent.com/7698088/50802850-15adb700-1323-11e9-87b8-892139c3104d.png></a></p><h2 id=编码>编码</h2><p>我们再来回顾一下：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/61799702-286e8000-ae5e-11e9-9aad-768f0a522f12.png><img class=mx-auto alt=编码 src=https://user-images.githubusercontent.com/7698088/61799702-286e8000-ae5e-11e9-9aad-768f0a522f12.png></a></p><p>在之前的报文拆解过程中，我们看到多了很多<code>%22</code>，其实，<code>0x22</code>是单引号<code>"</code>的ascii值，</p><p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p><p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p><p>转义的方法：百分号(<code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51080616-322e6280-171a-11e9-8deb-28ca0a472d51.png><img class=mx-auto alt=转义法 src=https://user-images.githubusercontent.com/7698088/51080616-322e6280-171a-11e9-8deb-28ca0a472d51.png></a></p><p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51294507-3aeea380-1a4e-11e9-9f52-2fb248a2d5de.png><img class=mx-auto alt=url保留及受限的字符 src=https://user-images.githubusercontent.com/7698088/51294507-3aeea380-1a4e-11e9-9f52-2fb248a2d5de.png></a></p><p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p><h2 id=mime类型>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Content-Type: text/plain; <span style=color:teal>charset</span><span style=color:#000;font-weight:700>=</span>utf-8
</span></span></code></pre></div><p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的<code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51149947-3768ea00-189f-11e9-8fcd-d40f2f2ccf0a.png><img class=mx-auto alt=MIME类型 src=https://user-images.githubusercontent.com/7698088/51149947-3768ea00-189f-11e9-8fcd-d40f2f2ccf0a.png></a></p><h2 id=uriurlurn>URI/URL/URN</h2><p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p><p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p><p>URL通常的格式是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>协议方案+服务器地址+具体的资源路径
</span></span></code></pre></div><p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>.</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51070533-b5e64180-167d-11e9-8dc3-4c54b3cbf1a2.png><img class=mx-auto alt=URL举例 src=https://user-images.githubusercontent.com/7698088/51070533-b5e64180-167d-11e9-8dc3-4c54b3cbf1a2.png></a></p><h2 id=http方法>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51070644-a0721700-167f-11e9-8579-8702abdb860b.png><img class=mx-auto alt=常见的http方法 src=https://user-images.githubusercontent.com/7698088/51070644-a0721700-167f-11e9-8579-8702abdb860b.png></a></p><p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p><p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p><h2 id=状态码>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#099>200</span> OK 
</span></span><span style=display:flex><span><span style=color:#099>404</span> Not Found
</span></span><span style=display:flex><span><span style=color:#099>500</span> Internal Server Error
</span></span></code></pre></div><p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是<code>404 Not Found</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p><p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p><p>三位数字的第一位表示分类：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51070802-2f802e80-1682-11e9-8a02-f60e2f11c3e6.png><img class=mx-auto alt=http状态分类 src=https://user-images.githubusercontent.com/7698088/51070802-2f802e80-1682-11e9-8a02-f60e2f11c3e6.png></a></p><h2 id=报文格式>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用<code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说<code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p><p>举个简单的请求报文和响应报文的格式的例子：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51070991-6dcb1d00-1685-11e9-8dae-25b63ad7ad52.png><img class=mx-auto alt=请求响应报文示例 src=https://user-images.githubusercontent.com/7698088/51070991-6dcb1d00-1685-11e9-8dae-25b63ad7ad52.png></a></p><p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由<code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的<code>回车换行</code>符也是必须要有的。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51071026-c4d0f200-1685-11e9-81ca-87c8da1dfc30.png><img class=mx-auto alt=请求报文格式 src=https://user-images.githubusercontent.com/7698088/51071026-c4d0f200-1685-11e9-81ca-87c8da1dfc30.png></a></p><p>响应报文的格式和请求报文的格式类似：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51074380-67ef2f00-16b9-11e9-81e7-d5ecaa8d4537.png><img class=mx-auto alt=响应报文格式 src=https://user-images.githubusercontent.com/7698088/51074380-67ef2f00-16b9-11e9-81e7-d5ecaa8d4537.png></a></p><p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p><p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p><table><thead><tr><th style=text-align:left>首部</th><th style=text-align:left>属性</th><th style=text-align:left>值</th><th style=text-align:left>含义</th></tr></thead><tbody><tr><td style=text-align:left>Date</td><td style=text-align:left>通用</td><td style=text-align:left>Thu, 03 Jan 2019 12:23:47 GMT</td><td style=text-align:left>报文构建的时间</td></tr><tr><td style=text-align:left>Accept</td><td style=text-align:left>请求报文</td><td style=text-align:left>text/html,application/xhtml+xml,application/xm</td><td style=text-align:left>客户端能接收的数据类型</td></tr><tr><td style=text-align:left>Content-Type</td><td style=text-align:left>通用</td><td style=text-align:left>Content-Type: text/plain; charset=utf-8</td><td style=text-align:left>报文中的body部分的数据类型。注意，若是请求报文中也有数据部分，也是需要此字段的</td></tr></tbody></table><p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51079989-318fcf00-170e-11e9-9958-daf87d65972b.png><img class=mx-auto alt=用telnet进行http对话 src=https://user-images.githubusercontent.com/7698088/51079989-318fcf00-170e-11e9-9958-daf87d65972b.png></a></p><h1 id=http协议进阶>HTTP协议进阶</h1><h2 id=代理>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51082793-23ab6f80-1749-11e9-8247-1a3fc5ac4d1d.png><img class=mx-auto alt=HTTP代理 src=https://user-images.githubusercontent.com/7698088/51082793-23ab6f80-1749-11e9-8247-1a3fc5ac4d1d.png></a></p><p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为<code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为<code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如<code>User-Agent</code>, <code>Cookie</code>等字段。</p><p>现实中，请求通过以下几种方式打到代理服务器上去：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51083035-c534c000-174d-11e9-9cab-ddc4a0de2314.png><img class=mx-auto alt=代理获取流量的方式 src=https://user-images.githubusercontent.com/7698088/51083035-c534c000-174d-11e9-9cab-ddc4a0de2314.png></a></p><p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51083254-e7304180-1751-11e9-95f8-a833a0d10d51.png><img class=mx-auto alt=via字段 src=https://user-images.githubusercontent.com/7698088/51083254-e7304180-1751-11e9-95f8-a833a0d10d51.png></a></p><p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p><h2 id=缓存>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p><p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是<code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个<code>304 Not Modified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为<code>再验证命中</code>。</p><p>再验证可能出现命中或未命中的情况。未命中时，服务器回复<code>200 OK</code>，并且返回完整的数据；命中时，服务器回复<code>304 Not Modified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p><p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p><p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如<code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个<code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改<code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p><p>HTTP通过<code>文档过期机制</code>和<code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p><p>文档过期通过如下首部字段来表示缓存的有效期：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51092170-60ba4500-17cf-11e9-8689-71b3c552bff3.png><img class=mx-auto alt=缓存有效期 src=https://user-images.githubusercontent.com/7698088/51092170-60ba4500-17cf-11e9-8689-71b3c552bff3.png></a></p><p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的<code>Expires</code>字段等。</p><p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个<code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。<code>条件GET</code>请求会用到如下的字段：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51092289-8562ec80-17d0-11e9-9e35-47a010a3f7a3.png><img class=mx-auto alt=缓存条件GET src=https://user-images.githubusercontent.com/7698088/51092289-8562ec80-17d0-11e9-9e35-47a010a3f7a3.png></a></p><h2 id=cookie>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p><p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p><p>服务器在给客户端的响应字段首部加上<code>Set-cookie</code>或<code>Set-cookie2</code>, 值为<code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过<code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p><p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含<code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。<code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Set-cookie: <span style=color:teal>user</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;mary&#34;</span>; <span style=color:teal>domain</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;stefno.com&#34;</span>
</span></span></code></pre></div><p>那么浏览器在访问任意以<code>stefno.com</code>结尾的站点都会发送：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Cookie: <span style=color:teal>user</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;mary&#34;</span>
</span></span></code></pre></div><h2 id=实体和编码>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果<code>Content-Type</code>定义是<code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果<code>Content-Type</code>定义是<code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p><p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外，<code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上<code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的<code>Content-Length</code>首部。</p><p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p><p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到<code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改<code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与<code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p><p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51150609-12c24180-18a2-11e9-9ca4-032f5abcd474.png><img class=mx-auto alt=编码类型 src=https://user-images.githubusercontent.com/7698088/51150609-12c24180-18a2-11e9-9ca4-032f5abcd474.png></a></p><p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在<code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p><p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码：<code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p><p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到<code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到<code>传输编码</code>来标注数据的结束的。</p><p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p><table><thead><tr><th style=text-align:left>字段</th><th style=text-align:left>含义</th><th style=text-align:left>典型值</th></tr></thead><tbody><tr><td style=text-align:left>Transfer-Encoding</td><td style=text-align:left>发送方告知接收方，我方已经进行了何种传输编码</td><td style=text-align:left>chuncked 分块编码</td></tr><tr><td style=text-align:left>TE</td><td style=text-align:left>请求方告知服务器可以用哪种传输编码</td><td style=text-align:left>trailers, chuncked 接受分块编码，并且愿意接受在报文结尾上的拖挂</td></tr></tbody></table><p>分块编码的报文形式是这样的：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51151337-671af080-18a5-11e9-80ad-926461f90f6a.png><img class=mx-auto alt=分块编码 src=https://user-images.githubusercontent.com/7698088/51151337-671af080-18a5-11e9-80ad-926461f90f6a.png></a></p><p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。<code>&lt;CR>&lt;LF></code>用于区隔长度值和数据。长度值不包含分块中的任何<code>&lt;CR>&lt;LF></code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个<code>Trailer: Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如，<code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p><p>内容编码和传输编码是可以结合起来使用的。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51151680-ae55b100-18a6-11e9-819c-5cffcc35cd69.png><img class=mx-auto alt=内容编码和传输编码结合 src=https://user-images.githubusercontent.com/7698088/51151680-ae55b100-18a6-11e9-819c-5cffcc35cd69.png></a></p><h2 id=国际化支持>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过<code>Accept-Charset</code>和<code>Accept-Language</code>首部实现。</p><p>比如：</p><pre tabindex=0><code>Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
</code></pre><p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在<code>Content-Type</code>首部里放上<code>charset</code>.</p><p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p><p>比较常见的字符集是<code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p><p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。<code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用<code>10</code>标识。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51167193-e2e65e80-18e0-11e9-97da-caea0244386d.png><img class=mx-auto alt=utf-8编码 src=https://user-images.githubusercontent.com/7698088/51167193-e2e65e80-18e0-11e9-97da-caea0244386d.png></a></p><p>举个例子，汉字“严”的Unicode编码为<code>4E25</code>(<code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将<code>100111000100101</code>填入上表中的<code>c</code>位即可。因此，严的<code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>https:</span><span style=color:#998;font-style:italic>//www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF-8&amp;gws_rd=cr
</span></span></span></code></pre></div><p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p><h2 id=重定向与负载均衡>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓<code>狡兔三窟</code>嘛。</p><p>这样，用户的请求会根据<code>负载均衡</code>的原则，被<code>重定向</code>到它应该去的地方。</p><h3 id=http重定向>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码<code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用，<code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p><p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p><h3 id=dns重定向>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的<code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为<code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为<code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为<code>故障屏蔽算法</code>。</p><p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p><h2 id=http连接>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p><h3 id=并行连接>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p><p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/50803988-0f213e80-1327-11e9-93d9-10339ee54864.png><img class=mx-auto alt=串行连接 src=https://user-images.githubusercontent.com/7698088/50803988-0f213e80-1327-11e9-93d9-10339ee54864.png></a></p><p>采用并行连接之后：</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/50803776-13992780-1326-11e9-8752-defd450ca639.png><img class=mx-auto alt=并行连接 src=https://user-images.githubusercontent.com/7698088/50803776-13992780-1326-11e9-8752-defd450ca639.png></a></p><p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p><p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p><h3 id=持久连接>持久连接</h3><p>HTTP keep-alive机制</p><p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p><p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p><p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51286420-e4716d00-1a2d-11e9-9b95-79b1e0a1984a.png><img class=mx-auto alt="http keep alive" src=https://user-images.githubusercontent.com/7698088/51286420-e4716d00-1a2d-11e9-9b95-79b1e0a1984a.png></a></p><p>HTTP有keep-alive机制，目的是可以在一个TCP
连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcp_set_keepalive，来激活连接的keep-alive属性。</p><p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试<code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><h3 id=管道化连接>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p><p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p><h1 id=小结>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p><p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p><p><a data-fancybox=gallery href=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png><img class=mx-auto alt="QR margin2" src=https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png></a></p><h1 id=参考资料>参考资料</h1><p>【http长连接】 <a href=https://www.cnblogs.com/cswuyg/p/3653263.html>https://www.cnblogs.com/cswuyg/p/3653263.html</a></p><p>【http/tcp keep alive】 <a href=https://segmentfault.com/a/1190000012894416>https://segmentfault.com/a/1190000012894416</a></p><p>【http/tcp keep alive】 <a href=http://www.nowamagic.net/academy/detail/23350305>http://www.nowamagic.net/academy/detail/23350305</a></p><p>【http/tcp keep alive】 <a href=https://laravel-china.org/articles/8020/on-the-keep-alive-and-tcp-keep-alive-in-the-http-protocol>https://laravel-china.org/articles/8020/on-the-keep-alive-and-tcp-keep-alive-in-the-http-protocol</a></p><p>【tcp keep alive】 <a href=http://blog.51cto.com/zxtong/1788252>http://blog.51cto.com/zxtong/1788252</a></p><p>【http权威指南】 <a href=https://book.douban.com/subject/10746113/>https://book.douban.com/subject/10746113/</a></p><p>【HTTP状态码】 <a href=https://www.cnblogs.com/starof/p/5035119.html>https://www.cnblogs.com/starof/p/5035119.html</a></p><p>【HTTP协议】 <a href=https://www.cnblogs.com/ranyonsue/p/5984001.html>https://www.cnblogs.com/ranyonsue/p/5984001.html</a></p><p>【HTTP状态分类】 <a href=http://www.runoob.com/http/http-status-codes.html>http://www.runoob.com/http/http-status-codes.html</a></p><p>【url编码】 <a href=http://www.ruanyifeng.com/blog/2010/02/url_encoding.html>http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-http/>https://qcrao.com/post/dive-into-http/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li><li><a href=https://qcrao.com/post/how-to-use-functional-options-pattern/ title="曹大带我学 Go（7）—— 如何优雅地指定配置项">曹大带我学 Go（7）—— 如何优雅地指定配置项</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>