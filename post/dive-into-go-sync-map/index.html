<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>深度解密 Go 语言之 sync.map | qcrao 的博客</title><meta property="og:title" content="深度解密 Go 语言之 sync.map - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-05-06T09:40:56+08:00"><meta property="article:modified_time" content="2020-05-06T09:40:56+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="深度解密 Go 语言之 sync.map"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/dive-into-go-sync-map/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度解密 Go 语言之 sync.map</h1></header><date class="post-meta meta-date">2020年5月6日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>工作中，经常会碰到并发读写 map 而造成 panic 的情况，为什么在并发读写的时候，会 panic 呢？因为在并发读写的情况下，map 里的数据会被写乱，之后就是 <code>Garbage in, garbage out</code>，还不如直接 panic 了。</p><h1 id=是什么>是什么</h1><p>Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。而 <code>sync.map</code> 则是一种并发安全的 map，在 Go 1.9 引入。</p><blockquote><p><code>sync.map</code> 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。</p></blockquote><blockquote><p><code>sync.map</code> 的零值是有效的，并且零值是一个空的 map。在第一次使用之后，不允许被拷贝。</p></blockquote><h1 id=有什么用>有什么用</h1><p>一般情况下解决并发读写 map 的思路是加一把大锁，或者把一个 map 分成若干个小 map，对 key 进行哈希，只操作相应的小 map。前者锁的粒度比较大，影响效率；后者实现起来比较复杂，容易出错。</p><p>而使用 <code>sync.map</code> 之后，对 map 的读写，不需要加锁。并且它通过空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。</p><h1 id=如何使用>如何使用</h1><p>使用非常简单，和普通 map 相比，仅遍历的方式略有区别：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#d14>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>()  {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>var</span> m sync.Map
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 1. 写入
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	m.<span style=color:#900;font-weight:700>Store</span>(<span style=color:#d14>&#34;qcrao&#34;</span>, <span style=color:#099>18</span>)
</span></span><span style=display:flex><span>	m.<span style=color:#900;font-weight:700>Store</span>(<span style=color:#d14>&#34;stefno&#34;</span>, <span style=color:#099>20</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 2. 读取
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	age, _ <span style=color:#000;font-weight:700>:=</span> m.<span style=color:#900;font-weight:700>Load</span>(<span style=color:#d14>&#34;qcrao&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(age.(<span style=color:#458;font-weight:700>int</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 3. 遍历
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	m.<span style=color:#900;font-weight:700>Range</span>(<span style=color:#000;font-weight:700>func</span>(key, value <span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>		name <span style=color:#000;font-weight:700>:=</span> key.(<span style=color:#458;font-weight:700>string</span>)
</span></span><span style=display:flex><span>		age <span style=color:#000;font-weight:700>:=</span> value.(<span style=color:#458;font-weight:700>int</span>)
</span></span><span style=display:flex><span>		fmt.<span style=color:#900;font-weight:700>Println</span>(name, age)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 4. 删除
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	m.<span style=color:#900;font-weight:700>Delete</span>(<span style=color:#d14>&#34;qcrao&#34;</span>)
</span></span><span style=display:flex><span>	age, ok <span style=color:#000;font-weight:700>:=</span> m.<span style=color:#900;font-weight:700>Load</span>(<span style=color:#d14>&#34;qcrao&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(age, ok)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 5. 读取或写入
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	m.<span style=color:#900;font-weight:700>LoadOrStore</span>(<span style=color:#d14>&#34;stefno&#34;</span>, <span style=color:#099>100</span>)
</span></span><span style=display:flex><span>	age, _ = m.<span style=color:#900;font-weight:700>Load</span>(<span style=color:#d14>&#34;stefno&#34;</span>)
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(age)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第 1 步，写入两个 k-v 对；</p><p>第 2 步，使用 Load 方法读取其中的一个 key；</p><p>第 3 步，遍历所有的 k-v 对，并打印出来；</p><p>第 4 步，删除其中的一个 key，再读这个 key，得到的就是 nil；</p><p>第 5 步，使用 LoadOrStore，尝试读取或写入 &ldquo;Stefno&rdquo;，因为这个 key 已经存在，因此写入不成功，并且读出原值。</p><p>程序输出：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#099>18</span>
</span></span><span style=display:flex><span>stefno <span style=color:#099>20</span>
</span></span><span style=display:flex><span>qcrao <span style=color:#099>18</span>
</span></span><span style=display:flex><span>&lt;nil&gt; <span style=color:#0086b3>false</span>
</span></span><span style=display:flex><span><span style=color:#099>20</span>
</span></span></code></pre></div><p><code>sync.map</code> 适用于读多写少的场景。对于写多的场景，会导致 read map 缓存失效，需要加锁，导致冲突变多；而且由于未命中 read map 次数过多，导致 dirty map 提升为 read map，这是一个 O(N) 的操作，会进一步降低性能。</p><h1 id=源码分析>源码分析</h1><h2 id=数据结构>数据结构</h2><p>先来看下 map 的数据结构。去掉大段的注释后：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Map <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	mu Mutex
</span></span><span style=display:flex><span>	read atomic.Value <span style=color:#998;font-style:italic>// readOnly
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	dirty <span style=color:#000;font-weight:700>map</span>[<span style=color:#000;font-weight:700>interface</span>{}]<span style=color:#000;font-weight:700>*</span>entry
</span></span><span style=display:flex><span>	misses <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>互斥量 <code>mu</code> 保护 read 和 dirty。</p><p><code>read</code> 是 atomic.Value 类型，可以并发地读。但如果需要更新 <code>read</code>，则需要加锁保护。对于 read 中存储的 entry 字段，可能会被并发地 CAS 更新。但是如果要更新一个之前已被删除的 entry，则需要先将其状态从 expunged 改为 nil，再拷贝到 dirty 中，然后再更新。</p><p><code>dirty</code> 是一个非线程安全的原始 map。包含新写入的 key，并且包含 <code>read</code> 中的所有未被删除的 key。这样，可以快速地将 <code>dirty</code> 提升为 <code>read</code> 对外提供服务。如果 <code>dirty</code> 为 nil，那么下一次写入时，会新建一个新的 <code>dirty</code>，这个初始的 <code>dirty</code> 是 <code>read</code> 的一个拷贝，但除掉了其中已被删除的 key。</p><p>每当从 read 中读取失败，都会将 <code>misses</code> 的计数值加 1，当加到一定阈值以后，需要将 dirty 提升为 read，以期减少 miss 的情形。</p><blockquote><p><code>read map</code> 和 <code>dirty map</code> 的存储方式是不一致的。</p></blockquote><blockquote><p>前者使用 atomic.Value，后者只是单纯的使用 map。</p></blockquote><blockquote><p>原因是 read map 使用 lock free 操作，必须保证 load/store 的原子性；而 dirty map 的 load+store 操作是由 lock（就是 mu）来保护的。</p></blockquote><p>真正存储 <code>key/value</code> 的是 read 和 dirty 字段。<code>read</code> 使用 atomic.Value，这是 lock-free 的基础，保证 load/store 的原子性。<code>dirty</code> 则直接用了一个原始的 map，对于它的 load/store 操作需要加锁。</p><p><code>read</code> 字段里实际上是存储的是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// readOnly is an immutable struct stored atomically in the Map.read field.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> readOnly <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	m       <span style=color:#000;font-weight:700>map</span>[<span style=color:#000;font-weight:700>interface</span>{}]<span style=color:#000;font-weight:700>*</span>entry
</span></span><span style=display:flex><span>	amended <span style=color:#458;font-weight:700>bool</span> <span style=color:#998;font-style:italic>// true if the dirty map contains some key not in m.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>注意到 read 和 dirty 里存储的东西都包含 <code>entry</code>，来看一下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> entry <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	p unsafe.Pointer <span style=color:#998;font-style:italic>// *interface{}
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>很简单，它是一个指针，指向 value。看来，read 和 dirty 各自维护一套 key，key 指向的都是同一个 value。也就是说，只要修改了这个 entry，对 read 和 dirty 都是可见的。这个指针的状态有三种：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200504093007.png><img class=mx-auto alt="p 的三种状态" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200504093007.png></a></p><p>当 <code>p == nil</code> 时，说明这个键值对已被删除，并且 m.dirty == nil，或 m.dirty[k] 指向该 entry。</p><p>当 <code>p == expunged</code> 时，说明这条键值对已被删除，并且 m.dirty != nil，且 m.dirty 中没有这个 key。</p><p>其他情况，p 指向一个正常的值，表示实际 <code>interface{}</code> 的地址，并且被记录在 m.read.m[key] 中。如果这时 m.dirty 不为 nil，那么它也被记录在 m.dirty[key] 中。两者实际上指向的是同一个值。</p><p>当删除 key 时，并不实际删除。一个 entry 可以通过原子地（CAS 操作）设置 p 为 nil 被删除。如果之后创建 m.dirty，nil 又会被原子地设置为 expunged，且不会拷贝到 dirty 中。</p><p>如果 p 不为 expunged，和 entry 相关联的这个 value 可以被原子地更新；如果 <code>p == expunged</code>，那么仅当它初次被设置到 m.dirty 之后，才可以被更新。</p><p>整体用一张图来表示：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200505120255.png><img class=mx-auto alt="sync.map 整体结构" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200505120255.png></a></p><h2 id=store>Store</h2><p>先来看 expunged：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>var</span> expunged = unsafe.<span style=color:#900;font-weight:700>Pointer</span>(<span style=color:#0086b3>new</span>(<span style=color:#000;font-weight:700>interface</span>{}))
</span></span></code></pre></div><p>它是一个指向任意类型的指针，用来标记从 dirty map 中删除的 entry。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// Store sets the value for a key.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>Map) <span style=color:#900;font-weight:700>Store</span>(key, value <span style=color:#000;font-weight:700>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 如果 read map 中存在该 key  则尝试直接更改(由于修改的是 entry 内部的 pointer，因此 dirty map 也可见)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	read, _ <span style=color:#000;font-weight:700>:=</span> m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> e, ok <span style=color:#000;font-weight:700>:=</span> read.m[key]; ok <span style=color:#000;font-weight:700>&amp;&amp;</span> e.<span style=color:#900;font-weight:700>tryStore</span>(<span style=color:#000;font-weight:700>&amp;</span>value) {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m.mu.<span style=color:#900;font-weight:700>Lock</span>()
</span></span><span style=display:flex><span>	read, _ = m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> e, ok <span style=color:#000;font-weight:700>:=</span> read.m[key]; ok {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> e.<span style=color:#900;font-weight:700>unexpungeLocked</span>() {
</span></span><span style=display:flex><span>			<span style=color:#998;font-style:italic>// 如果 read map 中存在该 key，但 p == expunged，则说明 m.dirty != nil 并且 m.dirty 中不存在该 key 值 此时:
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>//    a. 将 p 的状态由 expunged  更改为 nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>//    b. dirty map 插入 key
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			m.dirty[key] = e
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 更新 entry.p = value (read map 和 dirty map 指向同一个 entry)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		e.<span style=color:#900;font-weight:700>storeLocked</span>(<span style=color:#000;font-weight:700>&amp;</span>value)
</span></span><span style=display:flex><span>	} <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>if</span> e, ok <span style=color:#000;font-weight:700>:=</span> m.dirty[key]; ok {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 如果 read map 中不存在该 key，但 dirty map 中存在该 key，直接写入更新 entry(read map 中仍然没有这个 key)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		e.<span style=color:#900;font-weight:700>storeLocked</span>(<span style=color:#000;font-weight:700>&amp;</span>value)
</span></span><span style=display:flex><span>	} <span style=color:#000;font-weight:700>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 如果 read map 和 dirty map 中都不存在该 key，则：
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>//	  a. 如果 dirty map 为空，则需要创建 dirty map，并从 read map 中拷贝未删除的元素到新创建的 dirty map
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>//    b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>//    c. 将 kv 写入 dirty map 中，read 不变
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> !read.amended {
</span></span><span style=display:flex><span>		    <span style=color:#998;font-style:italic>// 到这里就意味着，当前的 key 是第一次被加到 dirty map 中。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// store 之前先判断一下 dirty map 是否为空，如果为空，就把 read map 浅拷贝一次。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			m.<span style=color:#900;font-weight:700>dirtyLocked</span>()
</span></span><span style=display:flex><span>			m.read.<span style=color:#900;font-weight:700>Store</span>(readOnly{m: read.m, amended: <span style=color:#000;font-weight:700>true</span>})
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 写入新 key，在 dirty 中存储 value
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		m.dirty[key] = <span style=color:#900;font-weight:700>newEntry</span>(value)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	m.mu.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>整体流程：</p><ol><li>如果在 read 里能够找到待存储的 key，并且对应的 entry 的 p 值不为 expunged，也就是没被删除时，直接更新对应的 entry 即可。</li><li>第一步没有成功：要么 read 中没有这个 key，要么 key 被标记为删除。则先加锁，再进行后续的操作。</li><li>再次在 read 中查找是否存在这个 key，也就是 double check 一下，这也是 lock-free 编程里的常见套路。如果 read 中存在该 key，但 <code>p == expunged</code>，说明 m.dirty != nil 并且 m.dirty 中不存在该 key 值 此时: a. 将 p 的状态由 expunged 更改为 nil；b. dirty map 插入 key。然后，直接更新对应的 value。</li><li>如果 read 中没有此 key，那就查看 dirty 中是否有此 key，如果有，则直接更新对应的 value，这时 read 中还是没有此 key。</li><li>最后一步，如果 read 和 dirty 中都不存在该 key，则：a. 如果 dirty 为空，则需要创建 dirty，并从 read 中拷贝未被删除的元素；b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key；c. 将 k-v 写入 dirty map 中，read.m 不变。最后，更新此 key 对应的 value。</li></ol><p>再来看一些子函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// 如果 entry 没被删，tryStore 存储值到 entry 中。如果 p == expunged，即 entry 被删，那么返回 false。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (e <span style=color:#000;font-weight:700>*</span>entry) <span style=color:#900;font-weight:700>tryStore</span>(i <span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>		p <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> p <span style=color:#000;font-weight:700>==</span> expunged {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p, p, unsafe.<span style=color:#900;font-weight:700>Pointer</span>(i)) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>tryStore</code> 在 Store 函数最开始的时候就会调用，是比较常见的 <code>for</code> 循环加 CAS 操作，尝试更新 entry，让 p 指向新的值。</p><p><code>unexpungeLocked</code> 函数确保了 entry 没有被标记成已被清除：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// unexpungeLocked 函数确保了 entry 没有被标记成已被清除。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 如果 entry 先前被清除过了，那么在 mutex 解锁之前，它一定要被加入到 dirty map 中
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (e <span style=color:#000;font-weight:700>*</span>entry) <span style=color:#900;font-weight:700>unexpungeLocked</span>() (wasExpunged <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p, expunged, <span style=color:#000;font-weight:700>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=load>Load</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>Map) <span style=color:#900;font-weight:700>Load</span>(key <span style=color:#000;font-weight:700>interface</span>{}) (value <span style=color:#000;font-weight:700>interface</span>{}, ok <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	read, _ <span style=color:#000;font-weight:700>:=</span> m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>	e, ok <span style=color:#000;font-weight:700>:=</span> read.m[key]
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 如果没在 read 中找到，并且 amended 为 true，即 dirty 中存在 read 中没有的 key
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> !ok <span style=color:#000;font-weight:700>&amp;&amp;</span> read.amended {
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Lock</span>() <span style=color:#998;font-style:italic>// dirty map 不是线程安全的，所以需要加上互斥锁
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#998;font-style:italic>// double check。避免在上锁的过程中 dirty map 提升为 read map。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		read, _ = m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>		e, ok = read.m[key]
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 仍然没有在 read 中找到这个 key，并且 amended 为 true
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> !ok <span style=color:#000;font-weight:700>&amp;&amp;</span> read.amended {
</span></span><span style=display:flex><span>			e, ok = m.dirty[key] <span style=color:#998;font-style:italic>// 从 dirty 中找
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			<span style=color:#998;font-style:italic>// 不管 dirty 中有没有找到，都要&#34;记一笔&#34;，因为在 dirty 提升为 read 之前，都会进入这条路径
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>			m.<span style=color:#900;font-weight:700>missLocked</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> !ok { <span style=color:#998;font-style:italic>// 如果没找到，返回空，false
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> e.<span style=color:#900;font-weight:700>load</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>处理路径分为 fast path 和 slow path，整体流程如下：</p><ol><li>首先是 fast path，直接在 read 中找，如果找到了直接调用 entry 的 load 方法，取出其中的值。</li><li>如果 read 中没有这个 key，且 amended 为 fase，说明 dirty 为空，那直接返回 空和 false。</li><li>如果 read 中没有这个 key，且 amended 为 true，说明 dirty 中可能存在我们要找的 key。当然要先上锁，再尝试去 dirty 中查找。在这之前，仍然有一个 double check 的操作。若还是没有在 read 中找到，那么就从 dirty 中找。不管 dirty 中有没有找到，都要"记一笔"，因为在 dirty 被提升为 read 之前，都会进入这条路径</li></ol><p>这里主要看下 <code>missLocked</code> 的函数的实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>Map) <span style=color:#900;font-weight:700>missLocked</span>() {
</span></span><span style=display:flex><span>	m.misses<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> m.misses &lt; <span style=color:#0086b3>len</span>(m.dirty) {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// dirty map 晋升
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	m.read.<span style=color:#900;font-weight:700>Store</span>(readOnly{m: m.dirty})
</span></span><span style=display:flex><span>	m.dirty = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>	m.misses = <span style=color:#099>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>直接将 misses 的值加 1，表示一次未命中，如果 misses 值小于 m.dirty 的长度，就直接返回。否则，将 m.dirty 晋升为 read，并清空 dirty，清空 misses 计数值。这样，之前一段时间新加入的 key 都会进入到 read 中，从而能够提升 read 的命中率。</p><p>再来看下 entry 的 load 方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (e <span style=color:#000;font-weight:700>*</span>entry) <span style=color:#900;font-weight:700>load</span>() (value <span style=color:#000;font-weight:700>interface</span>{}, ok <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> p <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> <span style=color:#000;font-weight:700>||</span> p <span style=color:#000;font-weight:700>==</span> expunged {
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>, <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#000;font-weight:700>interface</span>{})(p), <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于 nil 和 expunged 状态的 entry，直接返回 <code>ok=false</code>；否则，将 p 转成 <code>interface{}</code> 返回。</p><h2 id=delete>Delete</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#998;font-style:italic>// Delete deletes the value for a key.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>Map) <span style=color:#900;font-weight:700>Delete</span>(key <span style=color:#000;font-weight:700>interface</span>{}) {
</span></span><span style=display:flex><span>	read, _ <span style=color:#000;font-weight:700>:=</span> m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>	e, ok <span style=color:#000;font-weight:700>:=</span> read.m[key]
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// 如果 read 中没有这个 key，且 dirty map 不为空
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>if</span> !ok <span style=color:#000;font-weight:700>&amp;&amp;</span> read.amended {
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Lock</span>()
</span></span><span style=display:flex><span>		read, _ = m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>		e, ok = read.m[key]
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> !ok <span style=color:#000;font-weight:700>&amp;&amp;</span> read.amended {
</span></span><span style=display:flex><span>			<span style=color:#0086b3>delete</span>(m.dirty, key) <span style=color:#998;font-style:italic>// 直接从 dirty 中删除这个 key
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		}
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> ok {
</span></span><span style=display:flex><span>		e.<span style=color:#0086b3>delete</span>() <span style=color:#998;font-style:italic>// 如果在 read 中找到了这个 key，将 p 置为 nil
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，基本套路还是和 Load，Store 类似，都是先从 read 里查是否有这个 key，如果有则执行 <code>entry.delete</code> 方法，将 p 置为 nil，这样 read 和 dirty 都能看到这个变化。</p><p>如果没在 read 中找到这个 key，并且 dirty 不为空，那么就要操作 dirty 了，操作之前，还是要先上锁。然后进行 double check，如果仍然没有在 read 里找到此 key，则从 dirty 中删掉这个 key。但不是真正地从 dirty 中删除，而是更新 entry 的状态。</p><p>来看下 <code>entry.delete</code> 方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (e <span style=color:#000;font-weight:700>*</span>entry) <span style=color:#0086b3>delete</span>() (hadValue <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> {
</span></span><span style=display:flex><span>		p <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> p <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> <span style=color:#000;font-weight:700>||</span> p <span style=color:#000;font-weight:700>==</span> expunged {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p, p, <span style=color:#000;font-weight:700>nil</span>) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它真正做的事情是将正常状态（指向一个 interface{}）的 p 设置成 nil。没有设置成 expunged 的原因是，当 p 为 expunged 时，表示它已经不在 dirty 中了。这是 p 的状态机决定的，在 <code>tryExpungeLocked</code> 函数中，会将 nil 原子地设置成 expunged。</p><p><code>tryExpungeLocked</code> 是在新创建 dirty 时调用的，会将已被删除的 entry.p 从 nil 改成 expunged，这个 entry 就不会写入 dirty 了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (e <span style=color:#000;font-weight:700>*</span>entry) <span style=color:#900;font-weight:700>tryExpungeLocked</span>() (isExpunged <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	p <span style=color:#000;font-weight:700>:=</span> atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> p <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#998;font-style:italic>// 如果原来是 nil，说明原 key 已被删除，则将其转为 expunged。
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>		<span style=color:#000;font-weight:700>if</span> atomic.<span style=color:#900;font-weight:700>CompareAndSwapPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p, <span style=color:#000;font-weight:700>nil</span>, expunged) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		p = atomic.<span style=color:#900;font-weight:700>LoadPointer</span>(<span style=color:#000;font-weight:700>&amp;</span>e.p)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>return</span> p <span style=color:#000;font-weight:700>==</span> expunged
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意到如果 key 同时存在于 read 和 dirty 中时，删除只是做了一个标记，将 p 置为 nil；而如果仅在 dirty 中含有这个 key 时，会直接删除这个 key。原因在于，若两者都存在这个 key，仅做标记删除，可以在下次查找这个 key 时，命中 read，提升效率。若只有在 dirty 中存在时，read 起不到“缓存”的作用，直接删除。</p><h2 id=loadorstore>LoadOrStore</h2><p>这个函数结合了 Load 和 Store 的功能，如果 map 中存在这个 key，那么返回这个 key 对应的 value；否则，将 key-value 存入 map。这在需要先执行 Load 查看某个 key 是否存在，之后再更新此 key 对应的 value 时很有效，因为 LoadOrStore 可以并发执行。</p><p>具体的过程不再一一分析了，可参考 Load 和 Store 的源码分析。</p><h2 id=range>Range</h2><p>Range 的参数是一个函数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>f <span style=color:#000;font-weight:700>func</span>(key, value <span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span>
</span></span></code></pre></div><p>由使用者提供实现，Range 将遍历调用时刻 map 中的所有 k-v 对，将它们传给 f 函数，如果 f 返回 false，将停止遍历。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>Map) <span style=color:#900;font-weight:700>Range</span>(f <span style=color:#000;font-weight:700>func</span>(key, value <span style=color:#000;font-weight:700>interface</span>{}) <span style=color:#458;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>	read, _ <span style=color:#000;font-weight:700>:=</span> m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>if</span> read.amended {
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Lock</span>()
</span></span><span style=display:flex><span>		read, _ = m.read.<span style=color:#900;font-weight:700>Load</span>().(readOnly)
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> read.amended {
</span></span><span style=display:flex><span>			read = readOnly{m: m.dirty}
</span></span><span style=display:flex><span>			m.read.<span style=color:#900;font-weight:700>Store</span>(read)
</span></span><span style=display:flex><span>			m.dirty = <span style=color:#000;font-weight:700>nil</span>
</span></span><span style=display:flex><span>			m.misses = <span style=color:#099>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		m.mu.<span style=color:#900;font-weight:700>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>for</span> k, e <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> read.m {
</span></span><span style=display:flex><span>		v, ok <span style=color:#000;font-weight:700>:=</span> e.<span style=color:#900;font-weight:700>load</span>()
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> !ok {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#000;font-weight:700>if</span> !<span style=color:#900;font-weight:700>f</span>(k, v) {
</span></span><span style=display:flex><span>			<span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当 amended 为 true 时，说明 dirty 中含有 read 中没有的 key，因为 Range 会遍历所有的 key，是一个 O(n) 操作。将 dirty 提升为 read，会将开销分摊开来，所以这里直接就提升了。</p><p>之后，遍历 read，取出 entry 中的值，调用 f(k, v)。</p><h1 id=其他>其他</h1><p>关于为何 <code>sync.map</code> 没有 Len 方法，参考资料里给出了 <a href=https://github.com/golang/go/issues/20680>issue</a>，<code>bcmills</code> 认为对于并发的数据结构和非并发的数据结构并不一定要有相同的方法。例如，map 有 Len 方法，sync.map 却不一定要有。就像 sync.map 有 LoadOrStore 方法，map 就没有一样。</p><p>有些实现增加了一个计数器，并原子地增加或减少它，以此来表示 sync.map 中元素的个数。但 <code>bcmills</code> 提出这会引入竞争：<code>atomic</code> 并不是 <code>contention-free</code> 的，它只是把竞争下沉到了 CPU 层级。这会给其他不需要 Len 方法的场景带来负担。</p><h1 id=总结>总结</h1><ol><li><p><code>sync.map</code> 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。</p></li><li><p>通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。</p></li><li><p>Range 操作需要提供一个函数，参数是 <code>k,v</code>，返回值是一个布尔值：<code>f func(key, value interface{}) bool</code>。</p></li><li><p>调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。</p></li><li><p>新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。</p></li><li><p>当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据。</p></li></ol><h1 id=参考资料>参考资料</h1><p>【德志大佬-设计并发安全的 map】 <a href=https://halfrost.com/go_map_chapter_one/>https://halfrost.com/go_map_chapter_one/</a></p><p>【德志大佬-设计并发安全的 map】 <a href=https://halfrost.com/go_map_chapter_two/>https://halfrost.com/go_map_chapter_two/</a></p><p>【关于 sync.map 为什么没有 len 方法的 issue】 <a href=https://github.com/golang/go/issues/20680>https://github.com/golang/go/issues/20680</a></p><p>【芮神增加了 len 方法】 <a href=http://xiaorui.cc/archives/4972>http://xiaorui.cc/archives/4972</a></p><p>【图解 map 操作】 <a href=https://wudaijun.com/2018/02/go-sync-map-implement/>https://wudaijun.com/2018/02/go-sync-map-implement/</a></p><p>【从一道面试题开始】 <a href=https://segmentfault.com/a/1190000018657984>https://segmentfault.com/a/1190000018657984</a></p><p>【源码分析】 <a href=https://zhuanlan.zhihu.com/p/44585993>https://zhuanlan.zhihu.com/p/44585993</a></p><p>【行文通畅，流程图清晰】 <a href=https://juejin.im/post/5d36a7cbf265da1bb47da444>https://juejin.im/post/5d36a7cbf265da1bb47da444</a></p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/dive-into-go-sync-map/>https://qcrao.com/post/dive-into-go-sync-map/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/100-go-mistakes-reading-notes/ title="深度阅读之《100 Go Mistakes and How to Avoid Them》">深度阅读之《100 Go Mistakes and How to Avoid Them》</a></li><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄漏？">Go map 竟然也会发生内存泄漏？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>