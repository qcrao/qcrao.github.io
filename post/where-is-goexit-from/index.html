<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>曹大带我学 Go（5）—— 哪来里的 goexit？ | qcrao 的博客</title><meta property="og:title" content="曹大带我学 Go（5）—— 哪来里的 goexit？ - qcrao 的博客"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-06-07T23:26:36+08:00"><meta property="article:modified_time" content="2021-06-07T23:26:36+08:00"><meta name=Keywords content="golang,go语言,后端,个人成长"><meta name=description content="曹大带我学 Go（5）—— 哪来里的 goexit？"><meta name=author content="饶全成"><meta property="og:url" content="https://qcrao.com/post/where-is-goexit-from/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><script type=text/javascript src=//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<link href=https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=https://qcrao.com>qcrao 的博客</a><p class=description>专注于 Go 语言(golang)、后端架构、个人成长</p></div><div><nav id=nav-menu class=clearfix><a class=current href=https://qcrao.com>首页</a>
<a href=https://qcrao.com/archives/ title=归档>归档</a>
<a href=https://qcrao.com/about/ title=关于>关于</a>
<a href=https://qcrao.com/readings/ title=阅读>阅读</a>
<a href=https://qcrao.com/ishare/ title=分享>分享</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>曹大带我学 Go（5）—— 哪来里的 goexit？</h1></header><date class="post-meta meta-date">2021年6月7日</date><div class=post-meta><span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
阅读</span></span></div><div class=post-content><p>有同学在用 dlv 调试时看到了令人不解的 <code>goexit</code>：goexit 函数是啥，为啥 <code>go fun(){}()</code> 的上层是它？看着像是一个“退出”函数，为什么会出现在最上层？</p><p>其实如果看过 pprof 的火焰图，也会经常看到 <code>goexit</code> 这个函数。</p><p>我们来个例子重现一下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#d14>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span> ()  {
</span></span><span style=display:flex><span>		<span style=color:#0086b3>println</span>(<span style=color:#d14>&#34;hello world&#34;</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	time.<span style=color:#900;font-weight:700>Sleep</span>(<span style=color:#099>10</span><span style=color:#000;font-weight:700>*</span>time.Minute)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>启动 dlv 调试，并分别在不同的地方打上断点：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>dlv<span style=color:#000;font-weight:700>)</span> b a.go:5 
</span></span><span style=display:flex><span>Breakpoint <span style=color:#099>1</span> <span style=color:#000;font-weight:700>(</span>enabled<span style=color:#000;font-weight:700>)</span> <span style=color:#0086b3>set</span> at 0x106d12f <span style=color:#000;font-weight:700>for</span> main.main<span style=color:#000;font-weight:700>()</span> ./a.go:5
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>dlv<span style=color:#000;font-weight:700>)</span> b a.go:6
</span></span><span style=display:flex><span>Breakpoint <span style=color:#099>2</span> <span style=color:#000;font-weight:700>(</span>enabled<span style=color:#000;font-weight:700>)</span> <span style=color:#0086b3>set</span> at 0x106d13d <span style=color:#000;font-weight:700>for</span> main.main<span style=color:#000;font-weight:700>()</span> ./a.go:6
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>dlv<span style=color:#000;font-weight:700>)</span> b a.go:7
</span></span><span style=display:flex><span>Breakpoint <span style=color:#099>3</span> <span style=color:#000;font-weight:700>(</span>enabled<span style=color:#000;font-weight:700>)</span> <span style=color:#0086b3>set</span> at 0x106d1a0 <span style=color:#000;font-weight:700>for</span> main.main.func1<span style=color:#000;font-weight:700>()</span> ./a.go:7
</span></span></code></pre></div><p>执行命令 <code>c</code> 运行到断点处，再执行 <code>bt</code> 命令得到 main 函数的调用栈：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#000;font-weight:700>(</span>dlv<span style=color:#000;font-weight:700>)</span> bt
</span></span><span style=display:flex><span><span style=color:#099>0</span>  0x000000000106d12f in main.main
</span></span><span style=display:flex><span>   at ./a.go:5
</span></span><span style=display:flex><span><span style=color:#099>1</span>  0x0000000001035c0f in runtime.main
</span></span><span style=display:flex><span>   at /usr/local/go/src/runtime/proc.go:204
</span></span><span style=display:flex><span><span style=color:#099>2</span>  0x0000000001064961 in runtime.goexit
</span></span><span style=display:flex><span>   at /usr/local/go/src/runtime/asm_amd64.s:1374
</span></span></code></pre></div><p>它的上一层是 <code>runtime.main</code>，找到原代码位置，位于 <code>src/runtime/proc.go</code> 里的 <code>main</code> 函数，它是 Go 进程的 main goroutine，这里会执行一些 init 操作、开启 GC、执行用户 main 函数……</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>fn <span style=color:#000;font-weight:700>:=</span> main_main <span style=color:#998;font-style:italic>// proc.go:203
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#900;font-weight:700>fn</span>() <span style=color:#998;font-style:italic>// proc.go:204
</span></span></span></code></pre></div><p>其中 <code>fn</code> 是 <code>main_main</code> 函数，表示用户的 main 函数，执行到了这里，才真正将权力交给用户。</p><p>继续执行 <code>c</code> 命令和 <code>bt</code> 命令，得到 <code>go</code> 这一行的调用栈：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#099>0</span>  0x000000000106d13d in main.main
</span></span><span style=display:flex><span>   at ./a.go:6
</span></span><span style=display:flex><span><span style=color:#099>1</span>  0x0000000001035c0f in runtime.main
</span></span><span style=display:flex><span>   at /usr/local/go/src/runtime/proc.go:204
</span></span><span style=display:flex><span><span style=color:#099>2</span>  0x0000000001064961 in runtime.goexit
</span></span><span style=display:flex><span>   at /usr/local/go/src/runtime/asm_amd64.s:1374
</span></span></code></pre></div><p>以及 <code>println</code> 这一句的调用栈：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#099>0</span>  0x000000000106d1a0 in main.main.func1
</span></span><span style=display:flex><span>   at ./a.go:7
</span></span><span style=display:flex><span><span style=color:#099>1</span>  0x0000000001064961 in runtime.goexit
</span></span><span style=display:flex><span>   at /usr/local/go/src/runtime/asm_amd64.s:1374
</span></span></code></pre></div><p>可以看到，调用栈的最上层都是 <code>runtime.goexit</code>，我们跟着注明了的代码行数，顺藤摸瓜，找到 goexit 代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#998;font-style:italic>// The top-most function running on a goroutine
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// returns to goexit+PCQuantum.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#900;font-weight:700>TEXT</span> <span style=color:teal>runtime</span><span style=color:#a61717;background-color:#e3d2d2>·</span><span style=color:teal>goexit</span>(<span style=color:teal>SB</span>),<span style=color:teal>NOSPLIT</span>,<span style=color:teal>$0-0</span>
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>BYTE</span>	<span style=color:teal>$0x90</span>	<span style=color:#998;font-style:italic>// NOP
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#900;font-weight:700>CALL</span>	<span style=color:teal>runtime</span><span style=color:#a61717;background-color:#e3d2d2>·</span><span style=color:teal>goexit1</span>(<span style=color:teal>SB</span>)	<span style=color:#998;font-style:italic>// does not return
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#998;font-style:italic>// traceback from goexit1 must hit code range of goexit
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#900;font-weight:700>BYTE</span>	<span style=color:teal>$0x90</span>	<span style=color:#998;font-style:italic>// NOP
</span></span></span></code></pre></div><p>这还是个汇编函数，它接着调用 goexit1 函数、goexit0 函数，主要的功能就是将 goroutine 的各个字段清零，放入 gFree 队列里，等待将来进行复用。</p><p>另一方面，goexit 函数的地址是在创建 goroutine 的过程中，塞到栈上的。让 CPU “误以为”：<code>func()</code> 是由 goexit 函数调用的。这样一来，当 <code>func()</code> 执行完毕时，会返回到 goexit 函数做一些清理工作。</p><p>下面这张图能看出在 newg 的栈底塞了一个 goexit 函数的地址：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607084706.png><img class=mx-auto alt="goexit 返回地址" src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607084706.png></a></p><p>对应的路径是：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>newporc -&gt; newporc1 -&gt; gostartcallfn -&gt; gostartcall
</span></span></code></pre></div><p>来看 <code>newproc1</code> 中的关键几行代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>newg.sched.pc = <span style=color:#900;font-weight:700>funcPC</span>(goexit) <span style=color:#000;font-weight:700>+</span> sys.PCQuantum
</span></span><span style=display:flex><span>newg.sched.g = <span style=color:#900;font-weight:700>guintptr</span>(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(newg))
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>gostartcallfn</span>(<span style=color:#000;font-weight:700>&amp;</span>newg.sched, fn)
</span></span></code></pre></div><p>这里的 newg 就是创建的 goroutine，每个新建的 goroutine 都会执行这些代码。而 <code>sched</code> 结构体其实保存的是 goroutine 的执行现场，每当 goroutine 被调离 CPU，它的执行进度就是保存到这里。进度主要就是 SP、BP、PC，分别表示栈顶地址、栈底地址、指令位置，等 goroutine 再次得到 CPU 的执行权时，会把 SP、BP、PC 加载到寄存器中，从而从断点处恢复运行。</p><p>回到上面的几行代码，<code>pc</code> 被赋值成了 <code>funcPC(goexit)</code>，最后在 <code>gostartcall</code> 里：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// adjust Gobuf as if it executed a call to fn with context ctxt
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// and then did an immediate gosave.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>gostartcall</span>(buf <span style=color:#000;font-weight:700>*</span>gobuf, fn, ctxt unsafe.Pointer) {
</span></span><span style=display:flex><span>	sp <span style=color:#000;font-weight:700>:=</span> buf.sp
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>...</span>
</span></span><span style=display:flex><span>	sp <span style=color:#000;font-weight:700>-=</span> sys.PtrSize
</span></span><span style=display:flex><span>	<span style=color:#000;font-weight:700>*</span>(<span style=color:#000;font-weight:700>*</span><span style=color:#458;font-weight:700>uintptr</span>)(unsafe.<span style=color:#900;font-weight:700>Pointer</span>(sp)) = buf.pc
</span></span><span style=display:flex><span>	buf.sp = sp
</span></span><span style=display:flex><span>	buf.pc = <span style=color:#0086b3>uintptr</span>(fn)
</span></span><span style=display:flex><span>	buf.ctxt = ctxt
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>sp</code> 其实就是栈顶，第 7 行代码把 <code>buf.pc</code>，也就是 <code>goexit</code> 的地址，放在了栈顶的地方，熟悉 Go 函数调用规约的朋友知道，这个位置其实就是 <code>return addr</code>，将来等 <code>func()</code> 执行完，就会回到父函数继续执行，这里的父函数其实就是 <code>goexit</code>。</p><p>一切早已注定。</p><p>不过注意一点，<code>main goroutine</code> 和普通的 goroutine 不同的是，前者执行完用户 main 函数后，会直接执行 exit 调用，整个进程退出：</p><p><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607082923.png><img class=mx-auto alt=exit src=https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607082923.png></a></p><p>也就不会进入 goexit 函数。而普通 goroutine 执行完毕后，则直接进入 goexit 函数，做一些清理工作。</p><p>这也就是为什么只要 main goroutine 执行完了，就不会等其他 goroutine，直接退出。一切都是因为 <code>exit</code> 这个调用。</p><p>今天我们主要讲了 goexit 是怎么被安插到 goroutine 的栈上，从而实现 goroutine 执行完毕后再回到 goexit 函数。</p><p>原来看似很不理解的东西，是不是更清晰了？</p><p>源码面前，了无秘密。</p></div><div class=post-archive><ul class=post-copyright><li><strong>原文作者：</strong><a rel=author href=https://qcrao.com>饶全成</a></li><li style=word-break:break-all><strong>原文链接：</strong><a href=https://qcrao.com/post/where-is-goexit-from/>https://qcrao.com/post/where-is-goexit-from/</a></li><li><strong>版权声明：</strong>本作品采用<a rel=license href=https://creativecommons.org/licenses/by-nc-nd/4.0/>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li></ul></div><br></article><div class="post bg-white"><script src=https://utteranc.es/client.js repo=qcrao/blog_comments issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><footer id=footer><div>&copy; 2022 <a href=https://qcrao.com>qcrao 的博客 By 饶全成</a>
| <a rel=nofollow target=_blank href=http://beian.miit.gov.cn/>鄂ICP备20006251号-1</a></div><br><div><div class=github-badge><a href=https://gohugo.io/ target=_black rel=nofollow><span class=badge-subject>Powered by</span><span class="badge-value bg-blue">Hugo</span></a></div><div class=github-badge><a href=https://www.flysnow.org/ target=_black><span class=badge-subject>Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a></div><div class=github-badge><a href=https://github.com/flysnow-org/maupassant-hugo target=_black><span class=badge-subject>Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a></div></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[["$","$"]],processEscapes:!0}}</script><script src='//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script><script src=//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js></script>
<a id=rocket href=#top></a>
<script type=text/javascript src='/js/totop.js?v=0.0.0' async></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-144930666-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async></script>
<script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "15ed44493a8a4df682815ddf8c84ff23"}'></script></div><div id=secondary><section class=widget><form id=search action=https://qcrao.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://qcrao.com>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=https://qcrao.com/post/memory-leak-of-go-map/ title="Go map 竟然也会发生内存泄露？">Go map 竟然也会发生内存泄露？</a></li><li><a href=https://qcrao.com/post/what-is-upstream-downstream/ title="你说的下游是 upstream 吧？">你说的下游是 upstream 吧？</a></li><li><a href=https://qcrao.com/post/migrate-blog-to-cloudflare-pages/ title="将博客迁移到了 Cloudflare Pages">将博客迁移到了 Cloudflare Pages</a></li><li><a href=https://qcrao.com/post/blogs-written-by-xargin/ title=那些年曹大写的文章>那些年曹大写的文章</a></li><li><a href=https://qcrao.com/post/content-is-more-important/ title=最重要的是内容>最重要的是内容</a></li><li><a href=https://qcrao.com/post/look-up-go-doc-gracefully/ title="写 Go 时如何优雅地查文档">写 Go 时如何优雅地查文档</a></li><li><a href=https://qcrao.com/post/talk-about-map-extra-field/ title="曹大带我学 Go（11）—— 从 map 的 extra 字段谈起">曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</a></li><li><a href=https://qcrao.com/post/go-tls-pr-by-xargin/ title="曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr">曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</a></li><li><a href=https://qcrao.com/post/start-to-build-up-personal-tools/ title="曹大带我学 Go（9）—— 开始积累自己的工具库">曹大带我学 Go（9）—— 开始积累自己的工具库</a></li><li><a href=https://qcrao.com/post/accident-by-a-metric/ title="曹大带我学 Go（8）—— 一个 metrics 打点引发的事故">曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</a></li></ul></section><section class=widget><h3 class=widget-title>我写的书</h3><ul class=widget-list><li><a href=https://golang.design/go-questions/ title="《Go 程序员面试笔试宝典》" target=_blank style=color:red><img src=/book.png></a></li></ul></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.xargin.com/ title=曹大的博客>曹大的博客</a></li><li><a target=_blank href=https://eddycjy.com/ title=煎鱼的博客>煎鱼的博客</a></li><li><a target=_blank href=http://lessisbetter.site/ title=大彬的博客>大彬的博客</a></li><li><a target=_blank href=https://wujunze.com/ title="Panda 的博客">Panda 的博客</a></li><li><a target=_blank href=https://mytechshares.com/ title=董泽润>董泽润</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=https://qcrao.com/index.xml>文章 RSS</a></li></ul></section></div></div></div></div></body></html>