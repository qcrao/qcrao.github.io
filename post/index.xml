<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on qcrao 的博客</title><link>https://qcrao.com/post/</link><description>Recent content in Posts on qcrao 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 31 Jul 2022 18:56:00 +0800</lastBuildDate><atom:link href="https://qcrao.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>你说的下游是 upstream 吧？</title><link>https://qcrao.com/post/what-is-upstream-downstream/</link><pubDate>Sun, 31 Jul 2022 18:56:00 +0800</pubDate><guid>https://qcrao.com/post/what-is-upstream-downstream/</guid><description>工作中，有一些术语比较容易混淆，聊半天，最后发现双方对术语的理解不一致。这个时候用英文原本的表达或者换一种方式来表述能让沟通更顺畅。 像我们经常说的『上下游』便是经常发生混淆的一对名词。 以前，我经常说『梳理一下我们依赖的下游』，后来发现这种说法是错误的。正确的是：梳理一下我们依赖的</description></item><item><title>将博客迁移到了 Cloudflare Pages</title><link>https://qcrao.com/post/migrate-blog-to-cloudflare-pages/</link><pubDate>Tue, 19 Jul 2022 22:20:00 +0800</pubDate><guid>https://qcrao.com/post/migrate-blog-to-cloudflare-pages/</guid><description>上个月把博客从 hexo 迁移到了 hugo，博客数据、发布流程全部托管到 github。之后把之前写的一篇《那些年曹大写的文章》搬了过来，其他文章暂时下线了。 上周在折腾博客 css 的时候，aofei 说不如迁移到 Cloudflare，还能全球 cdn 加速。于是又动手迁移到 Cloudflare Pages，顺便又修改了一些 cs</description></item><item><title>那些年曹大写的文章</title><link>https://qcrao.com/post/blogs-written-by-xargin/</link><pubDate>Wed, 22 Jun 2022 09:37:00 +0800</pubDate><guid>https://qcrao.com/post/blogs-written-by-xargin/</guid><description>某天晚上看到曹大在群里指点江山，折服。感叹为何曹大如此渊博，遂决定从头到尾研读完他所有的博文。 前后共花了一个月的时间，今天终于读完了（2020-11-24~2020-12-26），总共 118 篇。从 15 年 10 月 31 日开始的第一篇，到今天，总共写了 5 年多的时间。基本上每半个月产出一篇，非常稳定</description></item><item><title>最重要的是内容</title><link>https://qcrao.com/post/content-is-more-important/</link><pubDate>Tue, 21 Jun 2022 22:00:00 +0800</pubDate><guid>https://qcrao.com/post/content-is-more-important/</guid><description>最近，看曹大依然在坚持固定频率发新的文章，非常佩服。今年是我写博客的第四年，因为各种原因，上半年基本没有发表新东西，非常惭愧。养成一个好习惯很难，破坏却很容易。 这次将博客改用 hugo 搭建。最早 qcrao.com 是用 hexo 在 mac 渲染，然后将 public 推到 github 上的 qcrao.github.io。坏外是需要在 mac 上安装一堆前</description></item><item><title>写 Go 时如何优雅地查文档</title><link>https://qcrao.com/post/look-up-go-doc-gracefully/</link><pubDate>Thu, 09 Sep 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/look-up-go-doc-gracefully/</guid><description>某天写代码时发现自己对 IDE 的依赖非常深，如果没了 Goland 就不会写代码了，心里为之一惊。 Goland 的自动补全功能已经是必需品了，只要打出相关的几个字符，不管是变量名还是函数调用，都能帮你直接补全。我们只需要往相应的位置填东西就行了。 进而又想到，当补全功能缺失或者暂时失灵的情况下，该如何快速地查出某</description></item><item><title>曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</title><link>https://qcrao.com/post/talk-about-map-extra-field/</link><pubDate>Sun, 08 Aug 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/talk-about-map-extra-field/</guid><description>熟悉 map 结构体的读者应该知道，hmap 由很多 bmap（bucket） 构成，每个 bmap 都保存了 8 个 key/value 对： 有时落在同一个 bmap 中的 key/value 太多了，超过了 8 个，就会由溢出 bmap 来承接，即 overflow bmap（后面我们叫它 bucket）。溢出的 bucket 和原来的 bucket 形成一个“拉链”。 对于这些 overflow 的 bucket，在 hmap 结构体和 bmap 结构</description></item><item><title>曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</title><link>https://qcrao.com/post/go-tls-pr-by-xargin/</link><pubDate>Tue, 03 Aug 2021 23:43:04 +0800</pubDate><guid>https://qcrao.com/post/go-tls-pr-by-xargin/</guid><description>之前写了一篇《成为 Go Contributor》 的文章，讲了如何给 Go 提一个 typo 的 pr，以此熟悉整个流程。当然，离真正的 Contributor 还差得远。 开课前曹大在 Go 夜读上讲了他给 Go 提的一个关于 tls 的性能优化，课上又细讲了下，本文就带大家来学习下他优化了啥以及如何看优化效果。 第一次提的 pr 在这里，之后又挪到了一</description></item><item><title>曹大带我学 Go（9）—— 开始积累自己的工具库</title><link>https://qcrao.com/post/start-to-build-up-personal-tools/</link><pubDate>Wed, 21 Jul 2021 23:42:31 +0800</pubDate><guid>https://qcrao.com/post/start-to-build-up-personal-tools/</guid><description>不知道你有没有这样的经验：看了很多计算机相关的书，觉得自己懂得很多，但是一遇到实际问题，就不会解。 再看身边的老司机，执行几行命令，看了几个指标，就准确地定位问题了。他可能也没看那么多理论，但实战能力确实强，心里一下子就失衡了。 这其中有很多原因，我认为其中有一个比较重要的就是：工具</description></item><item><title>曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</title><link>https://qcrao.com/post/accident-by-a-metric/</link><pubDate>Mon, 19 Jul 2021 23:28:24 +0800</pubDate><guid>https://qcrao.com/post/accident-by-a-metric/</guid><description>最近线上事故频发，搞得焦头烂额，但是能用上跟曹大学的知识并定位出了问题，还是值得高兴一把的。毕竟“打破砂锅问到底”，“定位出根因”一直是技术人的优良品质。 虽然我们总是逃不过事故驱动开发的魔咒，但吃一堑长一智，看别人的事故，学到的是自己的能力。 现象 一个平凡的午高峰，服务在全量上线的</description></item><item><title>曹大带我学 Go（7）—— 如何优雅地指定配置项</title><link>https://qcrao.com/post/how-to-use-functional-options-pattern/</link><pubDate>Thu, 15 Jul 2021 23:28:02 +0800</pubDate><guid>https://qcrao.com/post/how-to-use-functional-options-pattern/</guid><description>最近一个年久失修的库导致了线上事故，不得不去做一些改进。 这个陈年库的作用是调用第三方的 RPC 拿一些比较重要的配置，业务代码中有段逻辑会根据读到的配置调用不同端的下游。如果没拿到配置，就会默认地调一个兜底下游。恰好这个兜底下游最近新上了一些逻辑，不兼容这种跨端调用，直接把它打挂了。 先抛</description></item><item><title>曹大带我学 Go（6）—— 技术之外</title><link>https://qcrao.com/post/out-of-tech/</link><pubDate>Thu, 10 Jun 2021 00:10:07 +0800</pubDate><guid>https://qcrao.com/post/out-of-tech/</guid><description>这篇文章主要来讲一下怎么做动画。 其实只要掌握几个核心的要点，就可以学会怎么用 Figma 做动画了。 我们想一下小时候看的那种胶片电影： 每一张胶片上的影像都是静止的，但是当胶片连续滚动时，静止的图片就变成了连续的视频。 或者想像一下小时候我们看的那种武打的小人书，连着翻页，就能看到一个连续的打斗</description></item><item><title>曹大带我学 Go（5）—— 哪来里的 goexit？</title><link>https://qcrao.com/post/where-is-goexit-from/</link><pubDate>Mon, 07 Jun 2021 23:26:36 +0800</pubDate><guid>https://qcrao.com/post/where-is-goexit-from/</guid><description>有同学在用 dlv 调试时看到了令人不解的 goexit：goexit 函数是啥，为啥 go fun(){}() 的上层是它？看着像是一个“退出”函数，为什么会出现在最上层？ 其实如果看过 pprof 的火焰图，也会经常看到 goexit 这个函数。 我们来个例子重现一下： 1package main 2 3import &amp;#34;time&amp;#34; 4 5func main() { 6 go func () { 7 println(&amp;#34;hello world&amp;#34;) 8 }() 9 10 time.Sleep(10*time.Minute) 11} 启动 dlv 调试，并分别在不同的</description></item><item><title>曹大带我学 Go（4）—— 初始 ast 的威力</title><link>https://qcrao.com/post/getting-to-know-the-power-of-ast/</link><pubDate>Tue, 01 Jun 2021 23:26:17 +0800</pubDate><guid>https://qcrao.com/post/getting-to-know-the-power-of-ast/</guid><description>抽象语法树是编译过程中的一个中间产物，一般简单了解一下就行了。但我们可以把 Go 语言的整个 parser 和 ast 包直接拿来用，在一些场景下有很大的威力。 什么是 ast 呢，我从维基百科上摘录了一段： 在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代</description></item><item><title>曹大带我学 Go（3）—— 如何用汇编打同事的脸</title><link>https://qcrao.com/post/how-to-get-asm-code-of-go/</link><pubDate>Thu, 27 May 2021 23:21:54 +0800</pubDate><guid>https://qcrao.com/post/how-to-get-asm-code-of-go/</guid><description>今天介绍几个常用的查看 Go 汇编代码、调试 Go 程序的命令和工具，既可以在平时和同事、网友抬杠时使用，还能在关键时刻打他们的脸。 比如，有同事说这段代码： 1package main 2 3type Student struct { 4 Class int 5} 6 7func main() { 8 var a = &amp;amp;Student{1} 9 println(a) 10} 的执行效率要高于下面这段代码： 1package main 2 3type Student struct { 4 Class int 5} 6 7func main() { 8 var a = Student{1} 9 var b = &amp;amp;a 10 println(b) 11} 并且</description></item><item><title>曹大带我学 Go（2）—— 迷惑的 goroutine 执行顺序</title><link>https://qcrao.com/post/confusing-goroutine-running-orders/</link><pubDate>Fri, 21 May 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/confusing-goroutine-running-orders/</guid><description>上一篇文章我们讲了 Go 调度的本质是一个生产-消费流程。 生产端是正在运行的 goroutine 执行 go func(){}() 语句生产出 goroutine 并塞到三级队列中去。 消费端则是 Go 进程中的 m 在不断地执行调度循环，从三级队列中拿到 goroutine 来运行。 今天我们来通过 2 个实际的代码例子来看看 goroutine 的执行顺序是怎样的。 第一个例子 首先来看第一个例子： 1package main 2 3import</description></item><item><title>曹大带我学 Go（1）—— Go 调度的本质</title><link>https://qcrao.com/post/go-schedule-under-the-hood/</link><pubDate>Thu, 20 May 2021 08:13:00 +0800</pubDate><guid>https://qcrao.com/post/go-schedule-under-the-hood/</guid><description>首先抛出本文的结论：Go 调度的本质是一个生产-消费流程。 生产者-消费者模型 我们平时用 Go 最爽的一点莫过于用一句 go func(){}() 就启动了一个 goroutine 来并发地执行任务。这比用 C/C++ 启动一个线程并发地去执行任务方便太多。这句代码实际上就生产出了一个 goroutine，并进入可运行队列，等待 m 来找它从而可以得到</description></item></channel></rss>