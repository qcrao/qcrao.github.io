<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>深度阅读之《Mastering Go》 | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深度阅读之《Mastering Go》</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/readings/"><i class="fa fa-book"> 阅读</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深度阅读之《Mastering Go》</h1><div class="post-meta">Apr 19, 2021<span> | </span><span class="category"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>写在前面：这本书前前后后花了挺长时间，去年 11 月份就开始读了，中间又断了，直到最近才捡起来看完。</p>
<p>本书讲得内容非常全面，语言也很顺畅，生词非常少，并且内容没有太大难度，看起来比较过瘾，算是全面复习一下 Go 语言。如果你想开始练习阅读英文书，这本将是一个非常好的开始。</p>
<p>下面是阅读过程中记录的一些有用的点，随意看看就好。</p>
<hr>
<ol>
<li><p>Go 有很多优点，其中一点是没有预编译阶段，这使得它的编译速度更快。像 C 语中，以 # 开头的会被预编译器处理。有预编译器的语言有：C, C++, Ada, and PL/SQL。预编译器的一大缺点是它会修改源代码，而人们不知道送到编译器里的最终的代码是什么。</p>
</li>
<li><p>可以直接在命令行执行 <code>go doc strings.Fields</code> 获取库函数的解释；执行 <code>go get golang.org/x/tools/cmd/godoc</code> 会安装 godoc 工具，注意这两者是不同的。前者是 go 命令，后者则是 godoc 命令。执行 <code>godoc -http :8080</code> 可以启动一个 server，访问 <code>http://localhost:8080/pkg/</code> 即可看到 Go 的文档。</p>
</li>
<li><p>执行 <code>go build</code> 会显示生成一个可执行文件，仅仅一个 hello_world 就会达到 2M 大小，这是因为 Go 是静态链接，生成的文件可以直接执行，不需要再动态链接其他文件。而执行 <code>go run</code> 命令，虽然也会生成可执行文件，但是它是隐式的，之后当程序执行完后会被自动删掉。注意，看不见并不等于不存在！</p>
</li>
<li><p>所有的 UNIX 系统都支持：<code>/dev/stdin</code>、<code>/dev/stdout</code>、<code>/dev/stderr</code> 这三个特殊的文件名，它们也可以用 0、1、2 号文件描述符来描述。</p>
</li>
<li><p>fmt.Println(), fmt.Print(), and fmt.Printf() 用于打印，fmt.Sprintln(), fmt.Sprint(), fmt.Sprintf() 用于生成字符串，fmt.Fprintln(), fmt.Fprint(), fmt.Fprintf() 用于写文件。</p>
</li>
<li><p>短赋值符 <code>:=</code> 不能用于函数之外，因此全局变量只能用 <code>var</code> 声明。</p>
</li>
<li><p>下面的代码用于从标准输入读取数据，每读出一行就打印出来：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line">	f = os.Stdin</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	scanner := bufio.NewScanner(f)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&gt;"</span>, scanner.Text())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按 ctrl+D 退出循环，因为 ctrl+D 会告知程序没有更多的数据可以读取。</p>
<ol start="8">
<li><code>os.Args</code> 可以记录通过命令行输入的参数，并且它的类型是 []string，第一个元素是程序名，之后的为输入参数。例如：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run a.<span class="keyword">go</span> <span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>os.Args</code> 为 <code>[/tmp/go-build059507490/b001/exe/cla 10 1]</code></p>
<ol start="9">
<li>关于 docker 的命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 根据 tag 创建</span><br><span class="line">docker build -t go_hw:v1 .</span><br><span class="line"></span><br><span class="line"># 列出所有的 docker images</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line">docker run go_hw:v1</span><br><span class="line"></span><br><span class="line"># 删除（-f 强制删除）</span><br><span class="line">docker rmi 5a0d2473aa96 f56365ec0638</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><p>关于 Go 的垃圾回收算法：并发标记清除、非分代、非整理，使用写屏障。</p>
</li>
<li><p>Go 为了降低 GC 的停顿时间，让 GC 和用户程序并发执行。为了让三色标记的结果不受并发执行的程序的影响，在整个标记过程中，要确保一个不变性：黑色集合里的对象保证不会指向白色集合里的对象，注意这并不影响一个白色对象指向黑色对象。我们把用户程序称为 mutator，mutator 运行了一个 writer barrier，每次当堆上有对象的指针（如果是对象的非指针字段变化，不影响）发生了变化，说明此对象可达，就要运行 writer barrier，将它变成灰色。mutator 通过 writer barrier 保证“黑色集合里的对象保证不会指向白色集合里的对象”这一不变性。这会带来性能的损耗，但这是并发执行用户程序和 GC 的代价。</p>
</li>
<li><p>垃圾回收器会在 channel 不可达时回收它，即使 channel 还未关闭。</p>
</li>
<li><p><code>time go run xx.go</code> 可以计算运行程序花费的时间。</p>
</li>
<li><p>Please remember that at the end of the day, all programs that work on UNIX machines end up using C system calls to communicate with the UNIX kernel and perform most of their tasks. 所有在 UNIX 系统上运行的程序最终都会通过 C 系统调用来和内核打交道。用其他语言编写程序进行系统调用，方法不外乎两个：一是自己封装，二是依赖 glibc、或者其他的运行库。Go 语言选择了前者，把系统调用都封装到了 syscall 包。封装时也同样得通过汇编实现。</p>
</li>
<li><p><code>strace ls</code> 查看都有哪些系统调用，<code>-c</code> 可以计数。</p>
</li>
<li><p>将 .go 文件转化成汇编代码时，可指定操作系统和架构：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者等价</span></span><br><span class="line">GOOS=darwin GOARCH=amd64 go tool compile -S goEnv.go</span><br><span class="line">GOOS=darwin GOARCH=amd64 go build -gcflags -S goEnv.go</span><br></pre></td></tr></table></figure>

<p>GOOS 和 GOARCH 可选项为：The list of valid GOOS values includes android, darwin, dragonfly, freebsd, linux, nacl, netbsd, openbsd, plan9, solaris, windows, and zos. On the other hand, the list of valid GOARCH values includes 386, amd64, amd64p32, arm, armbe, arm64, arm64be, ppc64, ppc64le, mips, mipsle, mips64, mips64le, mips64p32, mips64p32le, ppc, s390, s390x, sparc, and sparc64.</p>
<ol start="16">
<li><p><code>go build -x defer.go</code> 展示 build 过程。</p>
</li>
<li><p>数组可以用 “:” 变成切片：array4[0:] 或 array4[:]，copy 函数只接收切片作为参数。</p>
</li>
<li><p>什么时候使用指针：1. 可以 share data，尤其是在函数之间；2. 区别某个变量是未设置还是真的零值。</p>
</li>
<li><p>关于 strings 有很多有意思的方法，例如 Repeat, Fields 等等，在<a href="https://github.com/PacktPublishing/Mastering-Go-Second-Edition/blob/master/ch04/useStrings.go" target="_blank" rel="noopener">这里</a>可以看到很多。</p>
</li>
<li><p>Go container 包有 heap/list/ring 这几个组件。</p>
</li>
<li><p><code>math/rand</code> 可用于生成伪随机数；更安全的生成随机数：<code>crypto/rand</code>。</p>
</li>
<li><p>关于可变参数的函数（A variadic function），<code>...Type</code> 称为 pack operator，而 <code>Slice...</code> 则被称为 unpack operator。一个可变参数的函数只能使用一次 pack operator。</p>
</li>
<li><p>安装一个本地包：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/go/src/aPackage</span><br><span class="line">$ cp aPackage.go ~/go/src/aPackage/</span><br><span class="line">$ go install aPackage</span><br><span class="line">$ <span class="built_in">cd</span> ~/go/pkg/darwin_amd64/</span><br><span class="line">$ ls -l aPackage.a</span><br><span class="line">-rw-r--r-- 1 mtsouk staff 4980 Dec 22 06:12 aPackage.a</span><br></pre></td></tr></table></figure>

<p>编译一个本地包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile aPackage.go</span><br><span class="line">$ ls -l aPackage.*</span><br><span class="line">-rw-r--r--@ 1 mtsouk staff 201 Jan 10 22:08 aPackage.go -rw-r--r-- 1 mtsouk staff 16316 Mar 4 20:01 aPackage.o</span><br></pre></td></tr></table></figure>

<ol start="24">
<li><p>关于 Go 版本，例如 v1.2.3，v1/v2/v3 通常是不兼容的，<code>1</code> 表示大版本，<code>2</code> 表示 feature，<code>3</code> 表示 fix。</p>
</li>
<li><p>如何和 gomod 工作：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init</span><br><span class="line">go: creating new go.mod: module github.com/mactsouk/myModule </span><br><span class="line">$ touch myModule.go</span><br><span class="line">$ vi myModule.go</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m <span class="string">"Initial version 1.0.0"</span></span><br><span class="line">$ git push</span><br><span class="line">$ git tag v1.0.0</span><br><span class="line">$ git push -q origin v1.0.0</span><br><span class="line">$ go list</span><br><span class="line">github.com/mactsouk/myModule</span><br><span class="line">$ go list -m</span><br><span class="line">github.com/mactsouk/myModule</span><br></pre></td></tr></table></figure>

<ol start="26">
<li>创建 v2 版本：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">"using v2.0.0"</span></span><br><span class="line">git tag v2.0.0</span><br><span class="line">git push --tags origin v2</span><br><span class="line">git --no-pager branch -a</span><br></pre></td></tr></table></figure>

<ol start="27">
<li>使用 go mod vendor 命令来将依赖放到 vendor 文件夹里：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init useV1V2</span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>

<ol start="28">
<li>查找哪些 go 源文件使用了 syscall：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep \"syscall\" `find /usr/<span class="built_in">local</span>/go/src -name <span class="string">"*.go"</span>`</span><br></pre></td></tr></table></figure>

<ol start="29">
<li><p>要记住的是在绝大部分程序里不需要使用反射，所以我们得弄清楚为什么反射是必须的以及什么时候需要使用反射。反射在实现 fmt, text/template, html/template 时是必须的。例如在 fmt 包里，反射可以让你不需要明确处理所有的类型，你当然可以明确处理你知道的所有类型，但你仍然不可能处理 All possible types。</p>
</li>
<li><p>什么时候用反射：Therefore, you might need to use reflection when you want to be as generic as possible or when you want to make sure that you will be able to deal with data types that do not exist at the time of writing your code but might exist in the future. Additionally, reflection is handy when working with values of types that do not implement a common interface.</p>
</li>
<li><p>反射不好的三点：a. 大量的反射会造成程序代码难以理解和维护。一个可行的解决方法是清晰的文档注释，但众所周知，程序员是最不愿意写文档的人；b. 相比正常的数据结构，反射是动态地“决定”数据结构，因此会更慢。这些动态代码也会使得一些代码工具更难执行重构和分析；c. 反射的错误在 build 期间不会被捕获，很多都是在运行期间直接 crash 整个程序。而且这经常是在程序正常运行数月甚至是数年之后才会爆发。一个可行的办法是大量的测试，但这也不太可能覆盖完全，并且会让代码库更加庞大。</p>
</li>
<li><p>Go 不是一门面向对象的语言，但它可以模拟面向对象语言的某些功能。</p>
</li>
<li><p>flag.var 可以解析用逗号分隔的多个值。</p>
</li>
<li><p><code>wc</code> 命令的结果有三列，分别表示行数、word 数，以及字节数。平时用的最多的是 <code>wc -l</code>，表示行数；<code>wc -w</code> 表示 wrod 数；<code>wc -c</code> 表示字节数。</p>
</li>
<li><p>如何输出一个文件的权限，上代码：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arguments := os.Args</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arguments) == <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"usage: permissions filename\n"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename := arguments[<span class="number">1</span>]</span><br><span class="line">	info, _ := os.Stat(filename)</span><br><span class="line">	mode := info.Mode()</span><br><span class="line">	fmt.Println(filename, <span class="string">"mode is"</span>, mode.String()[<span class="number">1</span>:<span class="number">10</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="36">
<li><p><code>crtl+C</code> 向进程发送 SIGINT 信号。Unix 里的信号其实都是软中断，用来异步处理“事件”，信号可以通过 name 和 number 来识别。进程不可能处理所有类型的信号，有些信号不能被 caught，不能被 blocked，例如 SIGKILL、SIGSTOP 不能被 caught，不能被 blocked，也不能被 ignored。因为它们给内核和 root 用户提供了特权，可以停止运行某些进程。一般我们建议用信号的 name 来操作，例如 <code>kill -s INT pid</code>。有个例外的是 SIGKILL，它对应的 number 是 9，例如我们经常执行 <code>kill -9 pid</code> 来杀死某个进程，它等价于 <code>kill -s KILL pid</code>。</p>
</li>
<li><p>最常用来发送信号的方式用 kill 命令，默认发送的是 SIGTERM 信号。<code>kill -l</code> 命令可以列出所有支持的信号。</p>
</li>
<li><p><code>go run -race xx.go</code> 可以显示有竞争冲突的代码。</p>
</li>
<li><p><code>diff pipeline.go plNoRace.go --color</code> 显示两个文件的 diff。</p>
</li>
<li><p>Go 语言的并发模型是 fork-join 型的。使用 go 关键字启动子协程工作，使用 sync.Wait 和 channel 来收集结果。</p>
</li>
<li><p>可通过设置环境变量来改变 runtime.GOMAXPROCS(0) 的输出值：<code>export GOMAXPROCS=800;</code>。</p>
</li>
<li><p>sync.RWMutex 结构体里包含 sync.Mutex，即“读写锁”是在“锁”的基本上实现的。只有当所的读锁都 Unlock 了，写锁才能被 Lock。</p>
</li>
<li><p><code>time go run xx.go</code> 可以显示执行时间，包括 real, sys, user 的执行时间。</p>
</li>
<li><p>如果子 context 取消了，父 context 没有收到消息，那么在父 context 取消前就发生了内存泄露。</p>
<blockquote>
<p>For garbage collection to work correctly, the parent goroutine needs to keep a reference to each child goroutine. If a child goroutine ends without the parent knowing about it, then a memory leak occurs until the parent is canceled as well.</p>
</blockquote>
</li>
<li><p>TAOCP——《计算机程序设计艺术》的作者高德纳（Donald Ervin Knuth）老爷子的一句经典的话：</p>
<blockquote>
<p>“The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.”</p>
</blockquote>
</li>
</ol>
<p>告诉我们不要老想着性能优化，在真的出现问题、出现瓶颈的时候再来考虑。</p>
<p>还有 Erlang 的作者之一 Joe Armstrong：</p>
<blockquote>
<p>“Make it work, then make it beautiful, then if you really, really have to, make it fast. 90 percent of the time, if you make it beautiful, it will already be fast. So really, just make it beautiful!”</p>
</blockquote>
<p>这告诉我们性能优化并不是主要工作，我们不要花费大量精力在这上面。</p>
<ol start="46">
<li><p>做优化的前提是程序没有 bug，所以如果你在程序的第一版就来优化是有问题的，因为 v1 版本可能经常有 bug。</p>
</li>
<li><p>交叉编译命令：<code>env GOOS=linux GOARCH=386 go build xCompile.go</code>。指定操作系统、指令集。</p>
</li>
<li><p>通过 <a href="https://golang.org/pkg/bytes/" target="_blank" rel="noopener">bytes 包</a>的例子，可以看懂 godoc 和<a href="https://golang.org/src/bytes/bytes.go" target="_blank" rel="noopener">源码</a>里的 comments 的对应关系。<code>pkg/bytes</code> 文档里有很多代码样例，还可以 run 一下，但其实这些样例是写死在源码里的，就在 <code>src/bytes/example_test.go</code> 文件里。一开始没发现这个文件，我直接拿样例代码全局搜，一下就找到了。例如，源码写的如下两个 example：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleToTitleSpecial</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := []<span class="keyword">byte</span>(<span class="string">"ahoj vývojári golang"</span>)</span><br><span class="line">	totitle := bytes.ToTitleSpecial(unicode.AzeriCase, str)</span><br><span class="line">	fmt.Println(<span class="string">"Original : "</span> + <span class="keyword">string</span>(str))</span><br><span class="line">	fmt.Println(<span class="string">"ToTitle : "</span> + <span class="keyword">string</span>(totitle))</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// Original : ahoj vývojári golang</span></span><br><span class="line">	<span class="comment">// ToTitle : AHOJ VÝVOJÁRİ GOLANG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://golang.org/pkg" target="_blank" rel="noopener">pkg</a> 上，就对应这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210416085739.png" alt="go pkg example"></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2021/04/19/mastering-go-reading-notes/">https://qcrao.com/2021/04/19/mastering-go-reading-notes/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2021/05/12/diving-into-preempt-by-signal/">深度解密 Go 语言之基于信号的抢占式调度</a><a class="next" href="/2021/03/30/become-a-go-typo-contributor/">喜提 Go Contributor</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://qcrao.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B1%82%E8%81%8C/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/%E7%89%9B%E4%BA%BA/" style="font-size: 15px;">牛人</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">协议</a> <a href="/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/" style="font-size: 15px;">故障排查</a> <a href="/tags/%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92/" style="font-size: 15px;">内存重排</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 15px;">编译原理</a> <a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 15px;">简历</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 15px;">小技巧</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/09/11/look-up-go-doc-gracefully/">写 Go 时如何优雅地查文档</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/09/talk-about-map-extra-field/">从 map 的 extra 字段谈起</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/03/go-tls-pr-by-xargin/">如何给 Go 提性能优化的 pr</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/21/start-to-build-up-personal-tools/">开始积累自己的工具库</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/19/accident-by-a-metric/">一个 metrics 打点引发的事故</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/15/how-to-use-functional-options-pattern/">如何优雅地指定配置项</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/10/out-of-tech/">技术之外</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/07/where-is-goexit-from/">哪来里的 goexit？</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/01/getting-to-know-the-power-of-ast/">初始 ast 的威力</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/27/how-to-get-asm-code-of-go/">如何用汇编打同事的脸</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://blog.changkun.de/" title="欧神" target="_blank">欧神</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="Panda - Just for fun" target="_blank">Panda - Just for fun</a><ul></ul><a href="https://mytechshares.com/" title="董泽润" target="_blank">董泽润</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://beian.miit.gov.cn"> 鄂ICP备20006251号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>