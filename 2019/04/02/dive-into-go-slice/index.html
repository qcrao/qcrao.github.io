<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>深度解密Go语言之slice | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深度解密Go语言之slice</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深度解密Go语言之slice</h1><div class="post-meta">Apr 2, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 31</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#当我们在说-slice-时，到底在说什么"><span class="toc-number">1.</span> <span class="toc-text">当我们在说 slice 时，到底在说什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#slice-的创建"><span class="toc-number">2.</span> <span class="toc-text">slice 的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接声明"><span class="toc-number">2.1.</span> <span class="toc-text">直接声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字面量"><span class="toc-number">2.2.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#make"><span class="toc-number">2.3.</span> <span class="toc-text">make</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#截取"><span class="toc-number">2.4.</span> <span class="toc-text">截取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#slice-和数组的区别在哪"><span class="toc-number">3.</span> <span class="toc-text">slice 和数组的区别在哪</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#append-到底做了什么"><span class="toc-number">4.</span> <span class="toc-text">append 到底做了什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么-nil-slice-可以直接-append"><span class="toc-number">5.</span> <span class="toc-text">为什么 nil slice 可以直接 append</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#传-slice-和-slice-指针有什么区别"><span class="toc-number">6.</span> <span class="toc-text">传 slice 和 slice 指针有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>Go 语言的 <code>slice</code> 很好用，不过也有一些坑。<code>slice</code> 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它。而且在我写这篇文章的过程中，发现绝大部分文章都存在一些问题，文章里会讲到，这里先不展开。</p>
<p>我希望本文可以终结这个话题，下次再有人想和你讨论 <code>slice</code>，直接把这篇文章的链接丢过去就行了。</p>
<h1 id="当我们在说-slice-时，到底在说什么"><a href="#当我们在说-slice-时，到底在说什么" class="headerlink" title="当我们在说 slice 时，到底在说什么"></a>当我们在说 slice 时，到底在说什么</h1><p><code>slice</code> 翻译成中文就是<code>切片</code>，它和<code>数组（array）</code>很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。</p>
<p>了解 slice 的本质，最简单的方法就是看它的源代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗，<code>slice</code> 共有三个属性：<br><code>指针</code>，指向底层数组；<br><code>长度</code>，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；<br><code>容量</code>，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/55270142-876c2000-52d6-11e9-99e5-2e921fc2d430.png" alt="切片数据结构"></p>
<p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p>
<h1 id="slice-的创建"><a href="#slice-的创建" class="headerlink" title="slice 的创建"></a>slice 的创建</h1><p>创建 slice 的方式有以下几种：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方式</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>直接声明</td>
<td><code>var slice []int</code></td>
</tr>
<tr>
<td>2</td>
<td>new</td>
<td><code>slice := *new([]int)</code></td>
</tr>
<tr>
<td>3</td>
<td>字面量</td>
<td><code>slice := []int{1,2,3,4,5}</code></td>
</tr>
<tr>
<td>4</td>
<td>make</td>
<td><code>slice := make([]int, 5, 10)</code></td>
</tr>
<tr>
<td>5</td>
<td>从切片或数组“截取”</td>
<td><code>slice := array[1:5]</code> 或 <code>slice := sourceSlice[1:5]</code></td>
</tr>
</tbody></table>
<h2 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h2><p>第一种创建出来的 slice 其实是一个 <code>nil slice</code>。它的长度和容量都为0。和<code>nil</code>比较的结果为<code>true</code>。</p>
<p>这里比较混淆的是<code>empty slice</code>，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 <code>0xc42003bda0</code>。空切片和 <code>nil</code> 比较的结果为<code>false</code>。</p>
<p>它们的内部结构如下图：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54864985-ac720780-4d99-11e9-8386-68ef68880c8d.png" alt="nil slice 与 empty slice"></p>
<table>
<thead>
<tr>
<th>创建方式</th>
<th>nil切片</th>
<th>空切片</th>
</tr>
</thead>
<tbody><tr>
<td>方式一</td>
<td>var s1 []int</td>
<td>var s2 = []int{}</td>
</tr>
<tr>
<td>方式二</td>
<td>var s4 = *new([]int)</td>
<td>var s3 = make([]int, 0)</td>
</tr>
<tr>
<td>长度</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>容量</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>和 <code>nil</code> 比较</td>
<td><code>true</code></td>
<td><code>false</code></td>
</tr>
</tbody></table>
<p><code>nil</code> 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p>
<p>关于<code>nil slice</code>和<code>empty slice</code>的探索可以参考公众号“码洞”作者老钱写的一篇文章《深度解析 Go 语言中「切片」的三种特殊状态》，地址附在了参考资料部分。</p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>比较简单，直接用<code>初始化表达式</code>创建。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>: <span class="number">100</span>&#125;</span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 0 0 0 0 100] 9 9</span><br></pre></td></tr></table></figure>

<p>唯一值得注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 <code>0 值</code>。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p><code>make</code>函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。</p>
<p>上篇文章<a href="https://www.cnblogs.com/qcrao-2018/p/10562216.html" target="_blank" rel="noopener">《走进Go的底层》</a>中，我们学到了汇编这个工具，这次我们再次请出汇编来更深入地看看<code>slice</code>。如果没看过上篇文章，建议先回去看完，再继续阅读本文效果更佳。</p>
<p>先来一小段玩具代码，使用 <code>make</code> 关键字创建 <code>slice</code>：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 长度为5，容量为10</span></span><br><span class="line">	slice[<span class="number">2</span>] = <span class="number">2</span> <span class="comment">// 索引为2的元素赋值为2</span></span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下命令，得到 Go 汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>

<p>我们只关注main函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:5)TEXT    &quot;&quot;.main(SB), $96-0</span><br><span class="line">0x0000 00000 (main.go:5)MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (main.go:5)CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (main.go:5)JLS     228</span><br><span class="line">0x0013 00019 (main.go:5)SUBQ    $96, SP</span><br><span class="line">0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)</span><br><span class="line">0x001c 00028 (main.go:5)LEAQ    88(SP), BP</span><br><span class="line">0x0021 00033 (main.go:5)FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (main.go:5)FUNCDATA    $1, gclocals·57cc5e9a024203768cbab1c731570886(SB)</span><br><span class="line">0x0021 00033 (main.go:5)LEAQ    type.int(SB), AX</span><br><span class="line">0x0028 00040 (main.go:6)MOVQ    AX, (SP)</span><br><span class="line">0x002c 00044 (main.go:6)MOVQ    $5, 8(SP)</span><br><span class="line">0x0035 00053 (main.go:6)MOVQ    $10, 16(SP)</span><br><span class="line">0x003e 00062 (main.go:6)PCDATA  $0, $0</span><br><span class="line">0x003e 00062 (main.go:6)CALL    runtime.makeslice(SB)</span><br><span class="line">0x0043 00067 (main.go:6)MOVQ    24(SP), AX</span><br><span class="line">0x0048 00072 (main.go:6)MOVQ    32(SP), CX</span><br><span class="line">0x004d 00077 (main.go:6)MOVQ    40(SP), DX</span><br><span class="line">0x0052 00082 (main.go:7)CMPQ    CX, $2</span><br><span class="line">0x0056 00086 (main.go:7)JLS     221</span><br><span class="line">0x005c 00092 (main.go:7)MOVQ    $2, 16(AX)</span><br><span class="line">0x0064 00100 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_2+72(SP)</span><br><span class="line">0x006e 00110 (main.go:8)MOVQ    DX, &quot;&quot;..autotmp_2+80(SP)</span><br><span class="line">0x0073 00115 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x007c 00124 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+56(SP)</span><br><span class="line">0x0085 00133 (main.go:8)LEAQ    type.[]int(SB), AX</span><br><span class="line">0x008c 00140 (main.go:8)MOVQ    AX, (SP)</span><br><span class="line">0x0090 00144 (main.go:8)LEAQ    &quot;&quot;..autotmp_2+64(SP), AX</span><br><span class="line">0x0095 00149 (main.go:8)MOVQ    AX, 8(SP)</span><br><span class="line">0x009a 00154 (main.go:8)PCDATA  $0, $1</span><br><span class="line">0x009a 00154 (main.go:8)CALL    runtime.convT2Eslice(SB)</span><br><span class="line">0x009f 00159 (main.go:8)MOVQ    16(SP), AX</span><br><span class="line">0x00a4 00164 (main.go:8)MOVQ    24(SP), CX</span><br><span class="line">0x00a9 00169 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x00ae 00174 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_1+56(SP)</span><br><span class="line">0x00b3 00179 (main.go:8)LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x00b8 00184 (main.go:8)MOVQ    AX, (SP)</span><br><span class="line">0x00bc 00188 (main.go:8)MOVQ    $1, 8(SP)</span><br><span class="line">0x00c5 00197 (main.go:8)MOVQ    $1, 16(SP)</span><br><span class="line">0x00ce 00206 (main.go:8)PCDATA  $0, $1</span><br><span class="line">0x00ce 00206 (main.go:8)CALL    fmt.Println(SB)</span><br><span class="line">0x00d3 00211 (main.go:9)MOVQ    88(SP), BP</span><br><span class="line">0x00d8 00216 (main.go:9)ADDQ    $96, SP</span><br><span class="line">0x00dc 00220 (main.go:9)RET</span><br><span class="line">0x00dd 00221 (main.go:7)PCDATA  $0, $0</span><br><span class="line">0x00dd 00221 (main.go:7)CALL    runtime.panicindex(SB)</span><br><span class="line">0x00e2 00226 (main.go:7)UNDEF</span><br><span class="line">0x00e4 00228 (main.go:7)NOP</span><br><span class="line">0x00e4 00228 (main.go:5)PCDATA  $0, $-1</span><br><span class="line">0x00e4 00228 (main.go:5)CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00e9 00233 (main.go:5)JMP     0</span><br></pre></td></tr></table></figure>

<p>先说明一下，Go 语言汇编 <code>FUNCDATA</code> 和 <code>PCDATA</code> 是编译器产生的，用于保存一些和垃圾收集相关的信息，我们先不用 care。</p>
<p>以上汇编代码行数比较多，没关系，因为命令都比较简单，而且我们的 Go 源码也足够简单，没有理由看不明白。</p>
<p>我们先从上到下扫一眼，看到几个关键函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CALL    runtime.makeslice(SB)</span><br><span class="line">CALL    runtime.convT2Eslice(SB)</span><br><span class="line">CALL    fmt.Println(SB)</span><br><span class="line">CALL    runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>创建slice</td>
</tr>
<tr>
<td>2</td>
<td>类型转换</td>
</tr>
<tr>
<td>3</td>
<td>打印函数</td>
</tr>
<tr>
<td>4</td>
<td>栈空间扩容</td>
</tr>
</tbody></table>
<p><code>1</code>是创建 slice 相关的；<code>2</code>是类型转换；调用 <code>fmt.Println</code>需要将 slice 作一个转换； <code>3</code>是打印语句；<code>4</code>是栈空间扩容函数，在函数开始处，会检查当前栈空间是否足够，不够的话需要调用它来进行扩容。暂时可以忽略。</p>
<p>调用了函数就会涉及到参数传递，Go 的参数传递都是通过 栈空间完成的。接下来，我们详细分析这整个过程。</p>
<table>
<thead>
<tr>
<th>行数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>main</code>函数定义，栈帧大小为 <code>96B</code></td>
</tr>
<tr>
<td>2-4</td>
<td>判断栈是否需要进行扩容，如果需要则跳到 <code>228</code>，这里会调用 <code>runtime.morestack_noctxt(SB)</code> 进行栈扩容操作。具体细节后续还会有文章来讲</td>
</tr>
<tr>
<td>5-9</td>
<td>将 <code>caller BP</code> 压栈，具体细节后面会讲到</td>
</tr>
<tr>
<td>10-15</td>
<td>调用 <code>runtime.makeslice(SB)</code> 函数及准备工作。*_type表示的是 <code>int</code>，也就是 <code>slice</code> 元素的类型。这里对应的源码是第6行，也就是调用 <code>make</code> 创建 <code>slice</code> 的那一行。<code>5</code> 和 <code>10</code> 分别代表长度和容量，函数参数会在栈顶准备好，之后执行函数调用命令 <code>CALL</code>，进入到被调用函数的栈帧，就会按顺序从 <code>caller</code> 的栈顶取函数参数</td>
</tr>
<tr>
<td>16-18</td>
<td>接收 <code>makeslice</code>的返回值，通过 <code>move</code> 移动到寄存器中</td>
</tr>
<tr>
<td>19-21</td>
<td>给数组索引值为 <code>2</code> 的元素赋上值 <code>2</code>，因为是 <code>int</code> 型的 <code>slice</code>，元素大小为8字节，所以 <code>MOVQ $2, 16(AX)</code> 此命令就是将 <code>2</code> 搬到索引为 <code>2</code> 的位置。这里还会对索引值的大小进行检查，如果越界，则会跳转到 <code>221</code>，执行 <code>panic</code> 函数</td>
</tr>
<tr>
<td>22-26</td>
<td>分别通过寄存器 <code>AX，CX，DX</code> 将 <code>makeslice</code> 的返回值 <code>move</code> 到内存的其他位置，也称为局部变量，这样就构造出了 <code>slice</code></td>
</tr>
</tbody></table>
<p><img src="https://user-images.githubusercontent.com/7698088/54982728-5fcf3c00-4fe6-11e9-819b-9c5b45cc93bf.png" alt="makeslice 栈帧"></p>
<p>左边是栈上的数据，右边是堆上的数据。<code>array</code> 指向 <code>slice</code> 的底层数据，被分配到堆上了。注意，栈上的地址是从高向低增长；堆则从低向高增长。栈左边的数字表示对应的汇编代码的行数，栈右边箭头则表示栈地址。（48）SP、（56）SP 表示的内容接着往下看。</p>
<p>注意，在图中，栈地址是从下往上增长，所以 SP 表示的是图中 <code>*_type</code> 所在的位置，其它的依此类推。</p>
<table>
<thead>
<tr>
<th>行数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>27-32</td>
<td>准备调用 <code>runtime.convT2Eslice(SB)</code>的函数参数</td>
</tr>
<tr>
<td>33-36</td>
<td>接收返回值，通过AX，CX寄存器 <code>move</code> 到(48)SP、（56）SP</td>
</tr>
</tbody></table>
<p><code>convT2Eslice</code> 的函数声明如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2Eslice</span><span class="params">(t *_type, elem unsafe.Pointer)</span> <span class="params">(e eface)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个参数是指针 <code>*_type</code>，<code>_type</code>是一个表示类型的结构体，这里传入的就是 <code>slice</code>的类型 <code>[]int</code>；第二个参数则是元素的指针，这里传入的就是 <code>slice</code> 底层数组的首地址。</p>
<p>返回值 <code>eface</code> 的结构体定义如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们会调用 <code>fmt.Println(slice)</code>，看下函数原型：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Println</code> 接收 interface 类型，因此我们需要将 <code>slice</code> 转换成 interface 类型。由于 <code>slice</code> 没有方法，是个“<code>空 interface</code>”。因此会调用 <code>convT2Eslice</code> 完成这一转换过程。</p>
<p><code>convT2Eslice</code> 函数返回的是类型指针和数据地址。源码就不贴了，大体流程是：调用 <code>mallocgc</code> 分配一块内存，把数据 <code>copy</code> 进到新的内存，然后返回这块内存的地址，<code>*_type</code> 则直接返回传入的参数。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/55271648-2d298a00-52eb-11e9-9dd0-e1bcc1fe33d0.png" alt="convT2Eslice 栈帧"></p>
<p><code>32(SP)</code> 和 <code>40(SP)</code> 其实是 <code>makeslice</code> 函数的返回值，这里可以忽略。</p>
<p>还剩 <code>fmt.Println(slice)</code> 最后一个函数调用了，我们继续。</p>
<table>
<thead>
<tr>
<th>行数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>37-40</td>
<td>准备 <code>Println</code> 函数参数。共3个参数，第一个是类型地址，还有两个 <code>1</code>，这块暂时还不知道为什么要传，有了解的同学可以在文章后面留言</td>
</tr>
</tbody></table>
<p>所以调用 <code>fmt.Println(slice)</code> 时，实际是传入了一个 <code>slice类型的eface地址</code>。这样，<code>Println</code>就可以访问类型中的数据，最终给“打印”出来。 </p>
<p><img src="https://user-images.githubusercontent.com/7698088/55271702-1f283900-52ec-11e9-9d3f-d8eb754ef23c.png" alt="fmt.Println 栈帧"></p>
<p>最后，我们看下 <code>main</code> 函数栈帧的开始和收尾部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0013 00019 (main.go:5)SUBQ    $96, SP</span><br><span class="line">0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)</span><br><span class="line">0x001c 00028 (main.go:5)LEAQ    88(SP), BP</span><br><span class="line">…………………………</span><br><span class="line">0x00d3 00211 (main.go:9)MOVQ    88(SP), BP</span><br><span class="line">0x00d8 00216 (main.go:9)ADDQ    $96, SP</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<p><code>BP</code>可以理解为保存了当前函数栈帧栈底的地址，<code>SP</code>则保存栈顶的地址。</p>
<p>初始，<code>BP</code> 和 <code>SP</code> 分别有一个初始状态。</p>
<p><code>main</code> 函数执行的时候，先根据 <code>main</code> 函数栈帧大小确定 <code>SP</code> 的新指向，使得 <code>main</code> 函数栈帧大小达到 <code>96B</code>。之后把老的 <code>BP</code> 保存到 <code>main</code>  函数栈帧的底部，并使 <code>BP</code> 寄存器重新指向新的栈底，也就是 <code>main</code> 函数栈帧的栈底。</p>
<p>最后，当 <code>main</code> 函数执行完毕，把它栈底的 <code>BP</code> 给回弹回到 <code>BP</code> 寄存器，恢复调用前的初始状态。一切都像是没有发生一样，完美的现场。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54874022-24821100-4e1e-11e9-805b-408c29b3c1c4.png" alt="栈帧变化"></p>
<p>这部分，又详细地分析了一遍函数调用的过程。一方面，让大家复习一下上一篇文章讲的内容；另一方面，向大家展示如何找到 Go 中的一个函数背后真实调用了哪些函数。像例子中，我们就看到了 <code>make</code> 函数背后，实际上是调用了 <code>makeslice</code> 函数；还有一点，让大家对汇编不那么“惧怕”，可以轻松地分析一些东西。</p>
<h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><p>截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。</p>
<p>基于已有 slice 创建新 slice 对象，被称为 <code>reslice</code>。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。</p>
<p>值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 <code>append</code> 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，<code>问题的关键在于两者是否会共用底层数组</code>。</p>
<p>截取操作采用如下方式：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">slice := data[<span class="number">2</span>:<span class="number">4</span>:<span class="number">6</span>] <span class="comment">// data[low, high, max]</span></span><br></pre></td></tr></table></figure>

<p>对 <code>data</code> 使用3个索引值，截取出新的  <code>slice</code>。这里 <code>data</code> 可以是数组或者 <code>slice</code>。<code>low</code> 是最低索引值，这里是闭区间，也就是说第一个元素是 <code>data</code> 位于 <code>low</code> 索引处的元素；而 <code>high</code> 和 <code>max</code> 则是开区间，表示最后一个元素只能是索引 <code>high-1</code> 处的元素，而最大容量则只能是索引 <code>max-1</code> 处的元素。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max &gt;= high &gt;= low</span><br></pre></td></tr></table></figure>

<p>当 <code>high == low</code> 时，新 <code>slice</code> 为空。</p>
<p>还有一点，<code>high</code> 和 <code>max</code> 必须在老数组或者老 <code>slice</code> 的容量（<code>cap</code>）范围内。</p>
<p>来看一个例子，来自雨痕大佬《Go学习笔记》第四版，P43页，参考资料里有开源书籍地址。这里我会进行扩展，并会作详细说明：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	s1 := slice[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	s2 := s1[<span class="number">2</span>:<span class="number">6</span>:<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">	s1[<span class="number">2</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下代码运行的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2 3 20]</span><br><span class="line">[4 5 6 7 100 200]</span><br><span class="line">[0 1 2 3 20 5 6 7 100 9]</span><br></pre></td></tr></table></figure>

<p>我们来走一遍代码，初始状态如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := slice[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">s2 := s1[<span class="number">2</span>:<span class="number">6</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p><code>s1</code> 从 <code>slice</code> 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。<br><code>s2</code> 从 <code>s1</code> 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54960948-c5490b80-4f99-11e9-8772-66d102caae8e.png" alt="slice origin"></p>
<p>接着，向 <code>s2</code> 尾部追加一个元素 100：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><code>s2</code> 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 <code>s1</code> 都可以看得到。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54960896-8ca93200-4f99-11e9-86de-df4d85cca135.png" alt="append 100"></p>
<p>再次向 <code>s2</code> 追加元素200：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这时，<code>s2</code> 的容量不够用，该扩容了。于是，<code>s2</code> 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 <code>append</code> 带来的再一次扩容，<code>s2</code> 会在此次扩容的时候多留一些 <code>buffer</code>，将新的容量将扩大为原始容量的2倍，也就是10了。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54961368-4654d280-4f9b-11e9-9b00-de96c6eedea9.png" alt="append 200"></p>
<p>最后，修改 <code>s1</code> 索引为2位置的元素：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1[<span class="number">2</span>] = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>这次只会影响原始数组相应位置的元素。它影响不到 <code>s2</code> 了，人家已经远走高飞了。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54961330-29200400-4f9b-11e9-88d0-a29308a818ae.png" alt="s1[2]=20"></p>
<p>再提一点，打印 <code>s1</code> 的时候，只会打印出 <code>s1</code> 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。</p>
<p>至于，我们想在汇编层面看看到底它们是如何共享底层数组的，限于篇幅，这里不再展开。感兴趣的同学可以在公众号后台回复：<code>切片截取</code>。</p>
<p>我会给你详细分析函数调用关系，对共享底层数组的行为也会一目了然。二维码见文章底部。</p>
<h1 id="slice-和数组的区别在哪"><a href="#slice-和数组的区别在哪" class="headerlink" title="slice 和数组的区别在哪"></a>slice 和数组的区别在哪</h1><p>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p>
<p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 <code>[3]int</code> 和 <code>[4]int</code> 就是不同的类型。</p>
<p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p>
<h1 id="append-到底做了什么"><a href="#append-到底做了什么" class="headerlink" title="append 到底做了什么"></a>append 到底做了什么</h1><p>先来看看 <code>append</code> 函数的原型：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 <code>...</code> 传入 slice，直接追加一个切片。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</span><br></pre></td></tr></table></figure>

<p><code>append</code>函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>(slice, elem1, elem2)</span><br><span class="line"><span class="built_in">append</span>(slice, anotherSlice...)</span><br></pre></td></tr></table></figure>

<p>所以上面的用法是错的，不能编译通过。</p>
<p>使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 <code>len-1</code> 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。</p>
<p>这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 <code>slice</code> 的容量是留了一定的 <code>buffer</code> 的。否则，每次添加元素的时候，都会发生迁移，成本太高。</p>
<p>新 slice 预留的 <code>buffer</code> 大小是有一定规律的。网上大多数的文章都是这样描述的：</p>
<blockquote>
<p>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p>
</blockquote>
<p>我在这里先说结论：以上描述是错误的。</p>
<p>为了说明上面的规律是错误的，我写了一小段玩具代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	oldCap := <span class="built_in">cap</span>(s)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, i)</span><br><span class="line"></span><br><span class="line">		newCap := <span class="built_in">cap</span>(s)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> newCap != oldCap &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"[%d -&gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n"</span>, <span class="number">0</span>, i<span class="number">-1</span>, oldCap, i, newCap)</span><br><span class="line">			oldCap = newCap</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我先创建了一个空的 <code>slice</code>，然后，在一个循环里不断往里面 <code>append</code> 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 <code>slice</code> 里的元素。这样，我就可以观察，新老 <code>slice</code> 的容量变化情况，从而找出规律。</p>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[0 -&gt;   -1] cap = 0     |  after append 0     cap = 1   </span><br><span class="line">[0 -&gt;    0] cap = 1     |  after append 1     cap = 2   </span><br><span class="line">[0 -&gt;    1] cap = 2     |  after append 2     cap = 4   </span><br><span class="line">[0 -&gt;    3] cap = 4     |  after append 4     cap = 8   </span><br><span class="line">[0 -&gt;    7] cap = 8     |  after append 8     cap = 16  </span><br><span class="line">[0 -&gt;   15] cap = 16    |  after append 16    cap = 32  </span><br><span class="line">[0 -&gt;   31] cap = 32    |  after append 32    cap = 64  </span><br><span class="line">[0 -&gt;   63] cap = 64    |  after append 64    cap = 128 </span><br><span class="line">[0 -&gt;  127] cap = 128   |  after append 128   cap = 256 </span><br><span class="line">[0 -&gt;  255] cap = 256   |  after append 256   cap = 512 </span><br><span class="line">[0 -&gt;  511] cap = 512   |  after append 512   cap = 1024</span><br><span class="line">[0 -&gt; 1023] cap = 1024  |  after append 1024  cap = 1280</span><br><span class="line">[0 -&gt; 1279] cap = 1280  |  after append 1280  cap = 1696</span><br><span class="line">[0 -&gt; 1695] cap = 1696  |  after append 1696  cap = 2304</span><br></pre></td></tr></table></figure>

<p>在老 slice 容量小于1024的时候，新 slice 的容量的确是老 slice 的2倍。目前还算正确。</p>
<p>但是，当老 slice 容量大于等于 <code>1024</code> 的时候，情况就有变化了。当向 slice 中添加元素 <code>1280</code> 的时候，老 slice 的容量为 <code>1280</code>，之后变成了 <code>1696</code>，两者并不是 <code>1.25</code> 倍的关系（1696/1280=1.325）。添加完 <code>1696</code> 后，新的容量 <code>2304</code> 当然也不是 <code>1696</code> 的 <code>1.25</code> 倍。</p>
<p>可见，现在网上各种文章中的扩容策略并不正确。我们直接搬出源码：源码面前，了无秘密。</p>
<p>从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 <code>growslice</code> 函数，所以我们直接看它的代码。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">	</span><br><span class="line">	capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗？如果只看前半部分，现在网上各种文章里说的 <code>newcap</code> 的规律是对的。现实是，后半部分还对 <code>newcap</code> 作了一个<code>内存对齐</code>，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 老 slice 容量的 <code>2倍</code>或者<code>1.25倍</code>。</p>
<p>之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。</p>
<p>最后，向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>
<p>关于 <code>append</code>，我们最后来看一个例子，来源于参考资料部分的【Golang Slice的扩容规则】。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d, cap=%d"</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=5, cap=6</span><br></pre></td></tr></table></figure>

<p>如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。</p>
<p>那上面代码的运行结果就是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=5, cap=8</span><br></pre></td></tr></table></figure>

<p>这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">	</span><br><span class="line">	capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的参数依次是 <code>元素的类型，老的 slice，新 slice 最小求的容量</code>。</p>
<p>例子中 <code>s</code> 原来只有 2 个元素，<code>len</code> 和 <code>cap</code> 都为 2，<code>append</code> 了三个元素后，长度变为 3，容量最小要变成 5，即调用 <code>growslice</code> 函数时，传入的第三个参数应该为 5。即 <code>cap=5</code>。而一方面，<code>doublecap</code> 是原 <code>slice</code>容量的 2 倍，等于 4。满足第一个 <code>if</code> 条件，所以 <code>newcap</code> 变成了 5。</p>
<p>接着调用了 <code>roundupsize</code> 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）</p>
<p>我们再看内存对齐，搬出 <code>roundupsize</code> 函数的代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/msize.go:13</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//……</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _MaxSmallSize = <span class="number">32768</span></span><br><span class="line"><span class="keyword">const</span> smallSizeMax = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> smallSizeDiv = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>很明显，我们最终将返回这个式子的结果：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]]</span><br></pre></td></tr></table></figure>

<p>这是 <code>Go</code> 源码中有关内存分配的两个 <code>slice</code>。<code>class_to_size</code>通过 <code>spanClass</code>获取 <code>span</code>划分的 <code>object</code>大小。而 <code>size_to_class8</code> 表示通过 <code>size</code> 获取它的 <code>spanClass</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> size_to_class8 = [smallSizeMax/smallSizeDiv + <span class="number">1</span>]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们传进去的 <code>size</code> 等于 40。所以 <code>(size+smallSizeDiv-1)/smallSizeDiv = 5</code>；获取 <code>size_to_class8</code> 数组中索引为 <code>5</code> 的元素为 <code>4</code>；获取 <code>class_to_size</code> 中索引为 <code>4</code> 的元素为 <code>48</code>。</p>
<p>最终，新的 slice 的容量为 <code>6</code>：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newcap = <span class="keyword">int</span>(capmem / ptrSize) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>至于，上面的两个<code>魔法数组</code>的由来，暂时就不展开了。</p>
<h1 id="为什么-nil-slice-可以直接-append"><a href="#为什么-nil-slice-可以直接-append" class="headerlink" title="为什么 nil slice 可以直接 append"></a>为什么 nil slice 可以直接 append</h1><p>其实 <code>nil slice</code> 或者 <code>empty slice</code> 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 <code>mallocgc</code> 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的<code>nil slice</code> 或 <code>empty slice</code>，然后摇身一变，成为“真正”的 <code>slice</code> 了。</p>
<h1 id="传-slice-和-slice-指针有什么区别"><a href="#传-slice-和-slice-指针有什么区别" class="headerlink" title="传 slice 和 slice 指针有什么区别"></a>传 slice 和 slice 指针有什么区别</h1><p>前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。</p>
<p>当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。</p>
<p>值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。</p>
<p>通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 <code>s[i]=10</code> 这种操作改变 slice 底层数组元素值。</p>
<p>另外，啰嗦一句，Go 语言的函数参数传递，只有值传递，没有引用传递。后面会再写一篇相关的文章，敬请期待。</p>
<p>再来看一个年幼无知的代码片段：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	f(s)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// i只是一个副本，不能改变s中元素的值</span></span><br><span class="line">	<span class="comment">/*for _, i := range s &#123;</span></span><br><span class="line"><span class="comment">		i++</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下，程序输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2 2 2]</span><br></pre></td></tr></table></figure>

<p>果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 <code>f</code> 函数中，<code>s</code> 只是 <code>main</code> 函数中 <code>s</code> 的一个拷贝。在<code>f</code> 函数内部，对 <code>s</code> 的作用并不会改变外层 <code>main</code> 函数的 <code>s</code>。</p>
<p>要想真的改变外层 <code>slice</code>，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(s []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里 s 虽然改变了，但并不会影响外层函数的 s</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppendPtr</span><span class="params">(s *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 会改变外层 s 本身</span></span><br><span class="line">	*s = <span class="built_in">append</span>(*s, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	newS := myAppend(s)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(newS)</span><br><span class="line"></span><br><span class="line">	s = newS</span><br><span class="line"></span><br><span class="line">	myAppendPtr(&amp;s)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1 1 1]</span><br><span class="line">[1 1 1 100]</span><br><span class="line">[1 1 1 100 100]</span><br></pre></td></tr></table></figure>

<p><code>myAppend</code> 函数里，虽然改变了 <code>s</code>，但它只是一个值传递，并不会影响外层的 <code>s</code>，因此第一行打印出来的结果仍然是 <code>[1 1 1]</code>。</p>
<p>而 <code>newS</code> 是一个新的 <code>slice</code>，它是基于 <code>s</code> 得到的。因此它打印的是追加了一个 <code>100</code> 之后的结果： <code>[1 1 1 100]</code>。</p>
<p>最后，将 <code>newS</code> 赋值给了 <code>s</code>，<code>s</code> 这时才真正变成了一个新的slice。之后，再给 <code>myAppendPtr</code> 函数传入一个 <code>s  指针</code>，这回它真的被改变了：<code>[1 1 1 100 100]</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，关于 <code>slice</code> 的部分就讲完了，不知大家有没有看过瘾。我们最后来总结一下：</p>
<ul>
<li>切片是对底层数组的一个抽象，描述了它的一个片段。</li>
<li>切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。</li>
<li>多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。</li>
<li><code>append</code> 函数会在切片容量不够的情况下，调用 <code>growslice</code> 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。</li>
<li>扩容策略并不是简单的扩为原切片容量的 <code>2</code> 倍或 <code>1.25</code> 倍，还有内存对齐的操作。扩容后的容量 &gt;= 原容量的 <code>2</code> 倍或 <code>1.25</code> 倍。</li>
<li>当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。</li>
</ul>
<p>最后，如果你觉得本文对你有帮助的话，帮我点一下右下角的“推荐”吧，感谢！</p>
<p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【码洞「切片」的三种特殊状态】<a href="https://juejin.im/post/5bea58df6fb9a049f153bca8" target="_blank" rel="noopener">https://juejin.im/post/5bea58df6fb9a049f153bca8</a></p>
<p>【老钱 数组】<a href="https://juejin.im/post/5be53bc251882516c15af2e0" target="_blank" rel="noopener">https://juejin.im/post/5be53bc251882516c15af2e0</a></p>
<p>【老钱 切片】<a href="https://juejin.im/post/5be8e0b1f265da614d08b45a" target="_blank" rel="noopener">https://juejin.im/post/5be8e0b1f265da614d08b45a</a></p>
<p>【golang interface源码】<a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">https://i6448038.github.io/2018/10/01/Golang-interface/</a></p>
<p>【golang interface源码】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p>
<p>【interface】<a href="https://www.jishuwen.com/d/2C9z#tuit" target="_blank" rel="noopener">https://www.jishuwen.com/d/2C9z#tuit</a></p>
<p>【雨痕开源Go学习笔记】<a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></p>
<p>【slice 图很漂亮】<a href="https://halfrost.com/go_slice/" target="_blank" rel="noopener">https://halfrost.com/go_slice/</a></p>
<p>【slice 扩容规则】<a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99" target="_blank" rel="noopener">https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99</a></p>
<p>【slice 作为参数】<a href="https://www.cnblogs.com/fwdqxl/p/9317769.html" target="_blank" rel="noopener">https://www.cnblogs.com/fwdqxl/p/9317769.html</a></p>
<p>【源码】<a href="https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/" target="_blank" rel="noopener">https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/</a></p>
<p>【append机制 译文】<a href="https://brantou.github.io/2017/05/24/go-array-slice-string/" target="_blank" rel="noopener">https://brantou.github.io/2017/05/24/go-array-slice-string/</a></p>
<p>【slice 汇编】<a href="http://xargin.com/go-slice/" target="_blank" rel="noopener">http://xargin.com/go-slice/</a></p>
<p>【slice tricks】<a href="https://colobu.com/2017/03/22/Slice-Tricks/" target="_blank" rel="noopener">https://colobu.com/2017/03/22/Slice-Tricks/</a></p>
<p>【有图】<a href="https://i6448038.github.io/2018/08/11/array-and-slice-principle/" target="_blank" rel="noopener">https://i6448038.github.io/2018/08/11/array-and-slice-principle/</a></p>
<p>【slice的本质】<a href="https://www.flysnow.org/2018/12/21/golang-sliceheader.html" target="_blank" rel="noopener">https://www.flysnow.org/2018/12/21/golang-sliceheader.html</a></p>
<p>【slice使用技巧】<a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html" target="_blank" rel="noopener">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></p>
<p>【slice/array、内存增长】<a href="https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html" target="_blank" rel="noopener">https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/04/02/dive-into-go-slice/">https://github.com/qcrao/qcrao.github.io/2019/04/02/dive-into-go-slice/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2019/04/25/dive-into-go-interface/">深度解密Go语言之关于interface的 10 个问题</a><a class="next" href="/2019/03/20/dive-into-go-asm/">深入Go的底层，带你走进一群有追求的人</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'cbe588b3fbaba896fb1d',
  clientSecret: '2d521d32f2d84aa94dce53582564a5fa871a53d5',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://github.com/qcrao/qcrao.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/24/how-go-runs/">Go 程序是怎样跑起来的</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/22/dive-into-go-channel/">深度解密Go语言之channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/how-to-write-resume-gracefully/">如何打造一份优雅的简历</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/cch-says-memory-reorder/">曹大谈内存重排</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/12/dive-into-go-context/">深度解密Go语言之context</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/03/dive-into-go-unsafe/">深度解密Go语言之unsafe</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/dive-into-go-map/">深度解密Go语言之map</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/dive-into-go-reflection/">深度解密Go语言之反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/dive-into-go-interface/">深度解密Go语言之关于interface的 10 个问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/02/dive-into-go-slice/">深度解密Go语言之slice</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">123.6k</span><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>