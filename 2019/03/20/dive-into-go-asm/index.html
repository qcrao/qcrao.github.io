<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>深入Go的底层，带你走进一群有追求的人 | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入Go的底层，带你走进一群有追求的人</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/readings/"><i class="fa fa-book"> 阅读</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入Go的底层，带你走进一群有追求的人</h1><div class="post-meta">Mar 20, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#缘起"><span class="toc-number">1.</span> <span class="toc-text">缘起</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自我介绍的技巧"><span class="toc-number">2.</span> <span class="toc-text">自我介绍的技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#硬核知识点"><span class="toc-number">3.</span> <span class="toc-text">硬核知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是plan9汇编"><span class="toc-number">3.1.</span> <span class="toc-text">什么是plan9汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编角度看函数调用及返回过程"><span class="toc-number">3.2.</span> <span class="toc-text">汇编角度看函数调用及返回过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编角度看slice"><span class="toc-number">3.3.</span> <span class="toc-text">汇编角度看slice</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正确参与Go夜读活动的方式"><span class="toc-number">4.</span> <span class="toc-text">正确参与Go夜读活动的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阅读原文"><span class="toc-number">5.</span> <span class="toc-text">阅读原文</span></a></li></ol></div></div><div class="post-content"><p>上周六晚上，我参加了“Go夜读”活动，这期主要讲Go汇编语言，由滴滴大佬曹春晖大神主讲。活动结束后，我感觉打通了任督二脉。活动从晚上9点到深夜11点多，全程深度参与，大呼过瘾，以至于活动结束之后，久久不能平静。</p>
<p>可以说理解了Go汇编语言，就可以让我们对Go的理解上一个台阶，很多以前模棱的东西，在汇编语言面前都无所遁形了。我在活动上收获了很多，今天我来作一个总结，希望给大家带来启发！</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>几周前我写了一篇关于<code>defer</code>的文章：<a href="https://www.cnblogs.com/qcrao-2018/p/10367346.html" target="_blank" rel="noopener">《Golang之如何轻松化解defer的温柔陷阱》</a>。这篇文章发出后不久就被<code>GoCN</code>的每日新闻收录了，然后就被Go夜读群的大佬杨文看到了，之后被邀请去夜读活动分享。</p>
<p>正式分享前，我又主题阅读了很多文章，以求把defer讲清楚。阅读过程中，我发现但凡深入一点的文章，都会抛出Go汇编语言。于是就去搜索资料，无奈相关的资料太少，看得云里雾里，最后到了真正要分享的时候也没有完全弄清楚。</p>
<p>夜读活动结束之后，杨大发布了由春晖大神带来的夜读分享预告：<code>《plan9 汇编入门，带你打通应用和底层》</code>。我得知这个消息后，非常激动！终于有牛人可以讲讲Go汇编语言了，听完之后估计会有很大提升，也能搞懂defer的底层原理了！</p>
<p>接着，我发现，春晖大神竟然和我在同一个公司！我在公司内网上搜到了他写的plan9汇编相关文章，发布到Go夜读的github上。我提前花时间预习完了文章，整理出了遇到的问题。</p>
<p>周六晚上9点准时开讲，曹大的准备很充分！原来1个小时的时间被拉长到了2个多小时，而曹大精力和反应一直很迅速，问的问题很快就能得到回答。我全程和曹大直接对话，感觉简直不要太爽！</p>
<p>这篇文章既是对这次夜读的总结，也是为了宣传一下Go夜读活动。那里是一群有追求的人，他们每周都会聚在一起，通过网络，探讨Go语言的方方面面。我相信，参与的人都会有很多不同的收获。</p>
<p>我直接参与的Go夜读活动有三期，一期分享，两期听讲，每次都有很多的收获。</p>
<h1 id="自我介绍的技巧"><a href="#自我介绍的技巧" class="headerlink" title="自我介绍的技巧"></a>自我介绍的技巧</h1><p>很多人都不知道怎么做好一个自我介绍，要么含糊其辞，介绍完大家都不知道你讲了什么；要么说了半天无效的信息，大家并不关心的事情，搞得很尴尬。 其实自我介绍没那么难，掌握套路后，是可以做得很好的！</p>
<p>我在上上期Go夜读分享的时候，用一张PPT完成了自我介绍。包含了四个方面：<code>个人基本信息</code>、<code>出现在此时此地的原因</code>、<code>我能带来的帮助</code>、<code>我希望得到的帮助</code>。</p>
<p><code>个人基本信息</code>包括你叫什么名字，是哪里人，在什么地方工作，毕业于哪个学校，有什么兴趣爱好……这些基本的属性。这些信息可以让大家快速形成对你的直观认识。</p>
<p><code>出现在此时此地的原因</code>，可以讲解你的故事。你在什么地方通过什么人知道了这个活动，然后因为什么打动你来参加……通过故事可以迅速拉近与现场其他参与者的距离。</p>
<p><code>我能带来的帮助</code>，参加活动的人都是想获取一些东西的：知识、经验、见闻等等。但是，我们不能只索取，不付出。因此，可以讲讲你可以提供的帮助。比如我可以联系场地，我会写宣传文章等等，你可以讲出你独特的价值。</p>
<p><code>我希望得到的帮助</code>。每个参与的人都希望从活动中获得自己想要的东西，正是因为此，这个活动对于参与者才有意义，也才会持续下去的动力。</p>
<p>这四个方面，可以组成一个非常精彩的自我介绍。它最早是我在听罗胖的《罗辑思维》听到的，我把它写进了我的<code>人生算法</code>里，今天推荐给大家。希望大家以后在需要自我介绍的场合有话可说，而且能说的精彩。</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54608061-e3d77000-4a8a-11e9-95a3-7484f94b959b.png" alt="自我介绍"></p>
<h1 id="硬核知识点"><a href="#硬核知识点" class="headerlink" title="硬核知识点"></a>硬核知识点</h1><h2 id="什么是plan9汇编"><a href="#什么是plan9汇编" class="headerlink" title="什么是plan9汇编"></a>什么是plan9汇编</h2><p>我们知道，CPU是只认二进制指令的，也就是一串的0101；人类无法记住这些二进制码，于是发明了汇编语言。汇编语言实际上是二进制指令的文本形式，它与指令可以一一对应。</p>
<p>每一种CPU指令都是不一样的，因此对应的汇编语言也就不一样。人类写完汇编语言后，把它转换成二进制码，就可以被机器执行了。转换的动作由编译器完成。</p>
<blockquote>
<p>Go语言的编译器和汇编器都带了一个-S参数，可以查看生成的最终目标代码。通过对比目标代码和原始的Go语言或Go汇编语言代码的差异可以加深对底层实现的理解。</p>
</blockquote>
<p>Go汇编语言实际上来源于plan9汇编语言，而plan9汇编语言最初来源于Go语言作者之一的Ken Thompson为plan9系统所写的C语言编译器输出的汇编伪代码。这里强烈推荐一下春晖大神的新书《Go语言高级编程》，即将上市，电子版的点击阅读原文可以看到地址，书中有一整个章节讲Go的汇编语言，非常精彩！</p>
<p>理解Go的汇编语言，哪怕只是一点点，都能对Go的运行机制有更深入的理解。比如我们以前讲的defer，如果从Go源码编译后的汇编代码来看，就能深刻地掌握它的底层原理。再比如，很多文章都会分析Go的函数参数传递都是值传递，如果把汇编代码秀出来，很容易就能得出结论。</p>
<h2 id="汇编角度看函数调用及返回过程"><a href="#汇编角度看函数调用及返回过程" class="headerlink" title="汇编角度看函数调用及返回过程"></a>汇编角度看函数调用及返回过程</h2><p>假设我们有一个这样年幼无知的例子，求两个int的和，Go源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = add(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下命令得到汇编代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>

<p><code>go tool compile</code>命令用于调用Go语言提供的底层命令工具，其中<code>-S</code>参数表示输出汇编格式。</p>
<p>我们现在只关心add函数的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.add STEXT nosplit size=19 args=0x18 locals=0x0</span><br><span class="line">        0x0000 00000 (main.go:7)        TEXT    &quot;&quot;.add(SB), NOSPLIT, $0-24</span><br><span class="line">        0x0000 00000 (main.go:7)        FUNCDATA        $0, gclocals·54241e171da8af6ae173d69da0236748(SB)</span><br><span class="line">        0x0000 00000 (main.go:7)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">        0x0000 00000 (main.go:7)        MOVQ    &quot;&quot;.b+16(SP), AX</span><br><span class="line">        0x0005 00005 (main.go:7)        MOVQ    &quot;&quot;.a+8(SP), CX</span><br><span class="line">        0x000a 00010 (main.go:8)        ADDQ    CX, AX</span><br><span class="line">        0x000d 00013 (main.go:8)        MOVQ    AX, &quot;&quot;.~r2+24(SP)</span><br><span class="line">        0x0012 00018 (main.go:8)        RET</span><br></pre></td></tr></table></figure>

<p>看不懂没关系，我目前也不是全部都懂，但是对于理解一个函数调用的整体过程而言，足够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:7)        TEXT    &quot;&quot;.add(SB), NOSPLIT, $0-24</span><br></pre></td></tr></table></figure>

<p>这一行表示定义<code>add</code>这个函数，最后的数字<code>$0-24</code>，其中<code>0</code>表示函数栈帧大小为0；<code>24</code>表示参数及返回值的大小：参数是2个int型变量，返回值是1个int型变量，共24字节。</p>
<p>再看中间这四行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:7)        MOVQ    &quot;&quot;.b+16(SP), AX</span><br><span class="line">0x0005 00005 (main.go:7)        MOVQ    &quot;&quot;.a+8(SP), CX</span><br><span class="line">0x000a 00010 (main.go:8)        ADDQ    CX, AX</span><br><span class="line">0x000d 00013 (main.go:8)        MOVQ    AX, &quot;&quot;.~r2+24(SP)</span><br></pre></td></tr></table></figure>

<p>代码片段中的第1行，将第2个参数<code>b</code>搬到<code>AX</code>寄存器；第2行将1个参数<code>a</code>搬到寄存器<code>CX</code>；第3行将<code>a</code>和<code>b</code>相加，相加的结果搬到<code>AX</code>；最后一行，将结果搬到返回参数的地址，这段汇编代码非常简单，来看一下函数调用者和被调者的栈帧图：</p>
<p>(SP)指栈顶，b+16(SP)表示参数1的位置，从SP往上增加16个字节，注意，前面的b仅表示一个标号；同样，a+8(SP)表示实参0；~r2+24(SP)则表示返回值的位置。</p>
<p>具体可以看下面的图：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54614544-8c8bcc80-4a97-11e9-9e68-61be5e6f5085.png" alt="add函数栈帧"></p>
<p>上面add函数的栈帧大小为0，其实更一般的调用者与被调用者的栈帧示意图如下：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54598545-aca99480-4a73-11e9-8870-99ab8ee9fcb7.png" alt="栈帧"></p>
<p>最后，执行<code>RET</code>指令。这一步把被调用函数<code>add</code>栈帧清零,接着，弹出栈顶的<code>返回地址</code>，把它赋给指令寄存器<code>rip</code>，而<code>返回地址</code>就是<code>main</code>函数里调用<code>add</code>函数的下一行。</p>
<p>于是，又回到了<code>main</code>函数的执行环境，<code>add</code>函数的栈帧也被销毁了。但是注意，这块内存是没有被清零的，清零动作是之后再次申请这块内存的时候要做的事。比如，声明了一个int型变量，它的默认值是0，清零的动作是在这里完成的。</p>
<p>这样，main函数完成了函数调用，也拿到了返回值，完美。</p>
<h2 id="汇编角度看slice"><a href="#汇编角度看slice" class="headerlink" title="汇编角度看slice"></a>汇编角度看slice</h2><p>再来看一个例子，我们来看看<code>slice</code>的底层到底是什么。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">	_ = f(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用上面同样的命令得到汇编代码，我们只关注<code>f</code>函数的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.f STEXT nosplit size=53 args=0x20 locals=0x8</span><br><span class="line">        // 栈帧大小为8字节，参数和返回值为32字节</span><br><span class="line">        0x0000 00000 (main.go:8)        TEXT    &quot;&quot;.f(SB), NOSPLIT, $8-32</span><br><span class="line">        // SP栈顶指针下移8字节</span><br><span class="line">        0x0000 00000 (main.go:8)        SUBQ    $8, SP</span><br><span class="line">        // 将BP寄存器的值入栈</span><br><span class="line">        0x0004 00004 (main.go:8)        MOVQ    BP, (SP)</span><br><span class="line">        // 将新的栈顶地址保存到BP寄存器</span><br><span class="line">        0x0008 00008 (main.go:8)        LEAQ    (SP), BP</span><br><span class="line">        0x000c 00012 (main.go:8)        FUNCDATA        $0, gclocals·4032f753396f2012ad1784f398b170f4(SB)</span><br><span class="line">        0x000c 00012 (main.go:8)        FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">        // 取出slice的长度len</span><br><span class="line">        0x000c 00012 (main.go:8)        MOVQ    &quot;&quot;.s+24(SP), AX</span><br><span class="line">        // 比较索引1是否超过len</span><br><span class="line">        0x0011 00017 (main.go:9)        CMPQ    AX, $1</span><br><span class="line">        // 如果超过len，越界了。跳转到46</span><br><span class="line">        0x0015 00021 (main.go:9)        JLS     46</span><br><span class="line">        // 将slice的数据首地址加载到AX寄存器</span><br><span class="line">        0x0017 00023 (main.go:9)        MOVQ    &quot;&quot;.s+16(SP), AX</span><br><span class="line">        // 将第8byte地址的元素保存到AX寄存器，也就是salaries[1]</span><br><span class="line">        0x001c 00028 (main.go:9)        MOVQ    8(AX), AX</span><br><span class="line">        // 将结果拷贝到返回参数的位置（y）</span><br><span class="line">        0x0020 00032 (main.go:9)        MOVQ    AX, &quot;&quot;.~r1+40(SP)</span><br><span class="line">        // 恢复BP的值</span><br><span class="line">        0x0025 00037 (main.go:9)        MOVQ    (SP), BP</span><br><span class="line">        // SP向上移动8个字节</span><br><span class="line">        0x0029 00041 (main.go:9)        ADDQ    $8, SP</span><br><span class="line">        // 返回</span><br><span class="line">        0x002d 00045 (main.go:9)        RET</span><br><span class="line">        0x002e 00046 (main.go:9)        PCDATA  $0, $1</span><br><span class="line">        // 越界，panic</span><br><span class="line">        0x002e 00046 (main.go:9)        CALL    runtime.panicindex(SB)</span><br><span class="line">        0x0033 00051 (main.go:9)        UNDEF</span><br><span class="line">        0x0000 48 83 ec 08 48 89 2c 24 48 8d 2c 24 48 8b 44 24  H...H.,$H.,$H.D$</span><br><span class="line">        0x0010 18 48 83 f8 01 76 17 48 8b 44 24 10 48 8b 40 08  .H...v.H.D$.H.@.</span><br><span class="line">        0x0020 48 89 44 24 28 48 8b 2c 24 48 83 c4 08 c3 e8 00  H.D$(H.,$H......</span><br><span class="line">        0x0030 00 00 00 0f 0b                                   .....</span><br><span class="line">        rel 47+4 t=8 runtime.panicindex+0</span><br></pre></td></tr></table></figure>

<p>通过上面的汇编代码，我们画出函数调用的栈帧图：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/54599149-fe065380-4a74-11e9-800b-9a12db0c730c.png" alt="f函数栈帧"></p>
<p>我们可以清晰地看到，一个slice本质上是用一个数据首地址，一个长度Len，一个容量Cap。所以在参数是slice的函数里，对slice的操作会影响到实参的slice。</p>
<h1 id="正确参与Go夜读活动的方式"><a href="#正确参与Go夜读活动的方式" class="headerlink" title="正确参与Go夜读活动的方式"></a>正确参与Go夜读活动的方式</h1><p>最后再说一下Go夜读活动的方式和目标。引自Go夜读的github说明文件：</p>
<blockquote>
<p>由一个主讲人带着大家一起去阅读 Go 源代码，一起去啃那些难啃的算法、学习代码里面的奇淫技巧，遇到问题或者有疑惑了，我们可以一起去检索，解答这些问题。我们可以一起学习，共同成长。</p>
</blockquote>
<blockquote>
<p>我们希望可以推进大家深入了解 Go ，快速成长为资深的 Gopher 。我们希望每次来了的人和没来的人都能够有收获，成长。</p>
</blockquote>
<p>前面我说Go夜读活动的小伙伴是一群有追求的人，这里我也指出一些问题吧。就我参与的三期来看，虽然zoom接入人数很多，高峰期50+人，但是全过程大家交流比较少，基本上是主讲人一个人在那自嗨。春晖大佬讲的那期，只有我全程提问。感觉像是我们两个人在对话，我的问题弄清楚了，只是不知道其他的参与同学如何？</p>
<p>我再给分享者和参与者提一些建议吧：</p>
<p>对于分享者，事先做好充足的准备，可以在文章里列出主要的点，放在github里，参考春晖大佬的plan9汇编讲义；最重要的一点，分享前给大家提供一份预习资料。</p>
<p>对于参与者，能获得最多收获的方式就是会前预习，会中积极提问，会后复习总结发散。另外，强烈建议参与者会前要准备至少一个问题，有针对性地听，才会有收获。会中也要积极提问，这也是对主讲者的反馈，不至于主讲者觉得只有自己在对着电脑讲。</p>
<p>最后，欢迎每一个学习Go语言的同学都能来Go夜读看看！点击阅读原文可以看到文章里提到的所有资料，包括上期曹大plan9汇编的视频回放，不容错过！</p>
<p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>
<h1 id="阅读原文"><a href="#阅读原文" class="headerlink" title="阅读原文"></a>阅读原文</h1><p><a href="https://github.com/developer-learning/reading-go" target="_blank" rel="noopener">夜读地址</a></p>
<p><a href="https://github.com/cch123/asmshare/blob/master/layout.md" target="_blank" rel="noopener">《plan9 汇编入门，带你打通应用和底层》讲义</a></p>
<p><a href="https://www.bilibili.com/video/av46494102" target="_blank" rel="noopener">《plan9 汇编入门，带你打通应用和底层》视频地址</a></p>
<p><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">曹大的Go高级编程书，纸质书即将出版</a></p>
<p><a href="https://github.com/cch123/golang-notes" target="_blank" rel="noopener">曹大go源码阅读</a></p>
<p><a href="http://xargin.com/" target="_blank" rel="noopener">曹大博客</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/03/20/dive-into-go-asm/">https://qcrao.com/2019/03/20/dive-into-go-asm/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2019/04/02/dive-into-go-slice/">深度解密Go语言之slice</a><a class="next" href="/2019/03/13/graphic-go-memory-allocation/">图解Go语言内存分配</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/故障排查/" style="font-size: 15px;">故障排查</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/head-first-design-pattern-reading-notes/">《Head First 设计模式》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/dive-into-go-sync-map/">深度解密Go语言之sync.map</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/codec-accident/">“���”引发的线上事故</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/dive-into-go-sync-pool/">深度解密Go语言之sync.pool</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/talk-about-g0/">聊聊 g0</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/how-to-traverse-defer-links/">defer 链表如何被遍历执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/high-performance-mysql-reading-notes/">《高性能 MySQL》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/dive-into-go-pprof/">深度解密Go语言之pprof</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/18/golang-error-break-through/">Golang error 的突围</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/dive-into-go-scheduler-source-code/">深度解密调度器源码系列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="Panda - Just for fun" target="_blank">Panda - Just for fun</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">168.5k</span><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 鄂ICP备20006251号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>