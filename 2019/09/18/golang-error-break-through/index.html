<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>Golang error 的突围 | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Golang error 的突围</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/readings/"><i class="fa fa-book"> 阅读</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Golang error 的突围</h1><div class="post-meta">Sep 18, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 23</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#error-的困局"><span class="toc-number">1.</span> <span class="toc-text">error 的困局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尝试破局"><span class="toc-number">2.</span> <span class="toc-text">尝试破局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Errors-are-just-values"><span class="toc-number">2.1.</span> <span class="toc-text">Errors are just values</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handle-not-just-check-errors"><span class="toc-number">2.2.</span> <span class="toc-text">handle not just check errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Only-handle-errors-once"><span class="toc-number">2.3.</span> <span class="toc-text">Only handle errors once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#胎死腹中的-try-提案"><span class="toc-number">3.</span> <span class="toc-text">胎死腹中的 try 提案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-1-13-的改进"><span class="toc-number">4.</span> <span class="toc-text">go 1.13 的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fmt-Errorf"><span class="toc-number">4.1.</span> <span class="toc-text">fmt.Errorf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unwrap"><span class="toc-number">4.2.</span> <span class="toc-text">Unwrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Is"><span class="toc-number">4.3.</span> <span class="toc-text">Is</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#As"><span class="toc-number">4.4.</span> <span class="toc-text">As</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>写过 C 的同学知道，C 语言中常常返回整数错误码（errno）来表示函数处理出错，通常用 <code>-1</code> 来表示错误，用 <code>0</code> 表示正确。</p>
<p>而在 Go 中，我们使用 <code>error</code> 类型来表示错误，不过它不再是一个整数类型，是一个接口类型：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它表示那些能用一个字符串就能说清的错误。</p>
<p>我们最常用的就是 <code>errors.New()</code> 函数，非常简单：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/errors/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 New 函数创建出来的 error 类型实际上是 errors 包里未导出的 <code>errorString</code> 类型，它包含唯一的一个字段 <code>s</code>，并且实现了唯一的方法：<code>Error() string</code>。</p>
<p>通常这就够了，它能反映当时“出错了”，但是有些时候我们需要更加具体的信息，例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用者发现出错的时候，只知道传入了一个负数进来，并不清楚到底传的是什么值。在 Go 里：</p>
<blockquote>
<p>It is the error implementation’s responsibility to summarize the context.</p>
</blockquote>
<p>它要求返回这个错误的函数要给出具体的“上下文”信息，也就是说，在 <code>Sqrt</code> 函数里，要给出这个负数到底是什么。</p>
<p>所以，如果发现 <code>f</code> 小于 0，应该这样返回错误：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"math: square root of negative number %g"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就用到了 <code>fmt.Errorf</code> 函数，它先将字符串格式化，再调用 <code>errors.New</code> 函数来创建错误。</p>
<p>当我们想知道错误类型，并且打印错误的时候，直接打印 error：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err.Error)</span><br></pre></td></tr></table></figure>

<p><code>fmt</code> 包会自动调用 <code>err.Error()</code> 函数来打印字符串。</p>
<p>通常，我们将 error 放到函数返回值的最后一个，没什么好说的，大家都这样做，约定俗成。</p>
<p>参考资料【Tony Bai】这篇文章提到，构造 error 的时候，要求传入的字符串首字母小写，结尾不带标点符号，这是因为我们经常会这样使用返回的 error：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... err := errors.New(<span class="string">"error example"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The returned error is %s.\n"</span>, err)</span><br></pre></td></tr></table></figure>

<h1 id="error-的困局"><a href="#error-的困局" class="headerlink" title="error 的困局"></a>error 的困局</h1><blockquote>
<p>In Go, error handling is important. The language’s design and conventions encourage you to explicitly check for errors where they occur (as distinct from the convention in other languages of throwing exceptions and sometimes catching them).</p>
</blockquote>
<p>在 Go 语言中，错误处理是非常重要的。它从语言层面要求我们需要明确地处理遇到的错误。而不是像其他语言，类如 Java，使用 <code>try-catch- finally</code> 这种“把戏”。</p>
<p>这就造成代码里 “error” 满天飞，显得非常冗长拖沓。</p>
<p>而为了代码健壮性考虑，对于函数返回的每一个错误，我们都不能忽略它。因为出错的同时，很可能会返回一个 <code>nil</code> 类型的对象。如果不对错误进行判断，那下一行对 <code>nil</code> 对象的操作百分之百会引发一个 <code>panic</code>。</p>
<p>这样，Go 语言中诟病最多的就是它的错误处理方式似乎回到了上古 C 语言时代。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rr := doStuff1()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = doStuff2()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = doStuff3()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Go authors 之一的 Russ Cox 对于这种观点进行过驳斥：当初选择返回值这种错误处理机制而不是 try-catch，主要是考虑前者适用于大型软件，后者更适合小程序。</p>
</blockquote>
<p>在参考资料【Go FAQ】里也提到，<code>try-catch</code> 会让代码变得非常混乱，程序员会倾向将一些常见的错误，例如，<code>failing to open a file</code>，也抛到异常里，这会让错误处理更加冗长繁琐且易出错。</p>
<p>而 Go 语言的多返回值使得返回错误异常简单。对于真正的异常，Go 提供 <code>panic-recover</code> 机制，也使得代码看起来非常简洁。</p>
<blockquote>
<p>当然 Russ Cox 也承认 Go 的错误处理机制对于开发人员的确有一定的心智负担。</p>
</blockquote>
<p>参考资料【Go 语言的错误处理机制是一个优秀的设计吗？】是知乎上的一个回答，阐述了 Go 对待错误和异常的不同处理方式，前者使用 error，后者使用 panic，这样的处理比较 Java 那种错误异常一锅端的做法更有优势。</p>
<p>【如何优雅的在Golang中进行错误处理】对于在业务上如何处理 error，给出了一些很好的示例。</p>
<h1 id="尝试破局"><a href="#尝试破局" class="headerlink" title="尝试破局"></a>尝试破局</h1><p>这部分的内容主要来自 Dave cheney GoCon 2016 的演讲，参考资料可以直达原文。</p>
<p>经常听到 Go 有很多“箴言”，说得很顺口，但理解起来并不是太容易，因为它们大部分都是有故事的。例如，我们常说：</p>
<blockquote>
<p>Don’t communicating by sharing memory, share memory by communicating.</p>
</blockquote>
<p>文中还列举了很多，都很有意思：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/64576578-d355e180-d3ab-11e9-8e99-34222a3994f1.png" alt="go proverbs"></p>
<p>下面我们讲三条关于 error 的“箴言”。</p>
<h2 id="Errors-are-just-values"><a href="#Errors-are-just-values" class="headerlink" title="Errors are just values"></a>Errors are just values</h2><p><code>Errors are just values</code> 的实际意思是只要实现了 <code>Error</code> 接口的类型都可以认为是 <code>Error</code>，重要的是要理解这些“箴言”背后的道理。</p>
<p>作者把处理 error 的方式分为三种：</p>
<blockquote>
<ol>
<li>Sentinel errors</li>
<li>Error Types</li>
<li>Opaque errors</li>
</ol>
</blockquote>
<p>我们来挨个说。首先 <code>Sentinel errors</code>，Sentinel 来自计算机中常用的词汇，中文意思是“哨兵”。以前在学习快排的时候，会有一个“哨兵”，其他元素都要和“哨兵”进行比较，它划出了一条界限。</p>
<p>这里 <code>Sentinel errors</code> 实际想说的是这里有一个错误，暗示处理流程不能再进行下去了，必须要在这里停下，这也是一条界限。而这些错误，往往是提前约定好的。</p>
<p>例如，<code>io</code> 包里的 <code>io.EOF</code>，表示“文件结束”错误。但是这种方式处理起来，不太灵活：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">"0123456789"</span>))</span><br><span class="line">	</span><br><span class="line">	_, err := r.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>))</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		log.Fatal(<span class="string">"read failed:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须要判断 <code>err</code> 是否和约定好的错误 <code>io.EOF</code> 相等。</p>
<p>再来一个例子，当我想返回 err 并且加上一些上下文信息时，就麻烦了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := readfile(“.bashrc”)</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(error.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readfile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := openfile(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(“cannot open file: %v<span class="string">", err)</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	// ……</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>readfile</code> 函数里判断 err 不为空，则用 fmt.Errorf 在 err 前加上具体的 <code>file</code> 信息，返回给调用者。返回的 err 其实还是一个字符串。</p>
<p>造成的后果时，调用者不得不用字符串匹配的方式判断底层函数 <code>readfile</code> 是不是出现了某种错误。当你必须要这样才能判断某种错误时，代码的“坏味道”就出现了。</p>
<p>顺带说一句，<code>err.Error()</code> 方法是给程序员而非代码设计的，也就是说，当我们调用 <code>Error</code> 方法时，结果要写到文件或是打印出来，是给程序员看的。在代码里，我们不能根据 <code>err.Error()</code> 来做一些判断，就像上面的 <code>main</code> 函数里做的那样，不好。</p>
<p><code>Sentinel errors</code> 最大的问题在于它在定义 error 和使用 error 的包之间建立了依赖关系。比如要想判断 <code>err == io.EOF</code> 就得引入 io 包，当然这是标准库的包，还 Ok。如果很多用户自定义的包都定义了错误，那我就要引入很多包，来判断各种错误。麻烦来了，这容易引起循环引用的问题。</p>
<p>因此，我们应该尽量避免 <code>Sentinel errors</code>，仅管标准库中有一些包这样用，但建议还是别模仿。</p>
<p>第二种就是 <code>Error Types</code>，它指的是实现了 <code>error</code> 接口的那些类型。它的一个重要的好处是，类型中除了 error 外，还可以附带其他字段，从而提供额外的信息，例如出错的行数等。</p>
<p>标准库有一个非常好的例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op   <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err  error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PathError</code> 额外记录了出错时的文件路径和操作类型。</p>
<p>通常，使用这样的 error 类型，外层调用者需要使用类型断言来判断错误：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// underlyingError returns the underlying error for known os error types.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">underlyingError</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *PathError:</span><br><span class="line">		<span class="keyword">return</span> err.Err</span><br><span class="line">	<span class="keyword">case</span> *LinkError:</span><br><span class="line">		<span class="keyword">return</span> err.Err</span><br><span class="line">	<span class="keyword">case</span> *SyscallError:</span><br><span class="line">		<span class="keyword">return</span> err.Err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这又不可避免地在定义错误和使用错误的包之间形成依赖关系，又回到了前面的问题。</p>
<p>即使 <code>Error types</code> 比 <code>Sentinel errors</code> 好一些，因为它能承载更多的上下文信息，但是它仍然存在引入包依赖的问题。因此，也是不推荐的。至少，不要把 <code>Error types</code> 作为一个导出类型。</p>
<p>最后一种，<code>Opaque errors</code>。翻译一下，就是“黑盒 errors”，因为你能知道错误发生了，但是不能看到它内部到底是什么。</p>
<p>譬如下面这段伪代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	x, err := bar.Foo()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// use x</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为调用者，调用完 <code>Foo</code> 函数后，只用知道 <code>Foo</code> 是正常工作还是出了问题。也就是说你只需要判断 err 是否为空，如果不为空，就直接返回错误。否则，继续后面的正常流程，不需要知道 err 到底是什么。</p>
<p>这就是处理 <code>Opaque errors</code> 这种类型错误的策略。</p>
<p>当然，在某些情况下，这样做并不够用。例如，在一个网络请求中，需要调用者判断返回的错误类型，以此来决定是否重试。这种情况下，作者给出了一种方法：</p>
<blockquote>
<p>In this case rather than asserting the error is a specific type or value, we can assert that the error implements a particular behaviour.</p>
</blockquote>
<p>就是说，不去判断错误的类型到底是什么，而是去判断错误是否具有某种行为，或者说实现了某个接口。</p>
<p>来个例子：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">	Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	te, ok := err.(temporary)</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到网络请求返回的 error 后，调用 <code>IsTemporary</code> 函数，如果返回 true，那就重试。</p>
<p>这么做的好处是在进行网络请求的包里，不需要 <code>import</code> 引用定义错误的包。</p>
<h2 id="handle-not-just-check-errors"><a href="#handle-not-just-check-errors" class="headerlink" title="handle not just check errors"></a>handle not just check errors</h2><p>这一节要说第二句箴言：“Don’t just check errors, handle them gracefully”。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     err := authenticate(r.User)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中的代码是有问题的，直接优化成一句就可以了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> authenticate(r.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他的问题，在函数调用链的最顶层，我们得到的错误可能是：<code>No such file or directory</code>。</p>
<p>这个错误反馈的信息太少了，不知道文件名、路径、行号等等。</p>
<p>尝试改进一下，增加一点上下文：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     err := authenticate(r.User)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"authenticate failed: %v"</span>, err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法实际上是先错误转换成字符串，再拼接另一个字符串，最后，再通过 <code>fmt.Errorf</code> 转换成错误。这样做破坏了相等性检测，即我们无法判断错误是否是一种预先定义好的错误了。</p>
<p>应对方案是使用第三方库：<code>github.com/pkg/errors</code>。提供了友好的界面：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrap annotates cause with a message.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(cause error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">// <span class="title">Cause</span> <span class="title">unwraps</span> <span class="title">an</span> <span class="title">annotated</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Cause</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>通过 <code>Wrap</code> 可以将一个错误，加上一个字符串，“包装”成一个新的错误；通过 <code>Cause</code> 则可以进行相反的操作，将里层的错误还原。</p>
<p>有了这两个函数，就方便很多：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"open failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	</span><br><span class="line">	buf, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个读文件的函数，先尝试打开文件，如果出错，则返回一个附加上了 “open failed” 的错误信息；之后，尝试读文件，如果出错，则返回一个附加上了 “read failed” 的错误。</p>
<p>当在外层调用 <code>ReadFile</code> 函数时：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	home := os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">	config, err := ReadFile(filepath.Join(home, <span class="string">".settings.xml"</span>))</span><br><span class="line">	<span class="keyword">return</span> config, errors.Wrap(err, <span class="string">"could not read config"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在 main 函数里就能打印出这样一个错误信息：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>

<p>它是有层次的，非常清晰。而如果我们用 <code>pkg/errors</code> 库提供的打印函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errors.Print(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能得到更有层次、更详细的错误：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfile.<span class="keyword">go</span>:<span class="number">27</span>: could not read config</span><br><span class="line">readfile.<span class="keyword">go</span>:<span class="number">14</span>: open failed</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>

<p>上面讲的是 <code>Wrap</code> 函数，接下来看一下 “Cause” 函数，以前面提到的 <code>temporary</code> 接口为例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">	Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	te, ok := errors.Cause(err).(temporary)</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断之前先使用 <code>Cause</code> 取出错误，做断言，最后，递归地调用 <code>Temporary</code> 函数。如果错误没实现 <code>temporary</code> 接口，就会断言失败，返回 <code>false</code>。</p>
<h2 id="Only-handle-errors-once"><a href="#Only-handle-errors-once" class="headerlink" title="Only handle errors once"></a>Only handle errors once</h2><p>什么叫“处理”错误：</p>
<blockquote>
<p>Handling an error means inspecting the error value, and making a decision.</p>
</blockquote>
<p>意思是查看了一下错误，并且做出一个决定。</p>
<p>例如，如果不做任何决定，相当于忽略了错误：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;  w.Write(buf) </span><br><span class="line">	w.Write(buf) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>w.Write(buf)</code> 会返回两个结果，一个表示写成功的字节数，一个是 error，上面的例子中没有对这两个返回值做任何处理。</p>
<p>下面这个例子却又处理了两次错误：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;  </span><br><span class="line">	 _, err := w.Write(buf) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">		<span class="comment">// annotated error goes to log file</span> </span><br><span class="line">		log.Println(<span class="string">"unable to write:"</span>, err)</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">// unannotated error returned to caller</span>  <span class="keyword">return</span> err </span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次处理是将错误写进了日志，第二次处理则是将错误返回给上层调用者。而调用者也可能将错误写进日志或是继续返回给上层。</p>
<p>这样一来，日志文件中会有很多重复的错误描述，并且在最上层调用者（如 main 函数）看来，它拿到的错误却还是最底层函数返回的 error，没有任何上下文信息。</p>
<p>使用第三方的 error 包就可以比较完美的解决问题：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Write, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123; </span><br><span class="line">	_, err := w.Write(buf) </span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(err, <span class="string">"write failed"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的错误，对于人和机器而言，都是友好的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一部分主要讲了处理 error 的一些原则，引入了第三方的 errors 包，使得错误处理变得更加优雅。</p>
<p>作者最后给出了一些结论：</p>
<blockquote>
<ol>
<li>errors 就像对外提供的 API 一样，需要认真对待。</li>
<li>将 errors 看成黑盒，判断它的行为，而不是类型。</li>
<li>尽量不要使用 sentinel errors。</li>
<li>使用第三方的错误包来包裹 error（errors.Wrap），使得它更好用。</li>
<li>使用 errors.Cause 来获取底层的错误。</li>
</ol>
</blockquote>
<h1 id="胎死腹中的-try-提案"><a href="#胎死腹中的-try-提案" class="headerlink" title="胎死腹中的 try 提案"></a>胎死腹中的 try 提案</h1><p>之前已经出现用 “check &amp; handle” 关键字和 “try 内置函数”改进错误处理流程的提案，目前 try 内置函数的提案已经被官方提前拒绝，原因是社区里一边倒地反对声音。</p>
<p>关于这两个提案的具体内容见参考资料【check &amp; handle】和【try 提案】。</p>
<h1 id="go-1-13-的改进"><a href="#go-1-13-的改进" class="headerlink" title="go 1.13 的改进"></a>go 1.13 的改进</h1><p>有一些 Go 语言失败的尝试，比如 Go 1.5 引入的 vendor 和 internal 来管理包，最后被滥用而引发了很多问题。因此 Go 1.13 直接抛弃了 <code>GOPATH</code> 和 <code>vendor</code> 特性，改用 <code>module</code> 来管理包。</p>
<p>柴大在《Go 语言十年而立，Go2 蓄势待发》一文中表示：</p>
<blockquote>
<p>比如最近 Go 语言之父之一 Robert Griesemer 提交的通过 try 内置函数来简化错误处理就被否决了。失败的尝试是一个好的现象，它表示 Go 语言依然在一些新兴领域的尝试 —— Go 语言依然处于活跃期。</p>
</blockquote>
<p>今年 9 月 3 号，Go 发布 1.13 版本，除了 module 特性转正之外，还改进了数字字面量。比较重要的还有 defer 性能提升 30%，将更多的对象从堆上移动到栈上以提升性能，等等。</p>
<blockquote>
<p>还有一个重大的改进发生在 errors 标准库中。errors 库增加了 Is/As/Unwrap三个函数，这将用于支持错误的再次包装和识别处理，为 Go 2 中新的错误处理改进提前做准备。</p>
</blockquote>
<p><code>1.13</code> 支持了 <code>error</code> 包裹（wrapping）：</p>
<blockquote>
<p>An error e can wrap another error w by providing an Unwrap method that returns w. Both e and w are available to programs, allowing e to provide additional context to w or to reinterpret it while still allowing programs to make decisions based on w.</p>
</blockquote>
<p>为了支持 wrapping，<code>fmt.Errorf</code> 增加了 <code>%w</code> 的格式，并且在 <code>error</code> 包增加了三个函数：<code>errors.Unwrap</code>，<code>errors.Is</code>，<code>errors.As</code>。</p>
<h2 id="fmt-Errorf"><a href="#fmt-Errorf" class="headerlink" title="fmt.Errorf"></a>fmt.Errorf</h2><p>使用 <code>fmt.Errorf</code> 加上 <code>%w</code> 格式符来生成一个嵌套的 error，它并没有像 <code>pkg/errors</code> 那样使用一个 Wrap 函数来嵌套 error，非常简洁。</p>
<h2 id="Unwrap"><a href="#Unwrap" class="headerlink" title="Unwrap"></a>Unwrap</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>将嵌套的 error 解析出来，多层嵌套需要调用 <code>Unwrap</code> 函数多次，才能获取最里层的 error。</p>
<p>源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否实现了 Unwrap 方法</span></span><br><span class="line">	u, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">		Unwrap() error</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 如果不是，返回 nil</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用 Unwrap 方法返回被嵌套的 error</span></span><br><span class="line">	<span class="keyword">return</span> u.Unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 err 进行断言，看它是否实现了 Unwrap 方法，如果是，调用它的 Unwrap 方法。否则，返回 nil。</p>
<h2 id="Is"><a href="#Is" class="headerlink" title="Is"></a>Is</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>判断 err 是否和 target 是同一类型，或者 err 嵌套的 error 有没有和 target 是同一类型的，如果是，则返回 true。</p>
<p>源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err == target</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 无限循环，比较 err 以及嵌套的 error</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 调用 error 的 Is 方法，这里可以自定义实现</span></span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回被嵌套的下一层的 error</span></span><br><span class="line">		<span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个无限循环，使用 <code>Unwrap</code> 不断地将 err 里层嵌套的 error 解开，再看被解开的 error 是否实现了 Is 方法，并且调用它的 Is 方法，当两者都返回 true 的时候，整个函数返回 true。</p>
<h2 id="As"><a href="#As" class="headerlink" title="As"></a>As</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>从 err 错误链里找到和 target 相等的并且设置 target 所指向的变量。</p>
<p>源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// target 不能为 nil</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: target cannot be nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	val := reflectlite.ValueOf(target)</span><br><span class="line">	typ := val.Type()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// target 必须是一个非空指针</span></span><br><span class="line">	<span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: target must be a non-nil pointer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保证 target 是一个接口类型或者实现了 Error 接口</span></span><br><span class="line">	<span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"errors: *target must be interface or implement error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	targetType := typ.Elem()</span><br><span class="line">	<span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="comment">// 使用反射判断是否可被赋值，如果可以就赋值并且返回true</span></span><br><span class="line">		<span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">			val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 调用 error 自定义的 As 方法，实现自己的类型断言代码</span></span><br><span class="line">		<span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不断地 Unwrap，一层层的获取嵌套的 error</span></span><br><span class="line">		err = Unwrap(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回 true 的条件是错误链里的 err 能被赋值到 target 所指向的变量；或者 err 实现的 <code>As(interface{}) bool</code> 方法返回 true。</p>
<p>前者，会将 err 赋给 target 所指向的变量；后者，由 As 函数提供这个功能。</p>
<p>如果 target 不是一个指向“实现了 error 接口的类型或者其它接口类型”的非空的指针的时候，函数会 panic。</p>
<p>这一部分的内容，飞雪无情大佬的文章【飞雪无情 分析 1.13 错误】写得比较好，推荐阅读。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go 语言使用 error 和 panic 处理错误和异常是一个非常好的做法，比较清晰。至于是使用 error 还是 panic，看具体的业务场景。</p>
<p>当然，Go 中的 error 过于简单，以至于无法记录太多的上下文信息，对于错误包裹也没有比较好的办法。当然，这些可以通过第三方库来解决。官方也在新发布的 go 1.13 中对这一块作出了改进，相信在 Go 2 里会有更进一步的优化。</p>
<p>本文还列举了一些处理 error 的示例，例如不要两次处理一个错误，判断错误的行为而不是类型等等。</p>
<p>参考资料里列举了很多错误处理相关的示例，这篇文章作为一个引子。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【Go 2 错误提案】<a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p>
<p>【check &amp; handle】<a href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md</a></p>
<p>【错误讨论的 issue】<a href="https://github.com/golang/go/issues/29934" target="_blank" rel="noopener">https://github.com/golang/go/issues/29934</a></p>
<p>【error value 的 FAQ】<a href="https://github.com/golang/go/wiki/ErrorValueFAQ" target="_blank" rel="noopener">https://github.com/golang/go/wiki/ErrorValueFAQ</a></p>
<p>【error 包】<a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">https://golang.org/pkg/errors/</a></p>
<p>【飞雪无情的博客 错误处理】<a href="https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html" target="_blank" rel="noopener">https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html</a></p>
<p>【飞雪无情 分析 1.13 错误】<a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html" target="_blank" rel="noopener">https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html</a></p>
<p>【Tony Bai Go语言错误处理】<a href="https://tonybai.com/2015/10/30/error-handling-in-go/" target="_blank" rel="noopener">https://tonybai.com/2015/10/30/error-handling-in-go/</a></p>
<p>【Go 官方 error 使用教程】<a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a></p>
<p>【Go FAQ】<a href="https://golang.org/doc/faq#exceptions" target="_blank" rel="noopener">https://golang.org/doc/faq#exceptions</a></p>
<p>【ethancai 错误处理】<a href="https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/" target="_blank" rel="noopener">https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/</a></p>
<p>【Dave cheney GoCon 2016 演讲】<a href="https://dave.cheney.net/paste/gocon-spring-2016.pdf" target="_blank" rel="noopener">https://dave.cheney.net/paste/gocon-spring-2016.pdf</a></p>
<p>【Morsing’s Blog Effective error handling in Go】<a href="http://morsmachine.dk/error-handling" target="_blank" rel="noopener">http://morsmachine.dk/error-handling</a></p>
<p>【如何优雅的在Golang中进行错误处理】<a href="https://www.ituring.com.cn/article/508191" target="_blank" rel="noopener">https://www.ituring.com.cn/article/508191</a></p>
<p>【Go 2 错误处理提案：try 还是 check？】<a href="https://toutiao.io/posts/uh9qo7/preview" target="_blank" rel="noopener">https://toutiao.io/posts/uh9qo7/preview</a></p>
<p>【try 提案】<a href="https://github.com/golang/go/issues/32437" target="_blank" rel="noopener">https://github.com/golang/go/issues/32437</a></p>
<p>【否决 try 提案】<a href="https://github.com/golang/go/issues/32437#issuecomment-512035919" target="_blank" rel="noopener">https://github.com/golang/go/issues/32437#issuecomment-512035919</a></p>
<p>【Go 语言的错误处理机制是一个优秀的设计吗？】<a href="https://www.zhihu.com/question/27158146/answer/44676012" target="_blank" rel="noopener">https://www.zhihu.com/question/27158146/answer/44676012</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/09/18/golang-error-break-through/">https://qcrao.com/2019/09/18/golang-error-break-through/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2019/11/10/dive-into-go-pprof/">深度解密Go语言之pprof</a><a class="next" href="/2019/09/06/dive-into-go-scheduler-source-code/">深度解密调度器源码系列</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/故障排查/" style="font-size: 15px;">故障排查</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/dive-into-go-sync-map/">深度解密Go语言之sync.map</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/accident/">“���”引发的线上事故</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/dive-into-go-sync-pool/">深度解密Go语言之sync.pool</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/talk-about-g0/">聊聊 g0</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/23/how-to-traverse-defer-links/">defer 链表如何被遍历执行</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/high-performance-mysql-reading-notes/">《高性能 MySQL》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/dive-into-go-pprof/">深度解密Go语言之pprof</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/18/golang-error-break-through/">Golang error 的突围</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/dive-into-go-scheduler-source-code/">深度解密调度器源码系列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/dive-into-go-scheduler/">深度解密Go语言之scheduler</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="Panda - Just for fun" target="_blank">Panda - Just for fun</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">167.7k</span><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 鄂ICP备20006251号-1</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>