<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qcrao</title>
  
  <subtitle>码农桃花源</subtitle>
  <link href="https://qcrao.com/atom.xml" rel="self"/>
  
  <link href="https://qcrao.com/"/>
  <updated>2021-09-11T07:04:10.000Z</updated>
  <id>https://qcrao.com/</id>
  
  <author>
    <name>饶全成</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写 Go 时如何优雅地查文档</title>
    <link href="https://qcrao.com/2021/09/11/look-up-go-doc-gracefully/"/>
    <id>https://qcrao.com/2021/09/11/look-up-go-doc-gracefully/</id>
    <published>2021-09-11T06:38:54.000Z</published>
    <updated>2021-09-11T07:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>某天写代码时发现自己对 IDE 的依赖非常深，如果没了 Goland 就不会写代码了，心里为之一惊。</p><p>Goland 的自动补全功能已经是必需品了，只要打出相关的几个字符，不管是变量名还是函数调用，都能帮你直接补全。我们只需要往相应的位置填东西就行了。</p><p>进而又想到，当补全功能缺失或者暂时失灵的情况下，该如何快速地查出某个函数的具体用法呢？</p><p>假设我们想要对字符串做 split，却忘了具体用法，下面是几种常见的查文档方法。</p><h1 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h1><p><img src="https://user-images.githubusercontent.com/7698088/132242306-1d6fe5ce-b89e-4cf8-ba88-7618b249f5cd.png" alt="google"></p><p>在设置了语言是 english 的情况下，还是挺精准的。直接定位到 Go 官方文档。</p><h1 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h1><p><img src="https://user-images.githubusercontent.com/7698088/132242453-c88c0ae5-ee56-4bf7-b701-c2aae2b601f2.png" alt="Dash"></p><p>同样很准确，搜索词不需要很精准。</p><h1 id="devdocs-io"><a href="#devdocs-io" class="headerlink" title="devdocs.io"></a><a href="https://devdocs.io/" target="_blank" rel="noopener">devdocs.io</a></h1><p><img src="https://user-images.githubusercontent.com/7698088/132287580-e8e9193d-3cb9-44c7-98d8-429f8570c706.png" alt="devdocs"></p><p>这个也不错，而且支持很多种语言。</p><h1 id="pkg-go-dev"><a href="#pkg-go-dev" class="headerlink" title="pkg.go.dev"></a>pkg.go.dev</h1><p><img src="https://user-images.githubusercontent.com/7698088/132287692-8bdc84be-18ec-4229-86fb-1cd130e99579.png" alt="pkg.go.dev"></p><p>优点是官方文档，最权威，逼格最高。缺点是要准确地记住包名+函数名。</p><h1 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h1><p><img src="https://user-images.githubusercontent.com/7698088/132287796-42eff622-094c-4243-93e0-c12dfd08d29c.png" alt="cmd"></p><p>优点是直接 iTerm2 里就可以查看，缺点是需要准确地记住包名+函数名。</p><p>有些大佬用 vim 写代码，在 shell 环境里直接能查文档，还是很有用的。不过对我等用 Goland 的菜鸡用处不大。😂</p><hr><p>上面这几种方法我用得最多的还是 Google，可能这并不是最快的方式，但是它总是能帮你找到所有有用的信息。没有 Google，我可能也不会写代码了。</p><p>最近看到一篇<a href="https://eli.thegreenplace.net/2018/command-line-autocomplete-for-go-documentation/" target="_blank" rel="noopener">文章</a>，就讲了如何利用 Go 标准库做出一个好用的查文档工具。</p><p>原理是利用 Go 提供的包解析工具，把所有的导出类型列出来。然后在我们搜索的时候用模糊匹配的方式找到符合的类型，再用这个精确的类型调用 <code>go doc</code>。</p><p>流程如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/132241591-98ddfbc9-fbb1-4ac8-825e-3fb8c474f365.png" alt="gdoc 原理"></p><p>在 Linux 下结合 dmenu，使用非常顺滑：</p><p><img src="https://user-images.githubusercontent.com/7698088/132288678-e34bfe08-054f-4188-a5d4-b7943b3bb945.png" alt="gdoc-cmd"></p><p>偷个懒，直接用原文的动图。😀</p><p>当然，不嫌弃浏览器的情况下，还提供了一个可视化的界面，同样有模糊匹配的功能且可以一键直达 <code>pkg.go.dev</code> 对应的页面。比 google 可能快一点。</p><p><img src="https://user-images.githubusercontent.com/7698088/132288730-aa607742-38e9-4e19-8dde-faf28405ab01.png" alt="gdoc-web"></p><p>选中其中一个，会直接跳转过来：</p><p><img src="https://user-images.githubusercontent.com/7698088/132288771-fdcd821c-004e-46f7-90d6-ac5f6e139a88.png" alt="跳转到 pkg.go.dev"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不过，即使知道了这些方法，可能最后还是会退化到用 Google 直接搜，因为啥都不需要记，所有的东西都可以用 Google 搜索出来。</p><p>这也是最方便的方法，什么额外的事情都不用做。因为方便，成本低，自然就想把所有的事情都挪到它上面来做，即使有很多专业的查文档工具的情况下，还是会这么做。</p><p>一件事，如果容易，那就会经常做。反之，如果成本比较高，结果不是做这件事花的时间更多，而是我们选择不去做它。</p><p>不知道你平时查文档时用的什么方法，欢迎留言一起讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;某天写代码时发现自己对 IDE 的依赖非常深，如果没了 Goland 就不会写代码了，心里为之一惊。&lt;/p&gt;
&lt;p&gt;Goland 的自动补全功能已经是必需品了，只要打出相关的几个字符，不管是变量名还是函数调用，都能帮你直接补全。我们只需要往相应的位置填东西就行了。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>从 map 的 extra 字段谈起</title>
    <link href="https://qcrao.com/2021/08/09/talk-about-map-extra-field/"/>
    <id>https://qcrao.com/2021/08/09/talk-about-map-extra-field/</id>
    <published>2021-08-09T15:43:50.000Z</published>
    <updated>2021-08-09T15:44:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉 map 结构体的读者应该知道，hmap 由很多 bmap（bucket） 构成，每个 bmap 都保存了 8 个 key/value 对：</p><p><img src="https://i.loli.net/2021/08/08/VUBwJ6532YGAmoz.png" alt="hmap"></p><p>有时落在同一个 bmap 中的 key/value 太多了，超过了 8 个，就会由溢出 bmap 来承接，即 overflow bmap（后面我们叫它 bucket）。溢出的 bucket 和原来的 bucket 形成一个“拉链”。</p><p>对于这些 overflow 的 bucket，在 hmap 结构体和 bmap 结构体里分别有一个 <code>extra.overflow</code> 和 <code>overflow</code> 字段指向它们。</p><p>如果我们仔细看 mapextra 结构体里对 overflow 字段的注释，会发现这里有“文章”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">overflow    *[]*bmap</span><br><span class="line">oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>overflow</code> 这个字段上面有一大段注释，我们来看看前两行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If both key and elem do not contain pointers and are inline, then we mark bucket</span></span><br><span class="line"><span class="comment">// type as containing no pointers. This avoids scanning such maps.</span></span><br></pre></td></tr></table></figure><p>意思是如果 map 的 key 和 value 都不包含指针的话，在 GC 期间就可以避免对它的扫描。在 map 非常大（几百万个 key）的场景下，能提升不少性能。</p><p>那具体是怎么实现“不扫描”的呢？</p><p>我们知道，bmap 这个结构体里有一个 overflow 指针，它指向溢出的 bucket。因为它是一个指针，所以 GC 的时候肯定要扫描它，也就要扫描所有的 bmap。</p><p>而当 map 的 key/value 都是非指针类型的话，扫描是可以避免的，直接标记整个 map 的颜色（三色标记法）就行了，不用去扫描每个 bmap 的 overflow 指针。</p><p>但是溢出的 bucket 总是可能存在的，这和 key/value 的类型无关。</p><p>于是就利用 hmap 里的 extra 结构体的 overflow 指针来 “hold” 这些 overflow 的 bucket，并把 bmap 结构体的 overflow 指针类型变成一个 unitptr 类型（这些是在编译期干的）。于是整个 bmap 就完全没有指针了，也就不会在 GC 期间被扫描。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow    *[]*bmap</span><br></pre></td></tr></table></figure><p>另一方面，当 GC 在扫描 hmap 时，通过 <code>extra.overflow</code> 这条路径（指针）就可以将 overflow 的 bucket 正常标记成黑色，从而不会被 GC 错误地回收。</p><p>当我们知道上面这些原理后，就可以利用它来对一些场景进行性能优化：</p><blockquote><p>map[string]int -&gt; map[[12]byte]int</p></blockquote><p>因为 string 底层有指针，所以当 string 作为 map 的 key 时，GC 阶段会扫描整个 map；而数组 <code>[12]byte</code> 是一个值类型，不会被 GC 扫描。</p><p>我们用两种方法来验证优化效果。</p><h1 id="主动触发-GC"><a href="#主动触发-GC" class="headerlink" title="主动触发 GC"></a>主动触发 GC</h1><p>这里的测试代码来自文章<a href="https://www.jianshu.com/p/5903323a7110" target="_blank" rel="noopener">《尽量不要在大 map 中保存指针》</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapWithPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">10000000</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        n := strconv.Itoa(i)</span><br><span class="line">        m[n] = n</span><br><span class="line">    &#125;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    runtime.GC()     </span><br><span class="line">    fmt.Printf(<span class="string">"With a map of strings, GC took: %s\n"</span>, time.Since(now))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用一下防止被 GC 回收掉</span></span><br><span class="line">    _ = m[<span class="string">"0"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapWithoutPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">10000000</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">        str := strconv.Itoa(i)</span><br><span class="line">        <span class="comment">// hash string to int</span></span><br><span class="line">        n, _ := strconv.Atoi(str)</span><br><span class="line">        m[n] = n</span><br><span class="line">    &#125;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    runtime.GC()</span><br><span class="line">    fmt.Printf(<span class="string">"With a map of int, GC took: %s\n"</span>, time.Since(now))</span><br><span class="line"></span><br><span class="line">    _ = m[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMapWithPointer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    MapWithPointer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMapWithoutPointer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    MapWithoutPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接用了 2 个不同类型的 map：前者 key 和 value 都是 string 类型，后者 key 和 value 都是 int 类型。整个 map 大小为 1kw。</p><p>测试结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestMapWithPointer</span><br><span class="line">With a map of strings, GC took: 150.078ms</span><br><span class="line">--- PASS: TestMapWithPointer (4.22s)</span><br><span class="line">=== RUN   TestMapWithoutPointer</span><br><span class="line">With a map of int, GC took: 4.9581ms</span><br><span class="line">--- PASS: TestMapWithoutPointer (2.33s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>于是验证了 string 相对于 int 这种值类型对 GC 的消耗更大。正如这篇文章的标题所说：</p><blockquote><p>Go语言使用 map 时尽量不要在 big map 中保存指针。</p></blockquote><h1 id="用-pprof-看对象数"><a href="#用-pprof-看对象数" class="headerlink" title="用 pprof 看对象数"></a>用 pprof 看对象数</h1><p>第二种方式就是直接开个 pprof 来看 heap profile。这次我们将 string 类型的 key 优化成数组类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// var m = map[[12]byte]int&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line"><span class="comment">// var arr [12]byte</span></span><br><span class="line"><span class="comment">// copy(arr[:], fmt.Sprint(i))</span></span><br><span class="line"><span class="comment">// m[arr] = i</span></span><br><span class="line"></span><br><span class="line">m[fmt.Sprint(i)] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(wr ,<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，去掉代码里的注释即可将 key 从 string 优化成数组类型。</p><p>直接在 init 里构建 map，然后开 pprof 看 profile：</p><p><img src="https://i.loli.net/2021/08/08/OgREqurjtYS2zbv.png" alt="key 为 string"></p><p><img src="https://i.loli.net/2021/08/08/i2tb6PDyLoucw8x.png" alt="key 为数组"></p><p>对象数从 33w 下降到 1.5w，效果非常明显。</p><blockquote><p>map 的 key 和 value 要不要在 GC 里扫描，和类型是有关的。数组类型是个值类型，string 底层也是指针。</p></blockquote><blockquote><p>不过要注意，key/value 大于 128B 的时候，会退化成指针类型。</p></blockquote><blockquote><p>那么问题来了，什么是指针类型呢？**所有显式 *T 以及内部有 pointer 的对像都是指针类型。</p></blockquote><blockquote><p>——来自董神的 map <a href="https://mp.weixin.qq.com/s/jGGCccMOx4s5asG2IXWNMQ" target="_blank" rel="noopener">优化文章</a></p></blockquote><p>关于超过 128 字节的情况，源码里也有说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum key or elem size to keep inline (instead of mallocing per element).</span></span><br><span class="line">maxKeySize  = <span class="number">128</span></span><br><span class="line">maxElemSize = <span class="number">128</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当 map 的 key/value 是非指针类型时，GC 不会对所有的 bucket 进行扫描。如果线上服务使用了一个超大的 map ，会因此提升性能。</p><p>为了不让 overflow 的 bucket 被 GC 错误地回收掉，在 hmap 里用 extra.overflow 指针指向它，从而在三色标记里将其标记为黑色。</p><p>如果你用了 key 是 string 类型的 map，并且恰好这些 string 是定长的，那么就可以用 key 为数组类型的 map 来优化它。</p><p>通过主动调用 GC 以及开 pprof 都可观察优化效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;熟悉 map 结构体的读者应该知道，hmap 由很多 bmap（bucket） 构成，每个 bmap 都保存了 8 个 key/value 对：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/08/VUBwJ6532YGAmoz.p</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>如何给 Go 提性能优化的 pr</title>
    <link href="https://qcrao.com/2021/08/03/go-tls-pr-by-xargin/"/>
    <id>https://qcrao.com/2021/08/03/go-tls-pr-by-xargin/</id>
    <published>2021-08-03T15:43:04.000Z</published>
    <updated>2021-08-09T15:45:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇<a href="https://mp.weixin.qq.com/s/vMM2tKEGJUproWMhycVtog" target="_blank" rel="noopener">《成为 Go Contributor》</a> 的文章，讲了如何给 Go 提一个 typo 的 pr，以此熟悉整个流程。当然，离真正的 Contributor 还差得远。</p><p>开课前曹大在 Go 夜读上讲了他给 Go 提的一个关于 <a href="https://www.bilibili.com/video/BV1Z64y1m7uc" target="_blank" rel="noopener">tls 的性能优化</a>，课上又细讲了下，本文就带大家来学习下他优化了啥以及如何看优化效果。</p><p>第一次提的 pr 在<a href="https://go-review.googlesource.com/c/go/+/263277" target="_blank" rel="noopener">这里</a>，之后又挪到了一个新的<a href="https://go-review.googlesource.com/c/go/+/267957" target="_blank" rel="noopener">位置</a>，前后有一些代码上的简化，最后看着挺舒服。</p><p>优化前每个 tls 连接上都有一个 <code>write buffer</code>，但是活跃的连接数很少，很多内存都被闲置了，这种就可以用 sync.Pool 来优化了。</p><p><img src="https://user-images.githubusercontent.com/7698088/127991523-b5d898c0-919c-4b11-be1c-b29816c3ba64.png" alt="conn"></p><p>用 sync.Pool 缓存 <code>[]byte</code>，并顺带将连接上的一个 outBuf 字段给干掉了：</p><p><img src="https://user-images.githubusercontent.com/7698088/127991930-34eee5d5-6176-458b-a7b8-c243a6b44950.png" alt="files changed"></p><p>整体上改动挺少，效果也不错。</p><p>虽然一开始给了 <code>_test</code> 文件，但其实并不能太好反映性能的提升。因此后面曹大又写了一个简单的 client 和 server 来实际测试。</p><p>我在开发机上测了一下，优化还是挺明显的。这又是一个使用 pprof 查看性能优化的好例子。</p><p><code>client</code> 的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/tls"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"go.uber.org/ratelimit"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := os.Args[<span class="number">3</span>]</span><br><span class="line">connNum, err := strconv.ParseInt(os.Args[<span class="number">1</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qps, err := strconv.ParseInt(os.Args[<span class="number">2</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bucket := ratelimit.New(<span class="keyword">int</span>(qps))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line">connList := <span class="built_in">make</span>([]*http.Client, connNum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">bucket.Take()</span><br><span class="line">i := i</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">if</span> connList[i%<span class="built_in">len</span>(connList)] == <span class="literal">nil</span> &#123;</span><br><span class="line">connList[i%<span class="built_in">len</span>(connList)] = &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;http.Transport&#123;</span><br><span class="line">TLSClientConfig:     &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">IdleConnTimeout:     <span class="number">0</span>,</span><br><span class="line">MaxIdleConns:        <span class="number">1</span>,</span><br><span class="line">MaxIdleConnsPerHost: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">conn := connList[i%<span class="built_in">len</span>(connList)]</span><br><span class="line">l.Unlock()</span><br><span class="line"><span class="keyword">if</span> resp, e := conn.Get(url); e != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(e)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">ioutil.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，就是固定连接数、固定 QPS 向服务端发请求。</p><p><code>server</code> 的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">wr.Header()[<span class="string">"Content-Length"</span>] = []<span class="keyword">string</span>&#123;fmt.Sprint(<span class="built_in">len</span>(content))&#125;</span><br><span class="line">wr.Header()[<span class="string">"Content-Type"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"application/json"</span>&#125;</span><br><span class="line">wr.Write(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.ListenAndServe(<span class="string">":3333"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayhello)</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServeTLS(<span class="string">":4443"</span>, <span class="string">"server.crt"</span>, <span class="string">"server.key"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也很简单，起了一个 tls server，并注册了一个 sayhello 接口。</p><p>启动 server 后，先用 1.15（1.17 之前的版本都可以，曹大的改动还没合入）测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run server.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1000 个连接，100 个 QPS</span></span><br><span class="line">go run client.go 1000 100 https://localhost:4443</span><br></pre></td></tr></table></figure><p>查看 server 的内存 profile。后面还会用 <code>--base</code> 的命令，比较前后两个 profile 文件的差异。</p><p><code>pprof</code> 的命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof --http=:8000 http://127.0.0.1:3333/debug/pprof/heap</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/127993938-98add38d-862e-4df5-ba4c-ac3f57b16649.png" alt="Go 1.15 mem profile"></p><p>看看这个大“平顶山”，有那味了（平顶山表示可以优化，如果是那种特别窄的尖尖就没办法了）~</p><p>因为这个 pr 已经合到了 1.17，我们再用 1.17 来测一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go1.17rc1 run server.go</span><br><span class="line">go1.17rc1 run client.go 1000 100 https://localhost:4443</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/127994165-147bc9f9-56c8-4888-9793-c751da6b8a3a.png" alt="Go 1.17 mem profile"></p><p>为了使用 <code>--base</code> 命令来进行比较，需要把 profile 文件保存下来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:3333/debug/pprof/heap &gt; mem.1.14</span><br><span class="line">curl http://127.0.0.1:3333/debug/pprof/heap &gt; mem.1.17</span><br></pre></td></tr></table></figure><p>最后来比较优化前后的差异：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -http=:8000 --base mem.1.15 mem.1.17</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/127995168-6a648836-01bb-4a20-b21b-12203e95a1d6.png" alt="--base"></p><p>优化效果还是很明显的。我们来看菜单栏里的 <code>view-&gt;top</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/127995312-ace757cf-7259-4ad0-bf3c-7c1526ec7248.png" alt="view-&gt;top"></p><p>整个优化从最终的提交来看还挺简单，但是能发现问题所在，并能结合自己的知识储备进行优化还是挺难的。我们平时也要多积累相关的优化经验，到关键时候才能顶上去。像 pprof 的使用，要自己多加练习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前写了一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/vMM2tKEGJUproWMhycVtog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《成为 Go Contributor》&lt;/a&gt; 的文章，讲了如何给 Go 提一个</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>开始积累自己的工具库</title>
    <link href="https://qcrao.com/2021/07/21/start-to-build-up-personal-tools/"/>
    <id>https://qcrao.com/2021/07/21/start-to-build-up-personal-tools/</id>
    <published>2021-07-21T15:42:31.000Z</published>
    <updated>2021-08-09T15:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你有没有这样的经验：看了很多计算机相关的书，觉得自己懂得很多，但是一遇到实际问题，就不会解。</p><p>再看身边的老司机，执行几行命令，看了几个指标，就准确地定位问题了。他可能也没看那么多理论，但实战能力确实强，心里一下子就失衡了。</p><p>这其中有很多原因，我认为其中有一个比较重要的就是：工具的使用。老司机因为经验多，积累了很多 命令、shell 脚本、代码库……这些东西就像瑞士军刀，关键时刻，直接就可以派上大用场。在线上出问题的时候，云淡风轻地说，这行代码有问题，删掉就可以了。潇洒至极！</p><p>今天我就把我最近积累的一些工具，包括一些软件、命令，这些是可以直接用于实战的。希望看完之后，能提升你的战斗力。</p><h1 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h1><p>今天推荐 2 个我日常用得比较多的，提升效率的软件：aText、paste。</p><h2 id="aText"><a href="#aText" class="headerlink" title="aText"></a>aText</h2><p><code>aText</code> 是一个输入映射的软件，输入预先设定的字符串，就可以转成设定好的目标字符串。我用 aText 存了很多有用的映射，例如，我把打开博客文章的命令缩写成了 <code>XPosts</code>：  </p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210720232555.png"></p><p>因为博客文件所在的路径比较长，如果我每次都直接敲出完整路径的话，会很麻烦。有了这个映射后，只用输入 <code>XPosts</code> 就自动变成了我要的文件路径。</p><p>还有很多场景可以使用 <code>aText</code>，尤其是你经常要输入的相同的内容，非常方便。</p><h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p><code>paste</code> 管理剪贴版的历史，只要是你复制过的内容，它都会保存下来，甚至可以对文本内容进行搜索。</p><p>比如可以把开发、排查问题时常用的链接、命令都放到一个 tab 下面，要用的时候，直接快捷键调出，怎一个优雅了得。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210720234152.png"></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>这部分挑了一些非常有用的命令出来，大家可以记在笔记里，关键时候直接拿出来用。</p><h2 id="查看-cache-size"><a href="#查看-cache-size" class="headerlink" title="查看 cache size"></a>查看 cache size</h2><p>看 Go 源码的时候，经常能看到一些 pad 字段，这个字段主要是用来防止 <code>false sharing</code>，一般是根据 cache line size 来算 pad 大小的。那么查看这个 size 的大小呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LEVEL1_DCACHE_LINESIZE</span><br></pre></td></tr></table></figure><h2 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h2><p>有时候会遇到一些和内核版本相关的问题，例如 Go 语言里面的内存归还策略在 Go 1.12 有一个改动，将 <code>MADV_FREE</code> 改成了 <code>MADV_DONTNEED</code>，导致线上应⽤的 RSS ⼤幅上升。</p><blockquote><p>使用 <code>MADV_FREE</code> 方式，程序内存不会立刻回收，即 RSS 值不会立刻下降，只有当 OS 内存紧缺时才会回收 Go 程序的内存；</p></blockquote><blockquote><p>而 Go 1.11 以及之前的版本默认采用的是 <code>MADV_DONTNEED</code> 方式，程序 RSS 值下降很快。</p></blockquote><blockquote><p>因此如果需要使程序内存占用下降很慢的话，可设置环境变量 <code>GODEBUG=madvdontneed=1</code>。</p></blockquote><p>另外，<code>MADV_FREE</code> 只在 Linux 4.5 及之后的版本才有，所以当你遇到 RSS 一直降不下去的场景时，要想确认是不是这个问题导致的，还得看你的内核版本是啥。那就用这个命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>这个归还内存的策略在 Go 1.16 又改回去了。因此只有在 Go 1.12-Go 1.15 之间，且是 Linux 4.5 及之后的内核版本才会有这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210721082338.png"></p><h2 id="输出代码行号"><a href="#输出代码行号" class="headerlink" title="输出代码行号"></a>输出代码行号</h2><p>有时候需要用 <code>cat</code> 命令输出一段代码，截图发给别人。这时如果需要对着代码行号做一些说明的话，把代码行号一并输出来是非常 nice 的，只需要用这个命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n a.go</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210721000709.png"></p><h2 id="汇总展示代码构成"><a href="#汇总展示代码构成" class="headerlink" title="汇总展示代码构成"></a>汇总展示代码构成</h2><p>当我们想看一个开源项目的代码行数的时候，并且能看到各种类型的语言各占多少的时候，怎么办呢？一个命令搞定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokei ./</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210721001151.png"></p><p>就问你强不强！</p><p>这个用在什么场景呢？太多了，例如你准备看一个稍微简单一点的框架，有几个侯选的：chi, echo, gin……执行一下命令，看看代码行数，选择一个最少的。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>工具是很重要的，积累了很多前人的智慧，我们拿来直接用，不需要自己再从零开始。当然，适当地学习原理也是必须的。</p><p>我们要记住这些命令，存入自己的工具库，要用的时候直接调出来。它们可以节省我们大脑的内存，把宝贵的资源用在思考真正的问题上，而不是记住这些命令。</p><p>而且当我们有了自己的代码码、脚本库、工具库的时候，遇到问题，拿上相应的家伙上场，马上就可以得到很多相关的信息，我们再根据这些信息做决策。</p><p>今天就先列这些吧，其实还准备了好几个关于 Go 的，先不放出来。如果这篇比较受欢迎，就下期再写了。</p><p>最后，也欢迎在留言区分享你的工具，无论是软件，还是一行命令。我会汇总后再分享给大家，切实有效地提升大家的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道你有没有这样的经验：看了很多计算机相关的书，觉得自己懂得很多，但是一遇到实际问题，就不会解。&lt;/p&gt;
&lt;p&gt;再看身边的老司机，执行几行命令，看了几个指标，就准确地定位问题了。他可能也没看那么多理论，但实战能力确实强，心里一下子就失衡了。&lt;/p&gt;
&lt;p&gt;这其中有很多原因</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个 metrics 打点引发的事故</title>
    <link href="https://qcrao.com/2021/07/19/accident-by-a-metric/"/>
    <id>https://qcrao.com/2021/07/19/accident-by-a-metric/</id>
    <published>2021-07-19T15:28:24.000Z</published>
    <updated>2021-08-09T15:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上事故频发，搞得焦头烂额，但是能用上跟曹大学的知识并定位出了问题，还是值得高兴一把的。毕竟“打破砂锅问到底”，“定位出根因”一直是技术人的优良品质。</p><p>虽然我们总是逃不过事故驱动开发的魔咒，但吃一堑长一智，看别人的事故，学到的是自己的能力。</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>一个平凡的午高峰，服务在全量上线的过程中，碰到一个非常重要的下游接口超时（后来发现该下游也在上线，可用实例数变少，正常实例负载变高，超时了一丢丢），拿不到该拿的数据，阻塞了启动。这样，打到线上正常实例上的流量就增加了。</p><p>不大会儿，线上大量实例 OOM，报警满天飞。不得已，回滚（遇到事故，第一件事就是回滚）。没想到，回滚无效，OOM 的实例数还是一直在增加，给跪了。</p><p>中间查到服务在启动过程中，一直在尝试调那个超时的下游，就临时把超时时间加大，并取消回滚，紧急上线了一把。</p><p>之后，正常启动的实例越来越多，服务逐渐恢复。</p><h1 id="第一天排查"><a href="#第一天排查" class="headerlink" title="第一天排查"></a>第一天排查</h1><p>发生事故之后就是排查过程了。</p><p>第一天，只查到了 OOM 的实例 goroutine 数暴涨，接口 QPS 有尖峰，比正常翻了几倍。所以，得到的结论就是接口流量太多，超过服务极限，导致 OOM。</p><p>接着尝试在预览环境压测，没有复现 OOM，gg。</p><p>结论有问题！</p><h1 id="第二天排查"><a href="#第二天排查" class="headerlink" title="第二天排查"></a>第二天排查</h1><p>第二天运气比较好，发现了线上有一个实例在不断地重启，一看监控，发现正常启动后，5 分钟左右就 OOM 了。</p><p>有现场就不慌。</p><p>正好跟着曹大学会了如何用 pprof 查问题，马上就安排，三下五除二就搞定了。</p><p>先看 inuse_space：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210718233301.png" alt="inuse_space"></p><p>虽然，这个 model 占用的内存比较高，但这是正常的业务逻辑，看了看相关的代码最近也没有改动。</p><p><strong>所以，这个只能是果，不是因。</strong></p><p>再看 CPU：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210718233443.png" alt="CPU"></p><p>中间加粗的红色线条和方框就差要告诉我有问题的代码在哪一行了！图上方有调 metrics 的函数名（这里没展示出来），一搜就搜出来了。</p><p>再看了下 goroutine：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210718233653.png" alt="goroutine"></p><p>结论还是一样的。</p><p>顺着图上的函数名，马上就在一个多重嵌套循环里找到了一处不那么显眼的打点。</p><p><code>metrics</code> 打点的剧本我熟，之前看了曹大的“几个 Go 系统可能遇到的锁问题”的文章（点击阅读原文可读），逻辑大概是这样的：</p><blockquote><p>由于 <code>metrics</code> 底层是用 udp 发送的，有文件锁，大量打点的情况下，会引起激烈的锁冲突，造成 goroutine 堆积、请求堆积，和请求关联的 model 无法释放，于是就 OOM 了。</p></blockquote><p>然后我们替换 bin 上到这台 OOM 的机器，果然恢复正常了，收工！</p><p>最后看了下 metrics 的代码，其实还不是文件锁的原因。不过也差不多了，也是一把大锁，所有 goroutine 的打点都会先 append 到一个 slice 里，append 前要先加锁。</p><p>由于这个地方的打点非常多，几十万 QPS，一冲突，goroutine 都 gopark 去等锁了，持有的内存无法释放，服务一会儿就 gg 了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引发这次事故的代码其实是一年多前写的，跑了一年都没出事，这次就遇到了，你说可气不？</p><p>幸亏不是自己写的，但也要敲个警钟：我写的每一行代码，将来都可能会引发事故，一定要认真对待。</p><p>遇到 OOM 不可怕，有现场就行。拿不到现场，我也没啥好办法。实在不行，用曹大的 holmes 试试，这个工具还是很厉害的，还帮曹大贡献了个 golang 的 mr。</p><p>平时要多看相关的事故排查文章，必要的时候练习一下 pprof 工具的使用，关键的时候还是能顶用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近线上事故频发，搞得焦头烂额，但是能用上跟曹大学的知识并定位出了问题，还是值得高兴一把的。毕竟“打破砂锅问到底”，“定位出根因”一直是技术人的优良品质。&lt;/p&gt;
&lt;p&gt;虽然我们总是逃不过事故驱动开发的魔咒，但吃一堑长一智，看别人的事故，学到的是自己的能力。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地指定配置项</title>
    <link href="https://qcrao.com/2021/07/15/how-to-use-functional-options-pattern/"/>
    <id>https://qcrao.com/2021/07/15/how-to-use-functional-options-pattern/</id>
    <published>2021-07-15T15:28:02.000Z</published>
    <updated>2021-08-09T15:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个年久失修的库导致了线上事故，不得不去做一些改进。</p><p>这个陈年库的作用是调用第三方的 RPC 拿一些比较重要的配置，业务代码中有段逻辑会根据读到的配置调用不同端的下游。如果没拿到配置，就会默认地调一个兜底下游。恰好这个兜底下游最近新上了一些逻辑，不兼容这种跨端调用，直接把它打挂了。</p><p>先抛开这个下游不健壮不谈，假设它是健壮的。</p><p>陈年库的问题在于：进程启动时它会去调一个下游拿数据，之后会定时更新。但如果启动时调用失败就直接 panic 了，所以之后也不会定时更新。理论上这个也没什么问题，服务在初始化时如果检测到了库的 panic，进程退出，重启就好了。</p><p>但是阻塞启动是比较危险的，所以有些服务就会吞掉 panic。于是，整个进程生命周期内这个配置就一直是缺失的状态。</p><p>因为阻塞服务的启动风险太高，所以当前的状态是把 panic recover 住了，但是之后这个配置也就一直没有更新的机会了。而陈年库其实是可以在后台静默更新数据的。</p><p>因此我要对陈年库要做一点改进：如果初始化时拉取配置失败，不 panic，后台静默修复。这个设置要在调用 Init 函数时设置，因为库就暴露了 Init 和 Get 函数。</p><p>但因为这个库有很多使用方，所以不可能更改函数签名和现在的行为，否则影响其他人使用。万一有业务都对这个是强依赖，就是要感知 panic，初始化失败就进程退出，你改了不就 gg 了。</p><p>我们知道，Go 语言里面有可变参数，调用它的时候可以不传实参，或者传多个实参。向陈年库函数的 Init 函数签名后加一个可变参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(a <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(a <span class="keyword">int</span>, opts ...optionFunc)</span></span></span><br></pre></td></tr></table></figure><p>这样就不影响已有的用户了，并且我可以增加更多的设置项。这里的关键是 <code>optionFunc</code> 的实现原理是什么？</p><p>它其实是一个函数类型，它接受 <code>options</code> 结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> optionFunc <span class="function"><span class="keyword">func</span><span class="params">(*options)</span></span></span><br></pre></td></tr></table></figure><p>再定义一个 options 结构体用于放 bool 型变量 <code>PanicWhenInitFail</code>，表示 Init 失败后是否 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">PanicWhenInitFail <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来定义一个导出的函数，用户传入 bool 型变量就可以设置 options，而不用定义 options 对象。这种方法美妙的地方就在这里，要多次回味才能感受到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPanicWhenInitFail</span><span class="params">()</span> <span class="title">optionFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">o.PanicWhenInitFail = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始时，Init 函数的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(a <span class="keyword">int</span>, opts ...optionFunc)</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gOpt = &amp;options&#123;PanicWhenInitFail: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(gOpt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(gOpt)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，main 函数就可以非常优雅地设置 <code>PanicWhenInitFail</code> 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Init(<span class="number">8</span>)</span><br><span class="line">Init(<span class="number">8</span>, WithPanicWhenInitFail())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管加不加后面的配置，两种调用方式都可以编译成功，不会影响现有的用户，完美。</p><p>为什么这篇文章和曹大扯上关系，因为在曹大写的 <a href="https://github.com/mosn/holmes" target="_blank" rel="noopener">mosn/homels</a> 这个库里也有类似的代码。当然，本文这种形式很常见，可以算作标配了。不过，有一点点不同之处，曹大定义了一个 interface，不过看起来感觉有点更难懂了。😇</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option holmes option type.</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">apply(*options) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> optionFunc <span class="function"><span class="keyword">func</span><span class="params">(*options)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f optionFunc)</span> <span class="title">apply</span><span class="params">(opts *options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去 Google 上一查，其实这种形式，叫 <code>Functional Options Pattern</code>，早在 2014 年 Rob Pike 就写过一篇<a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">博文</a>来说这个事，没几行代码，但是真的很优雅。</p><p>总结一下，当我们要修改已有的函数时，为了不破坏原有的签名和行为，可以使用 <code>Functional Options Pattern</code> 的形式增加可变参数，即可以增加设置项，又能兼容已有的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一个年久失修的库导致了线上事故，不得不去做一些改进。&lt;/p&gt;
&lt;p&gt;这个陈年库的作用是调用第三方的 RPC 拿一些比较重要的配置，业务代码中有段逻辑会根据读到的配置调用不同端的下游。如果没拿到配置，就会默认地调一个兜底下游。恰好这个兜底下游最近新上了一些逻辑，不兼容这种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>技术之外</title>
    <link href="https://qcrao.com/2021/06/10/out-of-tech/"/>
    <id>https://qcrao.com/2021/06/10/out-of-tech/</id>
    <published>2021-06-09T16:10:07.000Z</published>
    <updated>2021-08-09T16:14:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要来讲一下怎么做动画。</p><p>其实只要掌握几个核心的要点，就可以学会怎么用 Figma 做动画了。</p><p>我们想一下小时候看的那种胶片电影：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210610072807.png" alt="胶片电影"></p><p>每一张胶片上的影像都是静止的，但是当胶片连续滚动时，静止的图片就变成了连续的视频。</p><p>或者想像一下小时候我们看的那种武打的小人书，连着翻页，就能看到一个连续的打斗场景，非常神奇！</p><p>用 Figma 做动画呢，也是类似的原理。</p><p>我们可以创建一组画布，在不同的画布之间，相同名字图形的变化(大小、透明度、颜色、旋转等)，通过 smart animate 就可以自动“脑补”出动画。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210610073259.png" alt="Figma 画布"></p><p>这组画布连起来，就形成了动画。</p><p>原理就是这么简单，具体怎么做，大家看个视频教程就全会了。</p><p>如果做一个比较复杂的动画，涉及到很多的图形，就比较复杂了。我自己想到的一个方法是，先画出一个全貌作为“母画布”，然后再构建每一张子画布，这时就像做减法一样。因为单张画布，其实都是这个“母画布”的子集。</p><p>最终呈现的效果是这样的：</p><p><img src="https://i.loli.net/2021/08/10/wlh29AgmrFN5PqG.png" alt="动画截图"></p><p>视频地址在<a href="https://mp.weixin.qq.com/s/nqd0Vs3ZGzW0SVh1So7AWQ" target="_blank" rel="noopener">这里</a>。</p><p>讲的就是之前的文章<a href="https://mp.weixin.qq.com/s/WWfm7Ui7g_gGlb8XkIZigg" target="_blank" rel="noopener">《迷惑的 goroutine 执行顺序》</a>，这次用动画的形式展现了，是不是非常精彩？</p><p>动画可以更直观地展示原理，在一些技术分享的场合还是很有用的。尤其是很多人都还停留在满篇的文字，或者“装逼”一张幻灯片就一个关键字、对着讲 5 分钟、有几张图就算不错了的情况下，这时你啪来一个动画，你就是全场最靓的仔~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章主要来讲一下怎么做动画。&lt;/p&gt;
&lt;p&gt;其实只要掌握几个核心的要点，就可以学会怎么用 Figma 做动画了。&lt;/p&gt;
&lt;p&gt;我们想一下小时候看的那种胶片电影：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/qcrao/im</summary>
      
    
    
    
    <category term="技术人生" scheme="https://qcrao.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="小技巧" scheme="https://qcrao.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>哪来里的 goexit？</title>
    <link href="https://qcrao.com/2021/06/07/where-is-goexit-from/"/>
    <id>https://qcrao.com/2021/06/07/where-is-goexit-from/</id>
    <published>2021-06-07T15:26:36.000Z</published>
    <updated>2021-08-09T16:07:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>有同学在用 dlv 调试时看到了令人不解的 <code>goexit</code>：goexit 函数是啥，为啥 <code>go fun(){}()</code> 的上层是它？看着像是一个“退出”函数，为什么会出现在最上层？</p><p>其实如果看过 pprof 的火焰图，也会经常看到 <code>goexit</code> 这个函数。</p><p>我们来个例子重现一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 dlv 调试，并分别在不同的地方打上断点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(dlv) b a.go:5 </span><br><span class="line">Breakpoint 1 (enabled) <span class="built_in">set</span> at 0x106d12f <span class="keyword">for</span> main.main() ./a.go:5</span><br><span class="line">(dlv) b a.go:6</span><br><span class="line">Breakpoint 2 (enabled) <span class="built_in">set</span> at 0x106d13d <span class="keyword">for</span> main.main() ./a.go:6</span><br><span class="line">(dlv) b a.go:7</span><br><span class="line">Breakpoint 3 (enabled) <span class="built_in">set</span> at 0x106d1a0 <span class="keyword">for</span> main.main.func1() ./a.go:7</span><br></pre></td></tr></table></figure><p>执行命令 <code>c</code> 运行到断点处，再执行 <code>bt</code> 命令得到 main 函数的调用栈：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(dlv) bt</span><br><span class="line">0  0x000000000106d12f <span class="keyword">in</span> main.main</span><br><span class="line">   at ./a.go:5</span><br><span class="line">1  0x0000000001035c0f <span class="keyword">in</span> runtime.main</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:204</span><br><span class="line">2  0x0000000001064961 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1374</span><br></pre></td></tr></table></figure><p>它的上一层是 <code>runtime.main</code>，找到原代码位置，位于 <code>src/runtime/proc.go</code> 里的 <code>main</code> 函数，它是 Go 进程的 main goroutine，这里会执行一些 init 操作、开启 GC、执行用户 main 函数……</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn := main_main <span class="comment">// proc.go:203</span></span><br><span class="line">fn() <span class="comment">// proc.go:204</span></span><br></pre></td></tr></table></figure><p>其中 <code>fn</code> 是 <code>main_main</code> 函数，表示用户的 main 函数，执行到了这里，才真正将权力交给用户。</p><p>继续执行 <code>c</code> 命令和 <code>bt</code> 命令，得到 <code>go</code> 这一行的调用栈：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0  0x000000000106d13d <span class="keyword">in</span> main.main</span><br><span class="line">   at ./a.go:6</span><br><span class="line">1  0x0000000001035c0f <span class="keyword">in</span> runtime.main</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:204</span><br><span class="line">2  0x0000000001064961 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1374</span><br></pre></td></tr></table></figure><p>以及 <code>println</code> 这一句的调用栈：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  0x000000000106d1a0 <span class="keyword">in</span> main.main.func1</span><br><span class="line">   at ./a.go:7</span><br><span class="line">1  0x0000000001064961 <span class="keyword">in</span> runtime.goexit</span><br><span class="line">   at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1374</span><br></pre></td></tr></table></figure><p>可以看到，调用栈的最上层都是 <code>runtime.goexit</code>，我们跟着注明了的代码行数，顺藤摸瓜，找到 goexit 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The top-most function running on a goroutine</span><br><span class="line">&#x2F;&#x2F; returns to goexit+PCQuantum.</span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class="line">    BYTE$0x90&#x2F;&#x2F; NOP</span><br><span class="line">CALLruntime·goexit1(SB)&#x2F;&#x2F; does not return</span><br><span class="line">&#x2F;&#x2F; traceback from goexit1 must hit code range of goexit</span><br><span class="line">BYTE$0x90&#x2F;&#x2F; NOP</span><br></pre></td></tr></table></figure><p>这还是个汇编函数，它接着调用 goexit1 函数、goexit0 函数，主要的功能就是将 goroutine 的各个字段清零，放入 gFree 队列里，等待将来进行复用。</p><p>另一方面，goexit 函数的地址是在创建 goroutine 的过程中，塞到栈上的。让 CPU “误以为”：<code>func()</code> 是由 goexit 函数调用的。这样一来，当 <code>func()</code> 执行完毕时，会返回到 goexit 函数做一些清理工作。</p><p>下面这张图能看出在 newg 的栈底塞了一个 goexit 函数的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607084706.png" alt="goexit 返回地址"></p><p>对应的路径是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newporc -&gt; newporc1 -&gt; gostartcallfn -&gt; gostartcall</span><br></pre></td></tr></table></figure><p>来看 <code>newproc1</code> 中的关键几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum</span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure><p>这里的 newg 就是创建的 goroutine，每个新建的 goroutine 都会执行这些代码。而 <code>sched</code> 结构体其实保存的是 goroutine 的执行现场，每当 goroutine 被调离 CPU，它的执行进度就是保存到这里。进度主要就是 SP、BP、PC，分别表示栈顶地址、栈底地址、指令位置，等 goroutine 再次得到 CPU 的执行权时，会把 SP、BP、PC 加载到寄存器中，从而从断点处恢复运行。</p><p>回到上面的几行代码，<code>pc</code> 被赋值成了 <code>funcPC(goexit)</code>，最后在 <code>gostartcall</code> 里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">sp := buf.sp</span><br><span class="line">...</span><br><span class="line">sp -= sys.PtrSize</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc</span><br><span class="line">buf.sp = sp</span><br><span class="line">buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sp</code> 其实就是栈顶，第 7 行代码把 <code>buf.pc</code>，也就是 <code>goexit</code> 的地址，放在了栈顶的地方，熟悉 Go 函数调用规约的朋友知道，这个位置其实就是 <code>return addr</code>，将来等 <code>func()</code> 执行完，就会回到父函数继续执行，这里的父函数其实就是 <code>goexit</code>。</p><p>一切早已注定。</p><p>不过注意一点，<code>main goroutine</code> 和普通的 goroutine 不同的是，前者执行完用户 main 函数后，会直接执行 exit 调用，整个进程退出：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210607082923.png" alt="exit"></p><p>也就不会进入 goexit 函数。而普通 goroutine 执行完毕后，则直接进入 goexit 函数，做一些清理工作。</p><p>这也就是为什么只要 main goroutine 执行完了，就不会等其他 goroutine，直接退出。一切都是因为 <code>exit</code> 这个调用。</p><p>今天我们主要讲了 goexit 是怎么被安插到 goroutine 的栈上，从而实现 goroutine 执行完毕后再回到 goexit 函数。</p><p>原来看似很不理解的东西，是不是更清晰了？</p><p>源码面前，了无秘密。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有同学在用 dlv 调试时看到了令人不解的 &lt;code&gt;goexit&lt;/code&gt;：goexit 函数是啥，为啥 &lt;code&gt;go fun(){}()&lt;/code&gt; 的上层是它？看着像是一个“退出”函数，为什么会出现在最上层？&lt;/p&gt;
&lt;p&gt;其实如果看过 pprof 的火焰</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>初始 ast 的威力</title>
    <link href="https://qcrao.com/2021/06/01/getting-to-know-the-power-of-ast/"/>
    <id>https://qcrao.com/2021/06/01/getting-to-know-the-power-of-ast/</id>
    <published>2021-06-01T15:26:17.000Z</published>
    <updated>2021-08-09T16:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>抽象语法树是编译过程中的一个中间产物，一般简单了解一下就行了。但我们可以把 Go 语言的整个 parser 和 ast 包直接拿来用，在一些场景下有很大的威力。</p><p>什么是 ast 呢，我从维基百科上摘录了一段：</p><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p></blockquote><p>核心就是说 ast 能以一种树的形式表示代码结构。有了树结构，就可以对它做遍历，能干很多事。</p><h1 id="假定一个场景"><a href="#假定一个场景" class="headerlink" title="假定一个场景"></a>假定一个场景</h1><p>假定一个场景：我们可以从司机平台的某个接口获取司机的各种特征，例如：年龄、订单数、收入、每天驾驶时长、驾龄、平均车速、被投诉次数……数据一般采用 json 来传递。</p><p>司机平台的运营小姐姐经常需要搞一些活动，例如选出：</p><ul><li>订单数超过 10000，且驾龄超过 5 年的老司机</li><li>每天驾驶时小于 3 小时，且收入超过 500 的高效司机</li><li>年龄大于 40，且平均速度大于 70 的“狂野”司机</li><li>……</li></ul><p>这些规则并不是固定的，经常在变化，但总归是各种司机特征的组合。</p><p>为了简化，我们选取 2 个特征，并用一个 <code>Driver</code> 结构体来表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> &#123;</span><br><span class="line">Orders         <span class="keyword">int</span></span><br><span class="line">DrivingYears   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了配合运营搞活动，我们需要根据运营给的规则来判断一个司机是否符合要求。</p><p>如果公司人多，可以安排一个 rd 专门伺候运营小姐姐，每次做活动都来手动修改代码，也不是不可以。并且其实挺简单，我们来写一个示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第三方获取司机特征，json 表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDriverRemote</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">`&#123;"orders":100000,"driving_years":18&#125;`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为老司机</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOldDriver</span><span class="params">(d *Driver)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d.Orders &gt; <span class="number">10000</span> &amp;&amp; d.DrivingYears &gt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bs := getDriverRemote()</span><br><span class="line"><span class="keyword">var</span> d Driver</span><br><span class="line">json.Unmarshal(bs, &amp;d)</span><br><span class="line">fmt.Println(isOldDriver(&amp;d))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接来看 <code>main</code> 函数：<code>getDriverRemote</code> 模拟从第三方 RPC 获取一个司机的特征数据，用 json 表示。接着 <code>json.Unmarshal</code> 来反序列化 <code>Driver</code> 结构体。最后调用 <code>isOldDriver</code> 函数来判断此司机是否符合运营的规则。</p><p><code>isOldDriver</code> 根据 <code>Driver</code> 结构体的 2 个字段使用 if 语句来判断此司机是否为老司机。</p><p>确实还挺简单。</p><p>但是每次更新规则还得经过一次完整的上线流程，也挺麻烦的。有没有更简单的办法呢？使得我们可以直接解析运营小组姐给我们的一个用字符串表示的规则，并直接返回一个 bool 型的值，表示是否满足条件。</p><p>有的！</p><p>接下来就是本文的核心内容，如何使用 ast 来完成同样的功能。</p><h1 id="直观地理解如何用-ast-解析规则"><a href="#直观地理解如何用-ast-解析规则" class="headerlink" title="直观地理解如何用 ast 解析规则"></a>直观地理解如何用 ast 解析规则</h1><p>使用 ast 包提供的一些函数，我们可以非常方便地将如下的规则字符串：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orders &gt; 10000 &amp;&amp; driving_years &gt; 5</span><br></pre></td></tr></table></figure><p>解析成一棵这样的二叉树：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531232645.png" alt="规则二叉树"></p><p>其中，<code>ast.BinaryExpr</code> 代表一个二元表达式，它由 X 和 Y 以及符号 OP 三部分组成。最上面的一个 <code>BinaryExpr</code> 表示规则的左半部分和右半部分相与。</p><p>很明显，左半部分就是：<code>orders &gt; 10000</code>，而右半部分则是：<code>driving_years &gt; 5</code>。神奇的是，左半部分和右半部分恰好又都是一个二元表达式。</p><p>左半部分的 <code>orders &gt; 10000</code> 其实也是最小的叶子节点，它可以算出来一个 bool 值。把它拆开来之后，又可以分成 X、Y、OP。X 是 <code>orders</code>，OP 是 “&gt;”，Y 则是 “10000”。其中 X 表示一个标识符，是 ast.Ident 类型，Y 表示一个基本类型的字面量，例如 int 型、字符串型……是 ast.BasicLit 类型。</p><p>右半部分的 <code>driving_years &gt; 18</code> 也可以照此拆分。</p><p>然后，从 json 中取出这个司机的 <code>orders</code> 字段的值为 100000，它比 10000 大，所以左半部分算出来为 true。同理，右半部分算出来也为 true。最后，再算最外层的 “&amp;&amp;”，结果仍然为 true。</p><p>至此，直接根据规则字符串，我们就可以算出来结果。</p><p>如果写成程序的话，就是一个 dfs 的遍历过程。如果不是叶子结点，那就是二元表达式结点，那就一定有 X、Y、OP 部分。递归地遍历 X，如果 X 是叶子结点，那就结束递归，并计算出 X 的值……</p><p>这里再展示一个用 ast 包打印出来的抽象语法树：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210531231824.png" alt="Go 打印 ast"></p><p>上图中，1、2、3 表示最外层的二元表达式；4、5、6 则表示左边这个二元表达式。</p><p>结合这张图，再参考 ast 包的相关结构体 代码，就非常清晰了。例如 <code>ast.BinaryExpr</code> 的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A BinaryExpr node represents a binary expression.</span></span><br><span class="line">BinaryExpr <span class="keyword">struct</span> &#123;</span><br><span class="line">X     Expr        <span class="comment">// left operand</span></span><br><span class="line">OpPos token.Pos   <span class="comment">// position of Op</span></span><br><span class="line">Op    token.Token <span class="comment">// operator</span></span><br><span class="line">Y     Expr        <span class="comment">// right operand</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有 X、Y、OP，甚至还解析出了 Op 的位置，用 OpPos 表示。</p><p>如果你还对实现感兴趣，那就继续看下面的原理分析部分，否则可以直接跳到结尾总结部分。</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>还是用上面那个例子，我们直接写一个表达式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orders &gt; 10000 &amp;&amp; driving_years &gt; 5</span><br></pre></td></tr></table></figure><p>接下来用 ast 来解析规则并判断真假。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>&#123;<span class="string">"orders"</span>: <span class="number">100000</span>, <span class="string">"driving_years"</span>: <span class="number">18</span>&#125;</span><br><span class="line">rule := <span class="string">`orders &gt; 10000 &amp;&amp; driving_years &gt; 5`</span></span><br><span class="line">fmt.Println(Eval(m, rule))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简单，我们直接用 map 来代替 json，道理是一样的，仅仅为了方便。</p><p><code>Eval</code> 函数判断 <code>rule</code> 的真假：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eval : 计算 expr 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Eval</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>, expr <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">exprAst, err := parser.ParseExpr(expr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 ast</span></span><br><span class="line">fset := token.NewFileSet()</span><br><span class="line">ast.Print(fset, exprAst)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> judge(exprAst, m), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将表达式解析成 <code>Expr</code>，接着调用 judge 函数计算结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(bop ast.Node, m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 叶子结点</span></span><br><span class="line"><span class="keyword">if</span> isLeaf(bop) &#123;</span><br><span class="line"><span class="comment">// 断言成二元表达式</span></span><br><span class="line">expr := bop.(*ast.BinaryExpr)</span><br><span class="line">x := expr.X.(*ast.Ident) <span class="comment">// 左边</span></span><br><span class="line">y := expr.Y.(*ast.BasicLit) <span class="comment">// 右边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 "&gt;" 符号</span></span><br><span class="line"><span class="keyword">if</span> expr.Op == token.GTR &#123;</span><br><span class="line">left := m[x.Name]</span><br><span class="line">right, _ := strconv.ParseInt(y.Value, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">return</span> left &gt; right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是叶子节点那么一定是 binary expression（我们目前只处理二元表达式）</span></span><br><span class="line">expr, ok := bop.(*ast.BinaryExpr)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"this cannot be true"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归地计算左节点和右节点的值</span></span><br><span class="line"><span class="keyword">switch</span> expr.Op &#123;</span><br><span class="line"><span class="keyword">case</span> token.LAND:</span><br><span class="line"><span class="keyword">return</span> judge(expr.X, m) &amp;&amp; judge(expr.Y, m)</span><br><span class="line"><span class="keyword">case</span> token.LOR:</span><br><span class="line"><span class="keyword">return</span> judge(expr.X, m) || judge(expr.Y, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"unsupported operator"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>judge</code> 使用 dfs 递归地计算表达式的值。</p><p>递归地终止条件是叶子节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLeaf</span><span class="params">(bop ast.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">expr, ok := bop.(*ast.BinaryExpr)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元表达式的最小单位，左节点是标识符，右节点是值</span></span><br><span class="line">_, okL := expr.X.(*ast.Ident)</span><br><span class="line">_, okR := expr.Y.(*ast.BasicLit)</span><br><span class="line"><span class="keyword">if</span> okL &amp;&amp; okR &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天这篇文章主要讲了如何用 ast 包和 parser 包解析一个二元表达式，并见识到了它的威力，利用它可以做成一个非常简单的规则引擎。</p><p>其实利用 ast 包还可以做更多有意思的事情。例如批量把 thrift 文件转化成 proto 文件、解析 sql 语句并做一些审计……</p><p>想要更深入的学习，可以看曹大这篇<a href="https://xargin.com/ast/" target="_blank" rel="noopener">《golang 和 ast》</a>，据曹大自己说，他可以在 30 分钟内完成一个项目的一个 api 的编写，非常霸气！不服喷他……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抽象语法树是编译过程中的一个中间产物，一般简单了解一下就行了。但我们可以把 Go 语言的整个 parser 和 ast 包直接拿来用，在一些场景下有很大的威力。&lt;/p&gt;
&lt;p&gt;什么是 ast 呢，我从维基百科上摘录了一段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>如何用汇编打同事的脸</title>
    <link href="https://qcrao.com/2021/05/27/how-to-get-asm-code-of-go/"/>
    <id>https://qcrao.com/2021/05/27/how-to-get-asm-code-of-go/</id>
    <published>2021-05-27T15:21:55.000Z</published>
    <updated>2021-08-09T16:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍几个常用的查看 Go 汇编代码、调试 Go 程序的命令和工具，既可以在平时和同事、网友抬杠时使用，还能在关键时刻打他们的脸。</p><p>比如，有同事说这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Class <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = &amp;Student&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的执行效率要高于下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Class <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = Student&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = &amp;a</span><br><span class="line"><span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且给你讲了一通道理，你好像没法辩赢他。怎么办？</p><p>直接用一行命令生成汇编代码，马上可以戳穿他，打他的脸。</p><h1 id="go-tool-生成汇编"><a href="#go-tool-生成汇编" class="headerlink" title="go tool 生成汇编"></a>go tool 生成汇编</h1><p>其实很简单，有两个命令可以做到：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go &amp;&amp; go tool objdump ./main</span><br></pre></td></tr></table></figure><p>前者是编译，即将源代码编译成 <code>.o</code> 目标文件，并输出汇编代码。</p><p>后者是反汇编，即从可执行文件反编译成汇编，所以要先用 <code>go build</code> 命令编译出可执行文件。</p><p>二者不尽相同，但都能看到前面两个示例代码对应的汇编代码是一致的。同事的“谣言”不攻自破，脸都被你打疼了。</p><h1 id="找到-runtime-源码"><a href="#找到-runtime-源码" class="headerlink" title="找到 runtime 源码"></a>找到 runtime 源码</h1><p>Go 是一门有 runtime 的语言，什么是 runtime？其实就是一段辅助程序，用户没有写的代码，runtime 替我们写了，比如 Go 调度器的代码。</p><p>我们只需要知道用 go 关键字创建 goroutine，就可以疯狂堆业务了。至于 goroutine 是怎么被调度的，根本不需要关心，这些是 runtime 调度器的工作。</p><p>那我们自己写的代码如何和 runtime 里的代码对应起来呢？</p><p>前面介绍的方法就可以做到，只需要加一个 <code>grep</code> 就可以。</p><p>例如，我想知道 go 关键字对应 runtime 里的哪个函数，于是写了一段测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>go func(){}()</code> 那一行代码在第 4 行，所以，grep 的时候加一个条件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go | grep <span class="string">"main.go:4"</span></span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">go build main.go &amp;&amp; go tool objdump ./main | grep <span class="string">"main.go:4"</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525232528.png" alt="go func"></p><p>马上就能看到 <code>go func(){}()</code> 对应 <code>newproc()</code> 函数，这时再深入研究下 <code>newproc()</code> 函数就大概知道 goroutine 是如何被创建的。</p><h1 id="用-dlv-调试"><a href="#用-dlv-调试" class="headerlink" title="用 dlv 调试"></a>用 dlv 调试</h1><p>那有同学问了，有没有其他可以调试 Go、以及和 Go 程序互动的方法呢？其实是有的！这就是我们要介绍的 dlv 调试工具，目前它对调试 Go 的程序支持是最好的。</p><p>之前没我怎么研究它，只会一些非常简单的命令，这次学会了几个进阶的指令，威力挺大，也进一步加深了对 Go 的理解。</p><p>下面我们带着一个任务来讲解 dlv 如何使用。</p><p>我们知道，向一个 nil 的 slice append 元素，不会有任何问题。但是向一个 nil 的 map 插入新元素，马上就会报 panic。这是为什么呢？又是在哪 panic 呢？</p><p>首先写出让 map 产生 panic 的示例程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着用 <code>go build</code> 命令编译生成可执行文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build a.go</span><br></pre></td></tr></table></figure><p>然后，使用 dlv 进入调试状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv <span class="built_in">exec</span> ./a</span><br></pre></td></tr></table></figure><p>使用 <code>b</code> 这个命令打断点，有三种方法：</p><ol><li>b + 地址</li><li>b + 代码行数</li><li>b + 函数名</li></ol><p>我们要在对 map 赋值的地方加个断点。先找到代码位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n a.go</span><br></pre></td></tr></table></figure><p>看到：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525234605.png" alt="hello.go"></p><p>赋值的地方在第 5 行，加断点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dlv) b a.go:5</span><br><span class="line">Breakpoint 1 <span class="built_in">set</span> at 0x45e55d <span class="keyword">for</span> main.main() ./a.go:5</span><br></pre></td></tr></table></figure><p>执行 <code>c</code> 命令，直接运行到断点处：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525233423.png" alt="运行到断点处"></p><p>执行 <code>disass</code> 命令，可以看到汇编指令：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525233635.png" alt="disass"></p><p>这时使用 <code>si</code> 命令，执行单条指令，多次执行 <code>si</code>，就会执行到 map 赋值函数 <code>mapassign_fast64</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525233856.png" alt="mapassign_fast64"></p><p>这时再用单步命令 <code>s</code>，就会进入判断 h 的值为 nil 的分支，然后执行 <code>panic</code> 函数：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525234044.png" alt="panic"></p><p>至此，向 nil 的 map 赋值时，产生 panic 的代码就被我们找到了。接着，按图索骥找到对应 runtime 源码的位置，就可以进一步探索了。</p><p>除此之外，我们还可以使用 <code>bt</code> 命令看到调用栈：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210525234258.png" alt="调用栈"></p><p>使用 <code>frame 1</code> 命令可以跳转到相应位置。这里 <code>1</code> 对应图中的 <code>a.go:5</code>，也就是我们前面打断点的地方，是不是非常酷炫。</p><p>上面这张图里我们也能清楚地看到，用户 goroutine 其实是被 goexit 函数一路调用过来的。当用户 goroutine 执行完毕后，就会回到 goexit 函数做一些收尾工作。当然，这是题外话了。</p><p>另外，用 dlv 也能干第二部分“找到 runtime 源码”的活。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天系统地讲了几招通过命令和工具查看用户代码对应的 runtime 源码或者汇编代码的方法，非常实用。最后再汇总一下：</p><ol><li>go tool compile</li><li>go tool objdump</li><li>dlv</li></ol><p>使用这些命令和工具，可以让你在看 Go 源码的过程中事半功倍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天介绍几个常用的查看 Go 汇编代码、调试 Go 程序的命令和工具，既可以在平时和同事、网友抬杠时使用，还能在关键时刻打他们的脸。&lt;/p&gt;
&lt;p&gt;比如，有同事说这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>迷惑的 goroutine 执行顺序</title>
    <link href="https://qcrao.com/2021/05/24/confusing-goroutine-running-orders/"/>
    <id>https://qcrao.com/2021/05/24/confusing-goroutine-running-orders/</id>
    <published>2021-05-24T15:19:46.000Z</published>
    <updated>2021-08-09T15:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA" target="_blank" rel="noopener">文章</a>我们讲了 Go 调度的本质是一个生产-消费流程。</p><p>生产端是正在运行的 goroutine 执行 <code>go func(){}()</code> 语句生产出 goroutine 并塞到三级队列中去。</p><p>消费端则是 Go 进程中的 m 在不断地执行调度循环，从三级队列中拿到 goroutine 来运行。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210519235922.png" alt="生产-消费过程"></p><p>今天我们来通过 2 个实际的代码例子来看看 goroutine 的执行顺序是怎样的。</p><h1 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h1><p>首先来看第一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>runtime.GOMAXPROCS(1)</code> 设置只有一个 P，接着创建了 10 个 goroutine，并分别打印出 <code>i</code> 值。你可以先想一下输出会是什么，再对着答案会有更深入的理解。</p><p>揭晓答案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan receive]:</span><br><span class="line">main.main()</span><br><span class="line">        /home/raoquancheng/go/src/hello/main.go:16 +0x96</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><p>程序输出的 <code>fatal error</code> 是因为 main goroutine 正在从一个 channel 里读数据，而这时所有的 channel 都已经挂了，因此出现死锁。这里先忽略这个，只需要关注 <code>i</code> 输出的顺序：<code>9, 0, 1, 2, 3, 4, 5, 6, 7, 8</code>。</p><p>我来解释一下原因：因为一开始就设置了只有一个 P，所以 for 循环里面“生产”出来的 goroutine 都会进入到 P 的 runnext 和本地队列，而不会涉及到全局队列。</p><p>每次生产出来的 goroutine 都会第一时间塞到 runnext，而 i 从 1 开始，runnext 已经有 goroutine 在了，所以这时会把 old goroutine 移动 P 的本队队列中去，再把 new goroutine 放到 runnext。之后会重复这个过程……</p><p>因此这后当一次 i 为 9 时，新 goroutine 被塞到 runnext，其余 goroutine 都在本地队列。</p><p>之后，main goroutine 执行了一个读 channel 的语句，这是一个好的调度时机：main goroutine 挂起，运行 P 的 runnext 和本地可运行队列里的 gorotuine。</p><p>而我们又知道，runnext 里的 goroutine 的执行优先级是最高的，因此会先打印出 9，接着再执行本地队列中的 goroutine 时，按照先进先出的顺序打印：<code>0, 1, 2, 3, 4, 5, 6, 7, 8</code>。</p><p>是不是非常有意思？</p><h1 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h1><p>别急，我们再来看第 2 个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和第一个例子的不同之处是我们把读 channel 的代码换成 Sleep 操作。这一次，你还能正确回答 <code>i</code> 的输出顺序是什么吗？</p><p>我们直接揭晓答案。</p><p>当我们用 go1.13 运行时：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go1.13.8 run main.go</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>而当我们用 go1.14 及之后的版本运行时：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go1.14 run main.go</span><br><span class="line"></span><br><span class="line">9</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>可以看到，用 go1.14 及之后的版本运行时，输出顺序和之前的一致。而用 go1.13 运行时，却先输出了 <code>0</code>，这又是什么原因呢？</p><p>这就要从 Go 1.14 修改了 timer 的实现开始说起了。</p><p><code>go 1.13</code> 的 time 包会生产一个名字叫 timerproc 的 goroutine 出来，它专门用于唤醒挂在 timer 上的时间未到期的 goroutine；因此这个 goroutine 会把 runnext 上的 goroutine 挤出去。因此输出顺序就是：<code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</code>。</p><p>而 <code>go 1.14</code> 把这个唤醒的 goroutine 干掉了，取而代之的是，在调度循环的各个地方、sysmon 里都是唤醒 timer 的代码，timer 的唤醒更及时了，但代码也更难看懂了。所以，输出顺序和第一个例子是一致的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天通过 2 个实际的例子再次复习了 Go 调度消费端的流程，也学到了 time 包在不同 go 版本下的不同之处以及它对程序输出造成的影响。</p><p>有些人还会把例子中的 10 改成比 256 更大的数去尝试。曹大说这是考眼力，不要给自己找事。因为这时 P 的本地队列装不下这么多 goroutine 了，只能放到全局队列。这下程序的输出顺序就不那么直观了。</p><p>所以，记住本文的核心内容就行了：</p><ol><li>runnext 的优先级最高。</li><li>time.Sleep 在老版本中会创建一个 goroutine，在 1.14(包含)之后不会创建 goroutine 了。</li></ol><p>如果被别人考到，知道三级队列，以及 time 包在 1.14 的变更就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/5E5V56wazp5gs9lrLvtopA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;我们讲了 Go 调度的本质是一个生产-消费流程。&lt;/p&gt;
&lt;p&gt;生产端是正</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 调度的本质</title>
    <link href="https://qcrao.com/2021/05/20/go-schedule-under-the-hood/"/>
    <id>https://qcrao.com/2021/05/20/go-schedule-under-the-hood/</id>
    <published>2021-05-20T15:15:17.000Z</published>
    <updated>2021-08-09T15:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先抛出本文的结论：Go 调度的本质是一个生产-消费流程。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210519235236.png" alt="生产者-消费者"></p><h1 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h1><p>我们平时用 Go 最爽的一点莫过于用一句 <code>go func(){}()</code> 就启动了一个 goroutine 来并发地执行任务。这比用 C/C++ 启动一个线程并发地去执行任务方便太多。这句代码实际上就生产出了一个 goroutine，并进入可运行队列，等待和 m 来找它从而可以得到运行。</p><p>熟悉 GMP 模型的朋友都知道，goroutine 最终在 m 上得以执行，因为操作系统感知不到 goroutine，它只能感知线程，并且线程可以看成是 m。</p><p>所以，m 拿到 goroutine 并运行它的过程就是一个消费过程。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210519235922.png" alt="生产-消费过程"></p><h1 id="生产过程——三级队列"><a href="#生产过程——三级队列" class="headerlink" title="生产过程——三级队列"></a>生产过程——三级队列</h1><p>生产出的 goroutine 需要找一个地方存放，这个地方就是可运行队列。在 Go 程序中，可运行队列是分级的，分为三级：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210520000257.png" alt="三级可运行队列"></p><p><code>runnext</code> 实际上只能指向一个 goroutine，所以它是一个特殊的队列。</p><p>那把 goroutine 放到哪个可运行队列呢？看情况。</p><p>首先，如果 runnext 为空，那么 goroutine 就会顺利地放入 runnext，接下来，它会以最高优先级得到运行，即优先被消费。</p><p>如果 runnext 不为空，那就先负责把 runnext 上的 old goroutine 踢走，再把 new goroutine 放上来。具体踢到哪里呢？又得分情况。</p><p><code>local queue</code> 是一个大小为 256 的数组，实际上用 head 和 tail 指针把它当成一个环形数组在使用。如果 local queue 不满，则将 runnext 放入 local queue；否则，P 的本地队列上的 goroutine 太多了，说明当前 P 的任务太重了，需要减负，因此需要得到其他 P 协助。从而，将 runnext 以及当前 P 的一半 goroutine 一起打包丢到 global queue 里去。</p><p>当然，这部分课程里有非常生动的动画，这里贴一个截图大家感受一下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210520075006.png" alt="生产者动画"></p><h1 id="消费过程——调度循环"><a href="#消费过程——调度循环" class="headerlink" title="消费过程——调度循环"></a>消费过程——调度循环</h1><p>之前的<a href="https://mp.weixin.qq.com/s/pRCWOKlI48soY0deOWoSEw" target="_blank" rel="noopener">文章</a>里也讲到过调度循环是咋回事，它实际上就是 Go 程序在启动的时候，会创建和 CPU 核心数相等个数的 P，会创建初始的 m，称为 m0。这个 m0 会启动一个调度循环：不断地找 g，执行，再找 g……</p><p>伪代码是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210520000427.png" alt="调度循环"></p><p>随着程序的运行，m 更多地被创建出来，因此会有更多的调度循环在执行。</p><p>那边生产者在不断地生产 g，这边 m 的调度循环不断地在消费 g，整个过程就 run 起来了。</p><p>找 g 的过程中当然也是从上面的三级队列里找：</p><p>先看 runnext，再看 local queue，再看 global queue。当然，如果实在找不到，就去其他 p 去偷。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的文章只用记住一个观点：Go 调度的本质是一个生产-消费流程。这个观点非常新颖，之前我没有从哪篇文章看到过，这是曹大自己的感悟。</p><p>读者即使之前没见过类似的说法，但是一旦听曹大讲出来，就马上感觉醍醐灌顶。</p><p>这种熟悉加意外的效果其实就是你成长的时机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先抛出本文的结论：Go 调度的本质是一个生产-消费流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210519235236.png&quot; alt=&quot;生产者-消费者&quot;&gt;&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密 Go 语言之基于信号的抢占式调度</title>
    <link href="https://qcrao.com/2021/05/12/diving-into-preempt-by-signal/"/>
    <id>https://qcrao.com/2021/05/12/diving-into-preempt-by-signal/</id>
    <published>2021-05-12T15:12:56.000Z</published>
    <updated>2021-08-09T15:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家在实际工作中有没有遇到过老版本 Go 调度器的坑：死循环导致程序“死机”。我去年就遇到过，并且搞出了一起 P0 事故，还写了篇弱智的找 bug <a href="https://mp.weixin.qq.com/s/xe8KXD39YlJdDG4cLT0veA" target="_blank" rel="noopener">文章</a>。</p><p>识别事故的本质，并且用一个非常简单的示例展示出来，是功力的一种体现。那次事故的原因可以简化成如下的 demo：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230327.png" alt="demo-1"></p><p>我来简单解释一下上面这个程序。在主 goroutine 里，先用 GoMAXPROCS 函数拿到 CPU 的逻辑核心数 threads。这意味着 Go 进程会创建 threads 个数的 P。接着，启动了 threads 个数的 goroutine，每个 goroutine 都在执行一个无限循环，并且这个无限循环只是简单地执行 <code>x++</code>。</p><p>接着，主 goroutine sleep 了 1 秒钟；最后，打印 x 的值。</p><p>你可以自己思考一下，输出会是什么？</p><p>如果你想出了答案，接着再看下面这个 demo：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507230413.png" alt="demo-2"></p><p>我也来解释一下，在主 goroutine 里，只启动了一个 goroutine（虽然程序里用了一个 for 循环，但其实只循环了一次，完全是为了和前面的 demo 看起来更协调一些），同样执行了一个 <code>x++</code> 的无限 for 循环。</p><p>和前一个 demo 的不同点在于，在主 goroutine 里，我们手动执行了一次 GC；最后，打印 x 的值。</p><p>如果你能答对第一题，大概率也能答对第二题。</p><p>下面我就来揭晓答案。</p><p>其实我留了一个坑，我没说用哪个版本的 Go 来运行代码。所以，正确的答案是：</p><table><thead><tr><th>Go 版本</th><th>demo-1</th><th>demo-2</th></tr></thead><tbody><tr><td>1.13</td><td>卡死</td><td>卡死</td></tr><tr><td>1.14</td><td>0</td><td>0</td></tr></tbody></table><p>这个其实就是 Go 调度器的坑了。</p><p>假设在 demo-1 中，共有 4 个 P，于是创建了 4 个 goroutine。当主 goroutine 执行 sleep 的时候，刚刚创建的 4 个 goroutine 马上就把 4 个 P 霸占了，执行死循环，而且竟然没有进行函数调用，就只有一个简单的赋值语句。Go 1.13 对这种情况是无能为力的，没有任何办法让这些 goroutine 停下来，进程对外表现出“死机”。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507231301.png" alt="demo-1 示意图"></p><p>由于 Go 1.14 实现了基于信号的抢占式调度，这些执行无限循环的 goroutine 会被调度器“拿下”，P 就会空出来。所以当主 goroutine sleep 时间到了之后，马上就能获得 P，并得以打印出 x 的值。至于 x 为什么输出的是 0，不太好解释，因为这是一种未定义（有数据竞争，正常情况下要加锁）的行为，可能的一个原因是 CPU 的 cache 没有来得及更新，不过不太好验证。</p><p>理解了这个 demo，第二个 demo 其实是类似的道理：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507232036.png" alt="demo-2 示意图"></p><p>当主 goroutine 主动触发 GC 时，需要把所有当前正在运行的 goroutine 停止下来，即 stw（stop the world），但是 goroutine 正在执行无限循环，没法让它停下来。当然，Go 1.14 还是可以抢占掉这个 goroutine，从而打印出 x 的值，也是 0。</p><p>Go 1.14 之前的版本，能否抢占一个正在执行死循环的 goroutine 其实是有讲究的：</p><blockquote><p>能否被抢占，不是看有没有调用函数，而是看函数的序言部分有没有插入扩栈检测指令。</p></blockquote><blockquote><p>如果没有调用函数，肯定不会被抢占。</p></blockquote><blockquote><p>有些虽然也调用了函数，但其实不会插入检测指令，这个时候也不会被抢占。</p></blockquote><p>像前面的两个 demo，不可能有机会在函数扩栈检测期间主动放弃 CPU 使用权，从而完成抢占，因为没有函数调用。具体的过程后面有机会再写一篇文章详细讲，本文主要看基于信号的抢占式调度如何实现。</p><h1 id="preemptone"><a href="#preemptone" class="headerlink" title="preemptone"></a>preemptone</h1><p>一方面，Go 进程在启动的时候，会开启一个后台线程 sysmon，监控执行时间过长的 goroutine，进而发出抢占。另一方面，GC 执行 stw 时，会让所有的 goroutine 都停止，其实就是抢占。这两者都会调用 <code>preemptone()</code> 函数。</p><p><code>preemptone()</code> 函数会沿着下面这条路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preemptone-&gt;preemptM-&gt;signalM-&gt;tgkill</span><br></pre></td></tr></table></figure><p>向正在运行的 goroutine 所绑定的的那个 M（也可以说是线程）发出 <code>SIGURG</code> 信号。</p><h1 id="注册-sighandler"><a href="#注册-sighandler" class="headerlink" title="注册 sighandler"></a>注册 sighandler</h1><p>每个 M 在初始化的时候都会设置信号处理函数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initsig-&gt;setsig-&gt;sighandler</span><br></pre></td></tr></table></figure><h1 id="信号执行过程"><a href="#信号执行过程" class="headerlink" title="信号执行过程"></a>信号执行过程</h1><p>我们从“宏观”层面看一下信号的执行过程：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210507233951.png" alt="信号执行过程"></p><p>主程序（线程）正在“勤勤恳恳”地执行指令：它已经执行完了指令 <code>m</code>，接着就要执行指令 <code>m+1</code> 了……不幸在这个时候发生了，线程收到了一个信号，对应图中的 <code>①</code>。</p><p>接着，内核会接管执行流，转而去执行预先设置好的信号处理器程序，对应到 Go 里，就是执行 sighandler，对应图中的 <code>②</code> 和 <code>③</code>。</p><p>最后，执行流又交到线程手上，继续执行指令 <code>m+1</code>，对应图中的 <code>④</code>。</p><p>这里其实涉及到了一些现场的保护和恢复，内核都帮我们搞定了，我们不用操心。</p><h1 id="dosigPreempt"><a href="#dosigPreempt" class="headerlink" title="dosigPreempt"></a>dosigPreempt</h1><p>当线程收到 <code>SIGURG</code> 信号的时候，就会去执行 sighandler 函数，核心是 doSigPreempt 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sighandler</span><span class="params">(sig <span class="keyword">uint32</span>, info *siginfo, ctxt unsafe.Pointer, gp *g)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> sig == sigPreempt &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">doSigPreempt(gp, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doSigPreempt</code> 这个函数其实很短，一会儿就执行完了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;</span><br><span class="line"><span class="comment">// Adjust the PC and inject a call to asyncPreempt.</span></span><br><span class="line">ctxt.pushCall(funcPC(asyncPreempt), newpc)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isAsyncSafePoint</code> 函数会返回当前 goroutine 能否被抢占，以及从哪条指令开始抢占，返回的 newpc 表示安全的抢占地址。</p><p>接着，<code>pushCall</code> 调整了一下 SP，设置了几个寄存器的值就返回了。按理说，返回之后，就会接着执行指令 <code>m+1</code> 了，但那还怎么实现抢占呢？其实魔法都在 <code>pushCall</code> 这个函数里。</p><h1 id="pushCall"><a href="#pushCall" class="headerlink" title="pushCall"></a>pushCall</h1><p>在分析这个函数之前，我们需要先复习一下 Go 函数的调用规约，重点回顾一下 CALL 和 RET 指令就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509114734.png" alt="call 和 ret 指令"></p><p><code>call</code> 指令可以简单地理解为 <code>push ip</code> + <code>JMP</code>。这个 ip 其实就是返回地址，也就是调用完子函数接下来该执行啥指令的地址。所以 <code>push ip</code> 就是在 call 一个子函数之前，将返回地址压入栈中，然后 JMP 到子函数的地址执行。</p><p><code>ret</code> 指令和 <code>call</code> 指令刚好相反，它将返回地址从栈上 pop 到 IP 寄存器，使得 CPU 从这个地址继续执行。</p><p>理解了 <code>call</code> 和 <code>ret</code>，我们再来分析 <code>pushCall</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *sigctxt)</span> <span class="title">pushCall</span><span class="params">(targetPC, resumePC <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Make it look like we called target at resumePC.</span></span><br><span class="line">sp := <span class="keyword">uintptr</span>(c.rsp())</span><br><span class="line">sp -= sys.PtrSize</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = resumePC</span><br><span class="line">c.set_rsp(<span class="keyword">uint64</span>(sp))</span><br><span class="line">c.set_rip(<span class="keyword">uint64</span>(targetPC))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看这行注释：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Make it look like we called target at resumePC.</span><br></pre></td></tr></table></figure><p>它清晰地说明了这个函数的作用：让 CPU 误以为是 resumePC 调用了 targetPC。而这个 resumePC 就是上一步调用 isAsyncSafePoint 函数返回的 newpc，它代表我们抢占 goroutine 的指令地址。</p><p>前两行代码将 SP 下移了 8 个字节，并且把 resumePC 入栈（注意，它其实是一个返回地址），接着把 targetPC 设置到 ip 寄存器，sp 设置到 SP 寄存器。这使得从内核返回到用户态执行时，不是从指令 <code>m+1</code>，而是直接从 targetPC 开始执行，等到 targetPC 执行完，才会返回到 resumePC 继续执行。整个过程就像是 resumePC 调用了 targetPC 一样。而 targetPC 其实就是 <code>funcPC(asyncPreempt)</code>，也就是抢占函数。</p><p>于是我们可以看到，信号处理器程序 sighandler 只是将一个异步抢占函数给“安插”进来了，而真正的抢占过程则是在 asyncPreempt 函数中完成。</p><h1 id="异步抢占"><a href="#异步抢占" class="headerlink" title="异步抢占"></a>异步抢占</h1><p>当执行完 sighandler，执行流再次回到线程。由于 sighandler 插入了一个 asyncPreempt 的函数调用，所以 goroutine 原本的任务就得不到推进，转而执行 asyncPreempt 去了：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160026.png" alt="asyncPreempt 调用链路"></p><p><code>mcall(fn)</code> 的作用是切到 g0 栈去执行函数 <code>fn</code>, <code>fn</code> 永不返回。在 <code>mcall(gopreempt_m)</code> 这里，fn 就是 gopreempt_m。</p><p><code>gopreempt_m</code> 直接调用 <code>goschedImpl</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160534.png" alt="goschedImpl"></p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210509160551.png" alt="dropg"></p><p>最精彩的部分就在 goschedImpl 函数。它首先将 goroutine 的状态从 running 改成 runnable；接着调 dropg 将 g 和 m 解绑；然后调用 globrunqput 将 goroutine 丢到全局可运行队列，由于是全局可运行队列，所以需要加锁。最后，调用 <code>schedule()</code> 函数进入调度循环。关于调度循环，可以看这篇<a href="https://mp.weixin.qq.com/s/QFmh0wq50H9-4ZrtEknpCQ" target="_blank" rel="noopener">文章</a>。</p><p>运行 <code>schedule</code> 函数用的是 g0 栈，它会去寻找其他可运行的 goroutine，包括从当前 P 本地可运行队列获取、从全局可运行队列获取、从其他 P 偷等方式找到下一个可运行的 goroutine 并执行。</p><p>至此，这个线程就转而去执行其他的 goroutine，当前的 goroutine 也就被抢占了。</p><p>那被抢占的这个 goroutine 什么时候会再次得到执行呢？</p><p>因为它已经被丢到全局可运行队列了，所以它的优先级就会降低，得到调度的机会也就降低，但总还是有机会再次执行的，并且它会从调用 mcall 的下一条指令接着执行。</p><p>还记得 mcall 函数的作用吗？它会切到 g0 栈执行 gopreempt_m，自然它也会保存 goroutine 的执行进度，其实就是 SP、BP、PC 寄存器的值，当 goroutine 再次被调度执行时，就会从原来的执行流断点处继续执行下去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讲述了 Go 语言基于信号的异步抢占的全过程，一起来回顾下：</p><ol><li>M 注册一个 SIGURG 信号的处理函数：sighandler。</li><li>sysmon 线程检测到执行时间过长的 goroutine、GC stw 时，会向相应的 M（或者说线程，每个线程对应一个 M）发送 SIGURG 信号。</li><li>收到信号后，内核执行 sighandler 函数，通过 pushCall 插入 asyncPreempt 函数调用。</li><li>回到当前 goroutine 执行 asyncPreempt 函数，通过 mcall 切到 g0 栈执行 gopreempt_m。</li><li>将当前 goroutine 插入到全局可运行队列，M 则继续寻找其他 goroutine 来运行。</li><li>被抢占的 goroutine 再次调度过来执行时，会继续原来的执行流。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道大家在实际工作中有没有遇到过老版本 Go 调度器的坑：死循环导致程序“死机”。我去年就遇到过，并且搞出了一起 P0 事故，还写了篇弱智的找 bug &lt;a href=&quot;https://mp.weixin.qq.com/s/xe8KXD39YlJdDG4cLT0veA&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度阅读之《Mastering Go》</title>
    <link href="https://qcrao.com/2021/04/19/mastering-go-reading-notes/"/>
    <id>https://qcrao.com/2021/04/19/mastering-go-reading-notes/</id>
    <published>2021-04-19T15:07:24.000Z</published>
    <updated>2021-08-09T15:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：这本书前前后后花了挺长时间，去年 11 月份就开始读了，中间又断了，直到最近才捡起来看完。</p><p>本书讲得内容非常全面，语言也很顺畅，生词非常少，并且内容没有太大难度，看起来比较过瘾，算是全面复习一下 Go 语言。如果你想开始练习阅读英文书，这本将是一个非常好的开始。</p><p>下面是阅读过程中记录的一些有用的点，随意看看就好。</p><hr><ol><li><p>Go 有很多优点，其中一点是没有预编译阶段，这使得它的编译速度更快。像 C 语中，以 # 开头的会被预编译器处理。有预编译器的语言有：C, C++, Ada, and PL/SQL。预编译器的一大缺点是它会修改源代码，而人们不知道送到编译器里的最终的代码是什么。</p></li><li><p>可以直接在命令行执行 <code>go doc strings.Fields</code> 获取库函数的解释；执行 <code>go get golang.org/x/tools/cmd/godoc</code> 会安装 godoc 工具，注意这两者是不同的。前者是 go 命令，后者则是 godoc 命令。执行 <code>godoc -http :8080</code> 可以启动一个 server，访问 <code>http://localhost:8080/pkg/</code> 即可看到 Go 的文档。</p></li><li><p>执行 <code>go build</code> 会显示生成一个可执行文件，仅仅一个 hello_world 就会达到 2M 大小，这是因为 Go 是静态链接，生成的文件可以直接执行，不需要再动态链接其他文件。而执行 <code>go run</code> 命令，虽然也会生成可执行文件，但是它是隐式的，之后当程序执行完后会被自动删掉。注意，看不见并不等于不存在！</p></li><li><p>所有的 UNIX 系统都支持：<code>/dev/stdin</code>、<code>/dev/stdout</code>、<code>/dev/stderr</code> 这三个特殊的文件名，它们也可以用 0、1、2 号文件描述符来描述。</p></li><li><p>fmt.Println(), fmt.Print(), and fmt.Printf() 用于打印，fmt.Sprintln(), fmt.Sprint(), fmt.Sprintf() 用于生成字符串，fmt.Fprintln(), fmt.Fprint(), fmt.Fprintf() 用于写文件。</p></li><li><p>短赋值符 <code>:=</code> 不能用于函数之外，因此全局变量只能用 <code>var</code> 声明。</p></li><li><p>下面的代码用于从标准输入读取数据，每读出一行就打印出来：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line">f = os.Stdin</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">scanner := bufio.NewScanner(f)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;"</span>, scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 ctrl+D 退出循环，因为 ctrl+D 会告知程序没有更多的数据可以读取。</p><ol start="8"><li><code>os.Args</code> 可以记录通过命令行输入的参数，并且它的类型是 []string，第一个元素是程序名，之后的为输入参数。例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run a.<span class="keyword">go</span> <span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>os.Args</code> 为 <code>[/tmp/go-build059507490/b001/exe/cla 10 1]</code></p><ol start="9"><li>关于 docker 的命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 根据 tag 创建</span><br><span class="line">docker build -t go_hw:v1 .</span><br><span class="line"></span><br><span class="line"># 列出所有的 docker images</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line">docker run go_hw:v1</span><br><span class="line"></span><br><span class="line"># 删除（-f 强制删除）</span><br><span class="line">docker rmi 5a0d2473aa96 f56365ec0638</span><br></pre></td></tr></table></figure><ol start="10"><li><p>关于 Go 的垃圾回收算法：并发标记清除、非分代、非整理，使用写屏障。</p></li><li><p>Go 为了降低 GC 的停顿时间，让 GC 和用户程序并发执行。为了让三色标记的结果不受并发执行的程序的影响，在整个标记过程中，要确保一个不变性：黑色集合里的对象保证不会指向白色集合里的对象，注意这并不影响一个白色对象指向黑色对象。我们把用户程序称为 mutator，mutator 运行了一个 writer barrier，每次当堆上有对象的指针（如果是对象的非指针字段变化，不影响）发生了变化，说明此对象可达，就要运行 writer barrier，将它变成灰色。mutator 通过 writer barrier 保证“黑色集合里的对象保证不会指向白色集合里的对象”这一不变性。这会带来性能的损耗，但这是并发执行用户程序和 GC 的代价。</p></li><li><p>垃圾回收器会在 channel 不可达时回收它，即使 channel 还未关闭。</p></li><li><p><code>time go run xx.go</code> 可以计算运行程序花费的时间。</p></li><li><p>Please remember that at the end of the day, all programs that work on UNIX machines end up using C system calls to communicate with the UNIX kernel and perform most of their tasks. 所有在 UNIX 系统上运行的程序最终都会通过 C 系统调用来和内核打交道。用其他语言编写程序进行系统调用，方法不外乎两个：一是自己封装，二是依赖 glibc、或者其他的运行库。Go 语言选择了前者，把系统调用都封装到了 syscall 包。封装时也同样得通过汇编实现。</p></li><li><p><code>strace ls</code> 查看都有哪些系统调用，<code>-c</code> 可以计数。</p></li><li><p>将 .go 文件转化成汇编代码时，可指定操作系统和架构：</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两者等价</span></span><br><span class="line">GOOS=darwin GOARCH=amd64 go tool compile -S goEnv.go</span><br><span class="line">GOOS=darwin GOARCH=amd64 go build -gcflags -S goEnv.go</span><br></pre></td></tr></table></figure><p>GOOS 和 GOARCH 可选项为：The list of valid GOOS values includes android, darwin, dragonfly, freebsd, linux, nacl, netbsd, openbsd, plan9, solaris, windows, and zos. On the other hand, the list of valid GOARCH values includes 386, amd64, amd64p32, arm, armbe, arm64, arm64be, ppc64, ppc64le, mips, mipsle, mips64, mips64le, mips64p32, mips64p32le, ppc, s390, s390x, sparc, and sparc64.</p><ol start="16"><li><p><code>go build -x defer.go</code> 展示 build 过程。</p></li><li><p>数组可以用 “:” 变成切片：array4[0:] 或 array4[:]，copy 函数只接收切片作为参数。</p></li><li><p>什么时候使用指针：1. 可以 share data，尤其是在函数之间；2. 区别某个变量是未设置还是真的零值。</p></li><li><p>关于 strings 有很多有意思的方法，例如 Repeat, Fields 等等，在<a href="https://github.com/PacktPublishing/Mastering-Go-Second-Edition/blob/master/ch04/useStrings.go" target="_blank" rel="noopener">这里</a>可以看到很多。</p></li><li><p>Go container 包有 heap/list/ring 这几个组件。</p></li><li><p><code>math/rand</code> 可用于生成伪随机数；更安全的生成随机数：<code>crypto/rand</code>。</p></li><li><p>关于可变参数的函数（A variadic function），<code>...Type</code> 称为 pack operator，而 <code>Slice...</code> 则被称为 unpack operator。一个可变参数的函数只能使用一次 pack operator。</p></li><li><p>安装一个本地包：</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/go/src/aPackage</span><br><span class="line">$ cp aPackage.go ~/go/src/aPackage/</span><br><span class="line">$ go install aPackage</span><br><span class="line">$ <span class="built_in">cd</span> ~/go/pkg/darwin_amd64/</span><br><span class="line">$ ls -l aPackage.a</span><br><span class="line">-rw-r--r-- 1 mtsouk staff 4980 Dec 22 06:12 aPackage.a</span><br></pre></td></tr></table></figure><p>编译一个本地包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile aPackage.go</span><br><span class="line">$ ls -l aPackage.*</span><br><span class="line">-rw-r--r--@ 1 mtsouk staff 201 Jan 10 22:08 aPackage.go -rw-r--r-- 1 mtsouk staff 16316 Mar 4 20:01 aPackage.o</span><br></pre></td></tr></table></figure><ol start="24"><li><p>关于 Go 版本，例如 v1.2.3，v1/v2/v3 通常是不兼容的，<code>1</code> 表示大版本，<code>2</code> 表示 feature，<code>3</code> 表示 fix。</p></li><li><p>如何和 gomod 工作：</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init</span><br><span class="line">go: creating new go.mod: module github.com/mactsouk/myModule </span><br><span class="line">$ touch myModule.go</span><br><span class="line">$ vi myModule.go</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m <span class="string">"Initial version 1.0.0"</span></span><br><span class="line">$ git push</span><br><span class="line">$ git tag v1.0.0</span><br><span class="line">$ git push -q origin v1.0.0</span><br><span class="line">$ go list</span><br><span class="line">github.com/mactsouk/myModule</span><br><span class="line">$ go list -m</span><br><span class="line">github.com/mactsouk/myModule</span><br></pre></td></tr></table></figure><ol start="26"><li>创建 v2 版本：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">"using v2.0.0"</span></span><br><span class="line">git tag v2.0.0</span><br><span class="line">git push --tags origin v2</span><br><span class="line">git --no-pager branch -a</span><br></pre></td></tr></table></figure><ol start="27"><li>使用 go mod vendor 命令来将依赖放到 vendor 文件夹里：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init useV1V2</span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><ol start="28"><li>查找哪些 go 源文件使用了 syscall：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep \"syscall\" `find /usr/<span class="built_in">local</span>/go/src -name <span class="string">"*.go"</span>`</span><br></pre></td></tr></table></figure><ol start="29"><li><p>要记住的是在绝大部分程序里不需要使用反射，所以我们得弄清楚为什么反射是必须的以及什么时候需要使用反射。反射在实现 fmt, text/template, html/template 时是必须的。例如在 fmt 包里，反射可以让你不需要明确处理所有的类型，你当然可以明确处理你知道的所有类型，但你仍然不可能处理 All possible types。</p></li><li><p>什么时候用反射：Therefore, you might need to use reflection when you want to be as generic as possible or when you want to make sure that you will be able to deal with data types that do not exist at the time of writing your code but might exist in the future. Additionally, reflection is handy when working with values of types that do not implement a common interface.</p></li><li><p>反射不好的三点：a. 大量的反射会造成程序代码难以理解和维护。一个可行的解决方法是清晰的文档注释，但众所周知，程序员是最不愿意写文档的人；b. 相比正常的数据结构，反射是动态地“决定”数据结构，因此会更慢。这些动态代码也会使得一些代码工具更难执行重构和分析；c. 反射的错误在 build 期间不会被捕获，很多都是在运行期间直接 crash 整个程序。而且这经常是在程序正常运行数月甚至是数年之后才会爆发。一个可行的办法是大量的测试，但这也不太可能覆盖完全，并且会让代码库更加庞大。</p></li><li><p>Go 不是一门面向对象的语言，但它可以模拟面向对象语言的某些功能。</p></li><li><p>flag.var 可以解析用逗号分隔的多个值。</p></li><li><p><code>wc</code> 命令的结果有三列，分别表示行数、word 数，以及字节数。平时用的最多的是 <code>wc -l</code>，表示行数；<code>wc -w</code> 表示 wrod 数；<code>wc -c</code> 表示字节数。</p></li><li><p>如何输出一个文件的权限，上代码：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arguments := os.Args</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arguments) == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"usage: permissions filename\n"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename := arguments[<span class="number">1</span>]</span><br><span class="line">info, _ := os.Stat(filename)</span><br><span class="line">mode := info.Mode()</span><br><span class="line">fmt.Println(filename, <span class="string">"mode is"</span>, mode.String()[<span class="number">1</span>:<span class="number">10</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="36"><li><p><code>crtl+C</code> 向进程发送 SIGINT 信号。Unix 里的信号其实都是软中断，用来异步处理“事件”，信号可以通过 name 和 number 来识别。进程不可能处理所有类型的信号，有些信号不能被 caught，不能被 blocked，例如 SIGKILL、SIGSTOP 不能被 caught，不能被 blocked，也不能被 ignored。因为它们给内核和 root 用户提供了特权，可以停止运行某些进程。一般我们建议用信号的 name 来操作，例如 <code>kill -s INT pid</code>。有个例外的是 SIGKILL，它对应的 number 是 9，例如我们经常执行 <code>kill -9 pid</code> 来杀死某个进程，它等价于 <code>kill -s KILL pid</code>。</p></li><li><p>最常用来发送信号的方式用 kill 命令，默认发送的是 SIGTERM 信号。<code>kill -l</code> 命令可以列出所有支持的信号。</p></li><li><p><code>go run -race xx.go</code> 可以显示有竞争冲突的代码。</p></li><li><p><code>diff pipeline.go plNoRace.go --color</code> 显示两个文件的 diff。</p></li><li><p>Go 语言的并发模型是 fork-join 型的。使用 go 关键字启动子协程工作，使用 sync.Wait 和 channel 来收集结果。</p></li><li><p>可通过设置环境变量来改变 runtime.GOMAXPROCS(0) 的输出值：<code>export GOMAXPROCS=800;</code>。</p></li><li><p>sync.RWMutex 结构体里包含 sync.Mutex，即“读写锁”是在“锁”的基本上实现的。只有当所的读锁都 Unlock 了，写锁才能被 Lock。</p></li><li><p><code>time go run xx.go</code> 可以显示执行时间，包括 real, sys, user 的执行时间。</p></li><li><p>如果子 context 取消了，父 context 没有收到消息，那么在父 context 取消前就发生了内存泄露。</p><blockquote><p>For garbage collection to work correctly, the parent goroutine needs to keep a reference to each child goroutine. If a child goroutine ends without the parent knowing about it, then a memory leak occurs until the parent is canceled as well.</p></blockquote></li><li><p>TAOCP——《计算机程序设计艺术》的作者高德纳（Donald Ervin Knuth）老爷子的一句经典的话：</p><blockquote><p>“The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.”</p></blockquote></li></ol><p>告诉我们不要老想着性能优化，在真的出现问题、出现瓶颈的时候再来考虑。</p><p>还有 Erlang 的作者之一 Joe Armstrong：</p><blockquote><p>“Make it work, then make it beautiful, then if you really, really have to, make it fast. 90 percent of the time, if you make it beautiful, it will already be fast. So really, just make it beautiful!”</p></blockquote><p>这告诉我们性能优化并不是主要工作，我们不要花费大量精力在这上面。</p><ol start="46"><li><p>做优化的前提是程序没有 bug，所以如果你在程序的第一版就来优化是有问题的，因为 v1 版本可能经常有 bug。</p></li><li><p>交叉编译命令：<code>env GOOS=linux GOARCH=386 go build xCompile.go</code>。指定操作系统、指令集。</p></li><li><p>通过 <a href="https://golang.org/pkg/bytes/" target="_blank" rel="noopener">bytes 包</a>的例子，可以看懂 godoc 和<a href="https://golang.org/src/bytes/bytes.go" target="_blank" rel="noopener">源码</a>里的 comments 的对应关系。<code>pkg/bytes</code> 文档里有很多代码样例，还可以 run 一下，但其实这些样例是写死在源码里的，就在 <code>src/bytes/example_test.go</code> 文件里。一开始没发现这个文件，我直接拿样例代码全局搜，一下就找到了。例如，源码写的如下两个 example：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleToTitleSpecial</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := []<span class="keyword">byte</span>(<span class="string">"ahoj vývojári golang"</span>)</span><br><span class="line">totitle := bytes.ToTitleSpecial(unicode.AzeriCase, str)</span><br><span class="line">fmt.Println(<span class="string">"Original : "</span> + <span class="keyword">string</span>(str))</span><br><span class="line">fmt.Println(<span class="string">"ToTitle : "</span> + <span class="keyword">string</span>(totitle))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Original : ahoj vývojári golang</span></span><br><span class="line"><span class="comment">// ToTitle : AHOJ VÝVOJÁRİ GOLANG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://golang.org/pkg" target="_blank" rel="noopener">pkg</a> 上，就对应这样：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210416085739.png" alt="go pkg example"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在前面：这本书前前后后花了挺长时间，去年 11 月份就开始读了，中间又断了，直到最近才捡起来看完。&lt;/p&gt;
&lt;p&gt;本书讲得内容非常全面，语言也很顺畅，生词非常少，并且内容没有太大难度，看起来比较过瘾，算是全面复习一下 Go 语言。如果你想开始练习阅读英文书，这本将是一个非</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://qcrao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>喜提 Go Contributor</title>
    <link href="https://qcrao.com/2021/03/30/become-a-go-typo-contributor/"/>
    <id>https://qcrao.com/2021/03/30/become-a-go-typo-contributor/</id>
    <published>2021-03-30T14:44:48.000Z</published>
    <updated>2021-08-09T14:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写了一篇<a href="https://mp.weixin.qq.com/s/Yln7xoj13PlPqH44H2zOLQ" target="_blank" rel="noopener">《喜提 Redir Contributor》</a>，内容是给欧神写的一个短网址小工具加了一个输出结果排序的功能，凑了个热闹。结果有朋友看成了 redis contributor，并没有那么牛逼~😛</p><p>但这次真的是给 golang/go 提交了代码，喜提 Go Contributor。</p><p>当然因为是第一次，只是改了几个 typos，不过也算零的突破了~</p><p>周末看 <code>proc.go</code> 代码的时候发现了几个 typos（还和欧神确认了下）。前天晚上 8 点尝试提交，昨天下午 2 点多就已经合入了 master，很快啊。</p><p>欧神说 Ian Lance Taylor 合代码比较快，我就加了他作为 reviewers，第二天早上他就给 +2 了。因为合代码需要两个 +2，所以还得@一位大佬来 +2。还没等我操作，下午再来看，一个黑哥们已经给 merge 了。这样，我的第一个 <a href="https://go-review.googlesource.com/c/go/+/305249" target="_blank" rel="noopener">Go PR</a> 就完成了，非常嗨皮~</p><p>放几张合影留念一下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210329232710.png" alt="Github golang/go 仓库"></p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210329232750.png" alt="Gerrit go"></p><p>在所有的 PR 中，typos 是最简单的，找到 comment 中的一些拼写错误，就可以提交 fix。甚至有些人直接拿工具去检测 typos，比如 <a href="https://www.grammarly.com/" target="_blank" rel="noopener">grammarly</a> 网站就可以发现语法错误，你可以把 comments copy 出来，放进去检测一下，相信可以发现一些 typos。</p><p>发现了 typos 之后，按照 Go 官方给的<a href="https://golang.org/doc/contribute#contributor" target="_blank" rel="noopener">步骤</a>一步步操作就可以提交了。</p><p>因为 Go 源码是用 Gerrit 托管的，所以最好是按照 Gerrit 的流程来操作。其实也就是注册一下 Gerrit 帐号，当然这是直接和你的 Google 帐号打通的，所以操作起来很方便，点点按钮确认一下授权就行。</p><p>提交 typos 可能很初级，在大神看来不值一提，但是对于一般同学而言，这可能是遥不可及的。但是我要说，你以为的遥不可及，很可能是压根就没想到过自己竟然可以给 Go 提交代码。</p><p>以前自己一个人埋头学习的时候，有很多信息确实不知道，书上不会告诉你去给 Go 提交代码。但是最近两年，混迹于各种微信群，刷各种公众号的推送文章，主动去做分享……感觉各种信息都追着你，你不想知道都不行。比如每次 Go 发版，都有很多篇文章砸向你，你想不看都不行。</p><p>当然，我们还是要多认真读书，少看低价值信息。但是有些时候，哪怕你仅仅是知道有这么个东西都很有价值。</p><p>比如上次和曹大、杨文、欧神录制《Go 夜聊》<a href="https://www.xiaoyuzhoufm.com/episode/5ff6c042dee9c1e16d421197?s=eyJ1IjoiNWZiYTAxM2FlMGY1ZTcyM2JiYmQxNGQ1IiwiZCI6MX0=" target="_blank" rel="noopener">播客节目</a>的时候，他们就提到第一次提交完全可以是 typos。知道了这个信息，下次我再看 Go 源码的时候就留了个心眼，如果发现错误，就可以提交 PR。</p><p>千里之行，始于足下。</p><p>提交了第一次，第二次、第三次还会远吗？</p><p>杨文在《Go 夜读》知识星球打卡 Go 源码阅读很长时间了，他也是最近一段时间才开始给 Go 提交 RP。当然第一次也是 typos，不过他已经有了一个比较大的提交了，涉及到性能的提升，也就是意味着要写测试代码。而 typos 啥都不用，改几个错别字就完了。</p><p>后来，杨文还在极客时间的直播中做了分享<a href="https://docs.google.com/presentation/d/1TT3P1f8Cv7TwxbO6KIpdUw5ZWVIo-VP3aTrCP8IT4Rc/edit" target="_blank" rel="noopener">《聊聊我的 Go Contributor 之路》</a>。</p><p>在我发布喜提 Go Contributor 消息的时候，群里有小伙伴就说：</p><blockquote><p>从我听了曹大那次播客，我就知道饶大快成为 Contributor 了~</p></blockquote><p>嗯，相信他也快了~</p><p>另外，还有个大佬 benshi 回复说：</p><blockquote><p>我有 +2 权限，typos 可以找我。</p></blockquote><p>在<a href="https://github.com/golang/go/blob/master/CONTRIBUTORS" target="_blank" rel="noopener">这里</a>可以看到所有已发正式版的 Go Contributor，<a href="https://github.com/golang/go/graphs/contributors" target="_blank" rel="noopener">这里</a>可以看到 Go Contributor 的排名，benshi 大佬排名 46：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210329232238.png" alt="benshi 排名"></p><p>最后，如果你也是 Gopher，那你也可以尝试提交第一次 PR，祝开心~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上次写了一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/Yln7xoj13PlPqH44H2zOLQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《喜提 Redir Contributor》&lt;/a&gt;，内容是给欧神写的一个短网址</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 命令 &quot;go build -X&quot; 的妙用</title>
    <link href="https://qcrao.com/2021/03/15/ingenious-use-of-go-build-x/"/>
    <id>https://qcrao.com/2021/03/15/ingenious-use-of-go-build-x/</id>
    <published>2021-03-15T14:08:04.000Z</published>
    <updated>2021-08-09T14:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家还记不记得，上次发了一篇关于 panic 检测机器人的<a href="https://mp.weixin.qq.com/s/y9pVNtC6w8Fn0Xqq6EonCw" target="_blank" rel="noopener">文章</a>，原理非常简单，简单回顾一下：</p><ol><li>业务服务在 recover 函数里通过 HTTP 请求的方式向机器人上报 panic 栈信息。</li><li>机器人解析出 panic 栈里的代码行号，调用 gitlab 接口拿到该行代码的提交人、提交日期等信息。</li></ol><p>当然，后面我又给机器人增加了一些其他的功能，例如自动拉群，自动提醒相关人修复 panic 代码等……</p><p>上面说的这些其实都很好实现，主要就是和飞书 API 打交道，再加上一些逻辑串连一下流程。目前机器人上报了 1000+ 次 panic，工作状态良好。</p><p>但偶尔还是有一些小问题的存在，例如有人用开发分支（非 master）上到线上测试环境（只读环境）测试一把，这时机器人还是用 master（默认）分支请求 gitlab 接口拿 commit 信息，拿到的信息就有可能不准。</p><p>那有没有什么好的方法能拿到正在运行的进程的代码分支呢？如果能拿到，机器人用代码路径+代码行号+代码分支，就可以从 gitlab 拿到正确的 commit 信息。</p><p>答案是有，通过 <code>go build -X</code> 注入。</p><p>那具体怎么玩的呢，通过一个小例子来说明。</p><p>下面是 <code>build.sh</code> 的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">COMMIT_ID=`git <span class="built_in">log</span> |head -n 1| awk <span class="string">'&#123;print $2;&#125;'</span>`</span><br><span class="line">AUTHOR=`git <span class="built_in">log</span> |head -n 3| grep Author| awk <span class="string">'&#123;print $2;&#125;'</span>`</span><br><span class="line">BRANCH_NAME=`git branch | awk <span class="string">'/\*/ &#123; print $2; &#125;'</span>`</span><br><span class="line">SERVICE_INFO=<span class="string">"<span class="variable">$COMMIT_ID</span>,<span class="variable">$AUTHOR</span>,<span class="variable">$BRANCH_NAME</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SERVICE_INFO</span></span><br><span class="line">go build -ldflags <span class="string">"-X codebase/build-x/compile_info.ServiceInfo=<span class="variable">$SERVICE_INFO</span>"</span> -o output/bin/build</span><br></pre></td></tr></table></figure><p>第 3、4、5 行分别用 git 命令拿到本次提交的 commit-id，author，分支名；第 6 行用 “,” 将三者组合成一个字符串；第 8 行用 <code>go build</code> 命令，设置 ldflags，将变量 <code>$SERVICE_INFO</code> 注入到包变量 <code>codebase/build-x/compile_info.ServiceInfo</code>，这样在 Go 代码中就可以直接用了。</p><p>再看看我的 compile_info 包的代码，非常简单，就定义了一个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compile_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServiceInfo <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>执行完 <code>go build</code> 命令后，compile_info.ServiceInfo 就会被赋上值，在 main 函数里打印一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"codebase/build-x/compile_info"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"init: "</span>, compile_info.ServiceInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(compile_info.ServiceInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh build.sh</span><br></pre></td></tr></table></figure><p>再执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/go/src/codebase/build-x$ ./output/bin/build</span><br></pre></td></tr></table></figure><p>得到运行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init:  9699dcaae31e7e5eab55a1d75283a6d7158a64e8,raoquancheng,master</span><br><span class="line">9699dcaae31e7e5eab55a1d75283a6d7158a64e8,raoquancheng,master</span><br></pre></td></tr></table></figure><p>可知，在 init 函数里我们就可以拿到 compile_info.ServiceInfo 的值了。</p><p>代码文件结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210313163453.png" alt="文件结构"></p><p>原理也没啥可探究的，就是通过 -ldflags 给链接器传参数：</p><blockquote><p>-X definition: 添加形式为 importpath.name=value 的字符串值定义</p></blockquote><p>其他的一些常见的命令用处：</p><blockquote><p><code>-s</code> 的作用是去掉符号信息。 <code>-w</code> 的作用是去掉调试信息。<br>go build -ldflags “-s -w” -o xxx</p></blockquote><p>之前看到公司项目里 build 脚本里的一些命令不知道有啥用，真正到了用的时候才惊呼：原来是这样！</p><p>今天的 <code>go build</code> 妙用你学会了吗？也许下次就可以在同事面前装 B 了，当然如果碰到了老司机，也可能会被打脸。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【ldflags go version】<a href="https://ms2008.github.io/2018/10/08/golang-build-version/" target="_blank" rel="noopener">https://ms2008.github.io/2018/10/08/golang-build-version/</a></p><p>【go build 命令】<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.1.md" target="_blank" rel="noopener">https://github.com/hyper0x/go_command_tutorial/blob/master/0.1.md</a></p><p>【Go 编译命令】<a href="https://chenwenke.cn/blog/2019/11/05/2019-11-05-go-build/" target="_blank" rel="noopener">https://chenwenke.cn/blog/2019/11/05/2019-11-05-go-build/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道大家还记不记得，上次发了一篇关于 panic 检测机器人的&lt;a href=&quot;https://mp.weixin.qq.com/s/y9pVNtC6w8Fn0Xqq6EonCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，原理非常简单，</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go channel 的妙用</title>
    <link href="https://qcrao.com/2021/02/04/ingenious-use-of-channel/"/>
    <id>https://qcrao.com/2021/02/04/ingenious-use-of-channel/</id>
    <published>2021-02-04T14:02:17.000Z</published>
    <updated>2021-08-09T14:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家还记不记得，上次发了一篇关于 panic 检测机器人的<a href="https://mp.weixin.qq.com/s/y9pVNtC6w8Fn0Xqq6EonCw" target="_blank" rel="noopener">文章</a>，原理非常简单，简单回顾一下：</p><ol><li>业务服务在 recover 函数里通过 HTTP 请求的方式向机器人上报 panic 栈信息。</li><li>机器人解析出 panic 栈里的代码行号，调用 gitlab 接口拿到该行代码的提交人、提交日期等信息。</li></ol><p>当然，后面我又给机器人增加了一些其他的功能，例如自动拉群，自动提醒相关人修复 panic 代码等……</p><p>上面说的这些其实都很好实现，主要就是和飞书 API 打交道，再加上一些逻辑串连一下流程。目前机器人上报了 1000+ 次 panic，工作状态良好。</p><p>但偶尔还是有一些小问题的存在，例如有人用开发分支（非 master）上到线上测试环境（只读环境）测试一把，这时机器人还是用 master（默认）分支请求 gitlab 接口拿 commit 信息，拿到的信息就有可能不准。</p><p>那有没有什么好的方法能拿到正在运行的进程的代码分支呢？如果能拿到，机器人用代码路径+代码行号+代码分支，就可以从 gitlab 拿到正确的 commit 信息。</p><p>答案是有，通过 <code>go build -X</code> 注入。</p><p>那具体怎么玩的呢，通过一个小例子来说明。</p><p>下面是 <code>build.sh</code> 的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">COMMIT_ID=`git <span class="built_in">log</span> |head -n 1| awk <span class="string">'&#123;print $2;&#125;'</span>`</span><br><span class="line">AUTHOR=`git <span class="built_in">log</span> |head -n 3| grep Author| awk <span class="string">'&#123;print $2;&#125;'</span>`</span><br><span class="line">BRANCH_NAME=`git branch | awk <span class="string">'/\*/ &#123; print $2; &#125;'</span>`</span><br><span class="line">SERVICE_INFO=<span class="string">"<span class="variable">$COMMIT_ID</span>,<span class="variable">$AUTHOR</span>,<span class="variable">$BRANCH_NAME</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SERVICE_INFO</span></span><br><span class="line">go build -ldflags <span class="string">"-X codebase/build-x/compile_info.ServiceInfo=<span class="variable">$SERVICE_INFO</span>"</span> -o output/bin/build</span><br></pre></td></tr></table></figure><p>第 3、4、5 行分别用 git 命令拿到本次提交的 commit-id，author，分支名；第 6 行用 “,” 将三者组合成一个字符串；第 8 行用 <code>go build</code> 命令，设置 ldflags，将变量 <code>$SERVICE_INFO</code> 注入到包变量 <code>codebase/build-x/compile_info.ServiceInfo</code>，这样在 Go 代码中就可以直接用了。</p><p>再看看我的 compile_info 包的代码，非常简单，就定义了一个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compile_info</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServiceInfo <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>执行完 <code>go build</code> 命令后，compile_info.ServiceInfo 就会被赋上值，在 main 函数里打印一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"codebase/build-x/compile_info"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"init: "</span>, compile_info.ServiceInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(compile_info.ServiceInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh build.sh</span><br></pre></td></tr></table></figure><p>再执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/go/src/codebase/build-x$ ./output/bin/build</span><br></pre></td></tr></table></figure><p>得到运行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init:  9699dcaae31e7e5eab55a1d75283a6d7158a64e8,raoquancheng,master</span><br><span class="line">9699dcaae31e7e5eab55a1d75283a6d7158a64e8,raoquancheng,master</span><br></pre></td></tr></table></figure><p>可知，在 init 函数里我们就可以拿到 compile_info.ServiceInfo 的值了。</p><p>代码文件结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210313163453.png" alt="文件结构"></p><p>原理也没啥可探究的，就是通过 -ldflags 给链接器传参数：</p><blockquote><p>-X definition: 添加形式为 importpath.name=value 的字符串值定义</p></blockquote><p>其他的一些常见的命令用处：</p><blockquote><p><code>-s</code> 的作用是去掉符号信息。 <code>-w</code> 的作用是去掉调试信息。<br>go build -ldflags “-s -w” -o xxx</p></blockquote><p>之前看到公司项目里 build 脚本里的一些命令不知道有啥用，真正到了用的时候才惊呼：原来是这样！</p><p>今天的 <code>go build</code> 妙用你学会了吗？也许下次就可以在同事面前装 B 了，当然如果碰到了老司机，也可能会被打脸。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【ldflags go version】<a href="https://ms2008.github.io/2018/10/08/golang-build-version/" target="_blank" rel="noopener">https://ms2008.github.io/2018/10/08/golang-build-version/</a></p><p>【go build 命令】<a href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.1.md" target="_blank" rel="noopener">https://github.com/hyper0x/go_command_tutorial/blob/master/0.1.md</a></p><p>【Go 编译命令】<a href="https://chenwenke.cn/blog/2019/11/05/2019-11-05-go-build/" target="_blank" rel="noopener">https://chenwenke.cn/blog/2019/11/05/2019-11-05-go-build/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知道大家还记不记得，上次发了一篇关于 panic 检测机器人的&lt;a href=&quot;https://mp.weixin.qq.com/s/y9pVNtC6w8Fn0Xqq6EonCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，原理非常简单，</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>事故现场之依赖了不该依赖的 host ip</title>
    <link href="https://qcrao.com/2021/01/29/error-depend-on-host-ip/"/>
    <id>https://qcrao.com/2021/01/29/error-depend-on-host-ip/</id>
    <published>2021-01-29T02:18:55.000Z</published>
    <updated>2021-01-29T02:19:10.968Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，组里服务遇到了一个诡异的问题，跟着看了下原因，记录在此。</p><p>先介绍背景：我们维护了两个服务，一个对外服务，承接流量，称之为主服务，主服务会调用各种第三方 RPC 服务，获取各种字段，拼在一个大的 model 上。其中有一个 RPC 服务，称之为 E 服务，是我们自己维护的，它返回一部分字段。</p><p>E 服务会定时读取规则平台上的规则数据，根据这些规则计算返回给主服务的数据。运营或产品在规则平台上配置新的规则，通过审核后，E 服务会读取到新的规则，并应用到计算中，从而生成新的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210129090320.png" alt="数据流向"></p><p>再将视角放大一些，我们的服务实际是整个链路上的一环，每次有新业务需求的时候，上下游还有各种服务需要变更，业务上线需要经过测试、联调、小流量、上线等阶段。</p><p>通常有新业务需求的时候，我们这部分只需要变更配置，在规则平台上操作就行了。主服务和 E 服务均是只读服务，为了测试方便，E 服务部了两个集群：default 集群（用于服务线上流量）、test 集群（用于线上测试）。QA 以及上下游可以调 test 集群的接口进行线上测试（当然这之前会经过线下环境测试）。</p><p>因此，只需要将新增的规则加载到 test 集群用于测试，但不加载到 default 集群影响线上流量。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210129091245.png" alt="两个集群"></p><p>规则平台提供 GetRules 接口返回全量规则数据。每个规则实际上可能有两个版本（切片含 2 个元素）：小流量、全流量。规则上还有一个字段表示生效范围，对于小流量而言，表示哪些 ip 生效。当小流量验证没问题并推全量后，这个规则就只有一个版本了（切片只有一个元素）。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210129091818.png" alt="小流量、全流量规则的变化"></p><p>首次配置新规则时，先推小流量，配置项里需要填生效的 ip 列表。审核通过后，所有调用 GetRules 接口的 E 服务实例都能拿到新规则，但只有特定 ip 的实例才会使用新规则生成数据，这个 ip 就是之前配置规则 时填的。</p><p>只有机器 ip 和配置的小流量 ip 一致，才会使用小流量规则，否则就用全量规则。如果这个规则是第一次上，没有全量版本，那相当于这条规则不可见。对那些已经全量了的规则，需要有一些小的改动，就会先推小流量，这些规则就会包含两个版本。</p><p>为了方便测试，test 集群默认使用小流量规则。也就是说每次只要规则有变更，test 集群都能感知到，即它不受小流量 ip 的限制。</p><p>经历完线下测试、线上 test 集群测试等环节后，将小流量生效范围改成线上 default 集群的某个实例的 ip。这时只有这个实例能感知到新规则，等到验证、观察一段时间后，再推全量。这个新业务需求就全量平稳上线了。</p><p>背景就介绍到这里，本次事故的主人公，host ip 其实已经登场了。接着就来详细说说事故经过及原因。</p><p>前天有新业务需求过来，我们在规则平台上配置了一个新的规则，小流量配置了一台 test 集群的实例 ip 作为生效范围。这里实际上任意配置一个 ip 即可，因为 test 集群不看这个 ip，直接加载新规则。使用文档上说的是任意 ip 即可，但配置规则的同学为了“保险”，配上了 test 集群某台实例的 ip，自然也没问题（本来说的就是任意 ip 嘛），并且会“认为”更“保险”。</p><p>配置完成后，test 集群有 panic 发生，这个 panic 和新规则是有关的，只有加载了新规则后才会导致 panic 的发生。因此修复了一版代码，并且上线了 test 集群。</p><p>昨天中午收到主服务的业务方反馈，模型的某些关键字段有缺失。这些字段是调 E 服务获取的，因此排查 E 服务。再看字段开始缺失的时间和前一天上线 test 集群的时间是吻合的。但诡异的是，我们线上 default 集群并没有加载新规则，并且我们因为 panic 也只上线了 test 集群，为什么会影响线上流量呢？</p><p>非常诡异。</p><p>接着我们查到线上 default 集群也有 panic（报警失效了，这里待查），但这个 panic 只有在加载了新规则之后才会发生。问题是我们并没有让 default 集群加载新规则啊？</p><p>不对，这个 default 集群实例的 host ip 怎么和之前配置的小流量 ip 是一样的？这个 ip 是 test 集群的某台实例的。</p><p>再看 default 集群的这个实例启动时间和我们上线 test 集群的时间是吻合的，并且有先后关系，看起来是因果关系：上线 test 集群，导致 default 集群的某个实例发生了迁移，并且迁移到了某台物理机上，而这个物理机的 ip 正是之前配置的小流量 ip。</p><p>于是，“因果” 关系就出来了：上线 test 集群，导致 default 集群的某个实例被调度到之前 test 集群某个实例所在的 host 上。现在 default 集群的这个实例的 host ip 就在新规则的小流量范围内，因此加载新规则。然而新规则会导致 panic，但修复 panic 的变更只上线了 test 集群，因此 default 集群的某台实例会 panic，进而导致它返回的数据缺失某些字段。</p><p>问题的原因查到了，但同时也很费解：不同集群的实例所在的 host ip 能一样吗？为什么上线 test 集群，会引起 default 集群的实例发生调度？</p><p>在咨询了 Oncall 之后，我们才知道：</p><blockquote><p>正常的维护，集群内机器负载的变化，都会造成实例的重新调度。</p></blockquote><p>继续追问：</p><blockquote><p>如果是一般的机器负载变化什么的引起的重新调度是容易理解的。但这个 case 诡异的地方在于：我升级了一个 test 集群的实例 a（它在 host1 上），升级完成的同时，default 集群的一个实例被迁移到了 host1 上。而且，这明显是有“因果”关系（从时间上来看）的。现在想知道这个因果关系是有可能的吗？如果是，能查到具体的因 -&gt; 果吗？</p></blockquote><p>Oncall 继续追查，发现这个所谓的因果关系并不成立，前后相隔了 2 分钟。可能是实例 b 所在的机器负载比较高，而 a 实例所在的机器因为 a 刚被调度走，负载下来了，实例 b 有更优的调度选择，就恰好被调度到 host1 上了。</p><p>进一步追问得知，不同集群的实例 ip 是有可能相同的。因为 test/default 集群是两个业务集群，它们实际在同一个物理集群上，所以它们的实例有可能被调度到同一个 host。</p><p>如果我们新建了两个业务集群（同一个物理集群），目的是进行隔离。既然不同集群的实例可能会被分配到同一台机器上，那还能起到隔离的作用吗？</p><p>可以。首先，流量调度会根据业务集群进行，基本就能进行隔离了。并且，一般情况下，实例都是有资源限制的，不太可能会让其他实例受影响。</p><p>总之，事故的原因是我们依赖了不该依赖的 host ip。想到的解决办法有 2 点：</p><ol><li>在 test 集群测试时，小流量 ip 随便给一个无效的值，例如：127.0.0.1。这样，default 集群就不可能加载到小流量的新规则了。缺点是当 default 集群小流量的时候，设置的 ip 上可能有多个实例，小流量变成了中流量。</li><li>将小流量 ip 改成使用 pod-name。缺点是这个实例可能会被突然调度走，无法进行小流量测试了。</li></ol><p>小流量 ip 这个不起眼的地方，竟然会引起事故。根本原因是我们在容器环境下，还依赖了 ip，这是有问题的。并且实例调度时机有哪些、不同集群的实例 ip 会不会相同，这些我们之前并没有弄清楚。</p><p>延伸一下，我们不该依赖任何没有弄清原理的东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天，组里服务遇到了一个诡异的问题，跟着看了下原因，记录在此。&lt;/p&gt;
&lt;p&gt;先介绍背景：我们维护了两个服务，一个对外服务，承接流量，称之为主服务，主服务会调用各种第三方 RPC 服务，获取各种字段，拼在一个大的 model 上。其中有一个 RPC 服务，称之为 E 服务，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>写一个 panic blame 机器人</title>
    <link href="https://qcrao.com/2021/01/11/panic-blame-robot/"/>
    <id>https://qcrao.com/2021/01/11/panic-blame-robot/</id>
    <published>2021-01-11T01:17:59.000Z</published>
    <updated>2021-01-11T01:19:19.247Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手了一个“公共”服务，负责维护它的稳定性。代码库有很多人参与“维护”，其实就是各种业务方使劲往上堆逻辑。虽然入库前我会进行 CR，但多了之后，也看不过来，还有一些人自己偷摸就把代码合到 master 上去了。总之，代码质量无法得到很好的保证。</p><p>当然了，如果把合代码的权限收敛到我一个人，理论上是可行的。但是，一方面，业务迭代的速度很可能就 block 在我这了；另一方面，业务方的迭代逻辑涉及很多具体的业务，我也不太熟。所以，CR 的时候也只能看一些诸如 go 出去的 func 有没有加 recover、有没有异常使用空指针等等，对于业务相关的代码提不出什么有用的意见。</p><p>其实有一些业务方的逻辑和其他业务方完全独立（使用的接口和其他业务方独立），后续会将当前的服务完全“复制”一份出来，交给业务方自行维护。</p><p>但眼下有一个问题需要解决：报警群里时不时来一个 recovered panic 的报警，我看到报警后就要登上机器看日志，执行 “grep -C 10 panic xxx.log” 这样的命令看 panic 发生在哪里。再执行 <a href="https://wxnacy.com/2019/05/21/git-blame/" target="_blank" rel="noopener">git blame</a> 看看究竟是谁写的，再去群里 @ 他进行处理。但很多情况下是这些 panic 是由脏数据导致的，发生的也不频繁，并且 panic 被 recover 住了，所以也不太着急。</p><p>问题是业务方写完了代码之后，基本也不太关心服务运行地怎么样，但作为服务负责人得管。像前面提到的 panic 报警发生的多了，我“查日志，定位到代码提交人再通知他处理”的事情多了之后，就想能不能写一个 panic blame 机器人来做这件事。这样就能省不少事，而且还显得那么优雅。</p><p>想好了要做这件事，其实也并不困难。</p><p>最朴素的思路就是在 recover 函数里把 panic 发生时的一些信息，例如 pod-name、机器 ip、服务名、stack 等通过 HTTP 请求发送到某个服务，这个服务收到 stack 后分析出 panic 的那行代码，再请求 git 服务的某个接口，拿到提交人及提交时间。整体如下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/IMG_7121.JPG" alt="整体框架"></p><p>我们再看看具体代码是怎么写的。例如，Recover 函数是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverFromPanic</span><span class="params">(funcName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">64</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line"></span><br><span class="line">logs.Errorf(<span class="string">"[%s] func_name: %v, stack: %s"</span>, funcName, e, <span class="keyword">string</span>(buf))</span><br><span class="line"></span><br><span class="line">panicError := fmt.Errorf(<span class="string">"%v"</span>, e)</span><br><span class="line">        panic_reporter_client.ReportPanic(panicError.Error(), funcName, <span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向机器人服务端发送 panic 信息的 panic_reporter_client 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">"http://localhost:8888/report-panic"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免造成 panic report 服务被打挂，降低发送 http 请求频率，进程生命周期内只发一次</span></span><br><span class="line"><span class="keyword">var</span> panicReportOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PanicReq <span class="keyword">struct</span> &#123;</span><br><span class="line">Service   <span class="keyword">string</span> <span class="string">`json:"service"`</span></span><br><span class="line">ErrorInfo <span class="keyword">string</span> <span class="string">`json:"error_info"`</span></span><br><span class="line">Stack     <span class="keyword">string</span> <span class="string">`json:"stack"`</span></span><br><span class="line">LogId     <span class="keyword">string</span> <span class="string">`json:"log_id"`</span></span><br><span class="line">FuncName  <span class="keyword">string</span> <span class="string">`json:"func_name"`</span></span><br><span class="line">Host      <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">PodName   <span class="keyword">string</span> <span class="string">`json:"pod_name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReportPanic</span><span class="params">(errInfo, funcName, stack <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">panicReportOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">recover</span>()&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">panicReq := &amp;PanicReq &#123;</span><br><span class="line">Service:   env.Service(),</span><br><span class="line">ErrorInfo: errInfo,</span><br><span class="line">Stack:     stack,</span><br><span class="line">FuncName:  funcName,</span><br><span class="line">Host:      env.HostIP(),</span><br><span class="line">PodName:   env.PodName(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonBytes []<span class="keyword">byte</span></span><br><span class="line">jsonBytes, err = json.Marshal(panicReq)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req *http.Request</span><br><span class="line">req, err = http.NewRequest(<span class="string">"GET"</span>, url, bytes.NewBuffer(jsonBytes))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;Timeout: <span class="number">5</span> * time.Second&#125;</span><br><span class="line"><span class="keyword">var</span> resp *http.Response</span><br><span class="line">resp, err = client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析出 panic 消息的代码也不难，我们需要看一下如何从 stack 信息中找到 panic 的那一行。</p><p>举一个例子来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> RecoverFromPanic(<span class="string">"fun c"</span>)</span><br><span class="line">fmt.Println(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">var</span> a *Student</span><br><span class="line">fmt.Println(a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverFromPanic</span><span class="params">(funcName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">64</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"[%s] func_name: %v, stack: %s"</span>, funcName, e, <span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个有几层调用关系的例子，假装我们年幼无知直接解引用了一个空指针，导致 panic，但被 recover 了，输出的调用栈信息如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.RecoverFromPanic(0x4c4551, 0x5)</span><br><span class="line">        /home/raoquancheng/go/src/hello/test.go:36 +0xb5</span><br><span class="line">panic(0x4a9340, 0x55b8d0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/panic.go:679 +0x1b2</span><br><span class="line">main.c()</span><br><span class="line">        /home/raoquancheng/go/src/hello/test.go:26 +0xd4</span><br><span class="line">main.b()</span><br><span class="line">        /home/raoquancheng/go/src/hello/test.go:15 +0x7a</span><br><span class="line">main.a()</span><br><span class="line">        /home/raoquancheng/go/src/hello/test.go:10 +0x7a</span><br><span class="line">main.main()</span><br><span class="line">        /home/raoquancheng/go/src/hello/test.go:30 +0x20</span><br></pre></td></tr></table></figure><p>栈信息中，首先是 <code>runtime.Stack</code> 函数那一行；接着是 <code>/usr/local/go/src/runtime/panic.go:679</code>，也就是 runtime 里的 <code>gopanic</code> 函数；下一行就是真正引起 panic 的使用空指针的那一行代码，这是罪魁祸首，panic blame 机器人主要关注这个；之后的信息就是调用链关系，会一直追溯到 <code>main</code> 函数里调用 <code>a()</code> 的源头。</p><p>分析出来这些信息后，向 IM 提供的机器人 webhook 地址发送 panic 消息，并顺带 @ 刚才找到的代码提交人，老哥，你又写出 panic 了：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20210110234247.png" alt="机器人通知"></p><p>这样是不是就是万事大吉了？</p><p>并不是，还有一些关键问题需要考虑。首先业务进程不能阻塞在发送 panic 信息的过程中，且发送 panic 信息的代码不能再发次发生 panic，以免给业务进程带来二次伤害。这样就需要以异步的方式发送消息，并且最好是通过消息队列或者 UDP 这种“我发完了就不管了”的姿态发送。</p><p>机器人服务端用生产者消费者的形式来解析业务进程发送上来的消息。无论业务进程是以 HTTP，还是 UDP 或者消息队列发过来的 panic 报告请求最终都要进入一个“池子”，HTTP、UDP、消息队列也就是所谓的生产者，消费者协程则从“池子”里取出 panic 报告请求，解析、发送报警@人处理。</p><p>还有一个需要考虑的是机器人服务端不要被打跨了，尤其是考虑到一些业务跑在几千个实例上的时候，更要注意了。</p><p>分别从客户端和服务端两方面来看。</p><p>对于客户端，在一个进程生命周期内，同时发生多“种” panic 的情况并不多见，因此我们只需要在进程生命周期内发送一次就行了，用 <code>sync.Once</code>。</p><p>在服务端，对同一个业务发送的请求进行限流和聚合，例如每秒只处理同一个业务的一个请求，对被限流的请求做聚合，报告一个总的 panic 数量就行了。</p><p>另一个可能需要考虑的是如果 panic 代码提交者离职了怎么办？或者说我只是做了一下 format，真实的提交者并不是我，怎么办？</p><p>我们并不能做到 100% 的准确，现实有很多的边角没法解决。比如代码提交者并没有离职，但他转岗了……有个可以考虑的方法是看 panic 那一行代码附近的最近修改过代码的人是谁，找他，或者直接找服务负责人好了。不求完美，只要能解决大部分问题就行了。</p><p>实现一个 panic blame 机器人比较简单，但考虑服务稳定性的话，还是有一些点要注意的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近接手了一个“公共”服务，负责维护它的稳定性。代码库有很多人参与“维护”，其实就是各种业务方使劲往上堆逻辑。虽然入库前我会进行 CR，但多了之后，也看不过来，还有一些人自己偷摸就把代码合到 master 上去了。总之，代码质量无法得到很好的保证。&lt;/p&gt;
&lt;p&gt;当然了，如</summary>
      
    
    
    
    <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>那些年曹大写过的博客</title>
    <link href="https://qcrao.com/2020/12/27/blogs-written-by-xargin/"/>
    <id>https://qcrao.com/2020/12/27/blogs-written-by-xargin/</id>
    <published>2020-12-27T14:09:35.000Z</published>
    <updated>2021-03-23T10:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>某天晚上看到曹大在群里指点江山，折服。感叹为何曹大如此渊博，遂决定从头到尾研读完他所有的博文。</p><p>前后共花了一个月的时间，今天终于读完了（2020-11-24~2020-12-26），总共 118 篇。从 15 年 10 月 31 日开始的第一篇，到今天，总共写了 5 年多的时间。基本上每半个月产出一篇，非常稳定。</p><p>从最初讲具体的工作，例如将 MySQL 数据导入到 ES，到近期的《中台的末路》、《架构的腐化》、《工程师应该怎么学习》等名篇，水平一步步提高，视野也在一步步变大。</p><p>这些博文里很多内容都是从工作中提炼、总结出来的，这需要对自己所做的工作非常熟悉，并且需要做很多思考才行。这对我们而言，是有启发的。</p><p>还有一些是论文或文档的翻译，翻译它们而不是仅仅看一遍，对我们深刻理解内容是很有帮助的。连曹大都这样做了，我们有什么理由不做呢？</p><p>总的感受是，我们需要不断思考、反思、总结，并且持续不断地写出来。在所有文章里，如果只推荐一篇的话，那无疑就是<a href="https://xargin.com/how-to-learn/" target="_blank" rel="noopener">《工程师应该怎么学习》</a>这篇。其中最激励我的一段是：</p><blockquote><p>人这一辈子，最重要的是能把路越走越宽。对于工程师来说，能够锻炼软技能的场合其实不是很多，但也不代表完全没有。即使没有也可以自己创造机会，例如组内、组间、部门内的技术分享都是不错的机会。</p></blockquote><blockquote><p>更大规模的技术分享可能因为主办方“势力眼”，在你级别不高或者影响力不大的时候，不提供给你这样的机会，但是作为一个向上的人，迟早会有走到这一步的一天。你所要做的是提前做好准备，在那一天到来的时候，在聚光灯下旁征博引，谈笑风生。</p></blockquote><blockquote><p>祝大家都能成为更好的自己！</p></blockquote><p>我们只有保持终生学习的姿态，才有可能不被时代抛弃。</p><blockquote><p>If you don’t keep moving, you’ll quickly fall behind.</p></blockquote><p>下面是详细的文章内容介绍，最后有一张表格，列出了所有的文章链接和概览。因为 xargin.com 没有 archive 功能，所以这篇文章算是全网最全的、最方便的博客入口。</p><hr><p>第 1 篇是 15 年 10 月 31 日开始的，到今天已经 5 年了，主要讲如何使用 vagrant 来搭建一套 lnmp（linux/nginx/mysql/php）开发环境，解决一些诸如只用线上才出现的 bug，以及新同学如何能快速搞定开发环境。</p><p>第 2 篇主要讲的是一致性哈希。我又查了下其他资料，总结下一致性哈希的优点：当增减 server 时，可以移动最少的 keys；因为数据是均匀分布的，所以更容易水平扩展。现实世界中，比如 Amazon’s Dynamo 数据库的分区组件、Apache Cassandra 跨集群的数据分区等等都用到了一致性哈希。</p><p>第 3 篇是将 MySQL 里的数据导入到 Solr 来满足一些特定的查询需求。</p><p>第 4 篇把 Solr 换成 ES，再来一次。</p><p>第 5 篇主要内容是说用 PHP 实现服务发现很难，不如 Java 那样方便。人家亚马逊的贝索斯在 2002 年就要求服务化，而阿里则是 2009 年则开始的。</p><p>第 6 篇主要内容是讲从 MySQL 导入大量数据时，碰到 GC 问题，导致连登陆都不行，最后通过加大 JVM 的运行时内存解决；Stop the world 机制简称 STW，即在执行垃圾收集算法时，Java 应用程序的其他所有除了垃圾收集帮助器线程之外的线程都被挂起；思想其实很朴素，用空间来换时间。</p><p>第 7 篇是关于乐观锁的内容，悲观锁用 select for 先锁定记录，然后再 update 更交换机数据；而乐观锁则比较前后的版本（例如订单，也可以比较 status）来解决并发更新时的数据覆盖问题。记住这个时间点，5 年前，曹大刚听说乐观锁^_^。</p><p>第 8 篇是一份 Redis 事务相关的文档翻译。主要内容有事务的使用、事务的错误、使用 watch 等。</p><p>第 9 篇还是一个连续剧，书接第 6 篇，在实际操作的过程中，将 MySQL 的数据导入到 ES 中遇到的导入数据有丢失的问题，主要原因是有主从延迟。处理办法就是每次都去向前多取一点：<code>select * from [业务表] where update_time &gt; date_sub(now(), 10 minute);</code>。嗯，曹大会刻意总结在工作中遇到的问题及思考的解决方案，即使看起来比较简单。</p><p>第 10 篇其实也是一个续集（一致性哈希），书接第 2 篇，主要讲了 2 种缓存客户端如何生成虚拟节点的算法。并且，从这篇文章得知，PHP 是没有什么可以全局复用的全局变量的，所以每次 web 请求从 nginx 到 cgi 都会重新走各种 web 框架的 index.php。</p><p>第 11 篇主要是总结了在开发的过程中遇到的问题及解决方案，它同时也是曹大在公司做过的分享。比较重要的点有：没有填 <code>update_time</code> 而采用了 <code>create_time</code>，且由于主从同步或者时钟或者其他问题导致的“工单系统是有可能在未来创建过去一段时间的工单的”，或者说“一个时刻创建了在这个时刻之前”，这个是通过每次都向前多取 10 分钟的变更数据。还有一个点是每天低峰期删数据导致的大量删除 binlog 会对系统造成压力。另外，这时就已经用了 gin 框架了。</p><p>第 12 篇是对当时同步 MySQL 和 ES 的方案的一个总结反思，说明了优点和缺陷。嗯，估计是最后一篇了。前后也有四、五个月了。</p><p>第 13 篇曹大喷了一个 php 框架 laravel 里的一个实现：闭包套闭包在函数调用的时候类似于递归调用，也存在压栈压爆的问题。最后一段：没错，拿技术解决问题，但是不要为了炫技而炫技。(特别是你的特技可能连一个“丑陋”的解决方案都打不过。找到一篇 Go 相关的责任链<a href="http://tigerb.cn/2020/04/02/go-patterns/responsbility/" target="_blank" rel="noopener">文章</a>，对照看一下。</p><p>第 14 篇是看一个用 C 写的消息队列的源码。重点在于曹大对于“如何做分布式”的总结和思考：proxy 和 smart client。</p><p>第 15 篇讲的是如何设计一个灰度发布系统。从作用到分桶/分类策略，到用哈希算法对 key 进行哈希分桶从而实现千分比灰度。最后还提了几个问题并作了解答：使用 md5 和 sha1 不能保证均匀分布怎么办？如何选取分桶？使用 md5 或者 sha1 对 CPU 消耗太高怎么办？学到了两个如何对字符串算 md5 和 sha1 的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n 15810321343 |openssl dgst -sha1</span><br><span class="line">md5 -s 15810321343</span><br><span class="line"></span><br><span class="line">15810321343</span><br><span class="line"></span><br><span class="line">md5=&gt;</span><br><span class="line">05eadde36e5e5c3a00015a8f07d98d6b</span><br><span class="line"></span><br><span class="line">sha1=&gt;</span><br><span class="line">7962e1ba260de074ef895af44c62ad353ee36c2c</span><br></pre></td></tr></table></figure><p>第 16 篇从数据库、检索服务、日志三个方面来谈 ES 能做的事，以及优势和限制。企业内部使用的 elasticsearch 是提供垂直搜索的一种方案，内容可能是一些结构化的数据，而不像大搜索那样都是杂乱的内容。数据库层面，查询条件可以转化为 bool 查询；单表 count 也容易解决；但 ES 不能实现 Join，事务。在检索服务层面，集群便可以非常方便地进行动态扩展，数据也不容易丢失；缺点是分词不是很科学。日志方面，ELK，每天建一个索引。</p><p>第 17 篇介绍了曹大自己开发的工具：elasticsql，使用 SQL 来查询 ES，目前 629 星。工作中遇到了问题，然后就手动开发一个工具，并且写文章总结，赞！</p><p>第 18 篇讲迅雷。文件会按 16KB 进行切分，每个文件块用 sha1 算法计算一个哈希值，用作小块的校验。将一个文件的所有小块的 sha1 连接得到的字符串再进行 sha1，得到整个文件的 id。之后简单讲了 server hub、peer hub、file server 的工作原理。因为迅雷成立时，互联网上的轮子并没有那么多，所以很多都得自研，文档也不全。最难解决的问题不是 P2P 下载，而是各种乱七八糟的 case。</p><p>第 19 篇列出了实际工作过程中碰到的各种低级的做法。我自己印象深刻的且之前没碰到过的有：滥用回调，增加系统复杂性；访问数据库不做批量；树形结构的表结构设计问题；工作流系统update不判断修改前的状态；抱怨接口性能是语言问题。嬉笑怒骂，皆成文章。</p><p>第 20 篇，把 logstash/kibana/elasticsearch 之类的东西统统变成 5.0 的过程中，遇到的一些问题及解决。</p><p>第 21 篇，公司登陆验证用的 Google Authenticator 来做校验的原理。也就是将一个 key 分发给某个具体的帐户，然后服务端和客户端可以每隔 30 s 算一个 token。将 token 和帐户验证即可确定身份。</p><p>第 22 篇，翻译的一个后 GitHub 上的后端面试<a href="https://github.com/monklof/Back-End-Developer-Interview-Questions" target="_blank" rel="noopener">项目</a>，并给出一些问题的回答。这些题基本都是比较开放的问题，很少一问一答这种。5 年前的了，不过我看原项目地址 7 个月前还有更新。</p><p>第 23 篇，HTTP 中间件的形式如何写。这里给出了一些前置、后置、耗时统计的控制的例子，不过最后给的一个例子有点问题，不是太好理解。我找到了一篇叶剑峰大佬写的比较好理解的，能直接运行的<a href="https://blog.huoding.com/2019/01/31/716" target="_blank" rel="noopener">例子</a>。可以看到，《Go 语言高级编程》中也有这篇内容，可见平时的积累是非常重要的。</p><p>第 24 篇是问题 kafka 消息重复问题的排查，其实也没有各种现场排查，最终仅通过文档的说明就发现了问题：消费者在 poll 的时候才发送心跳，那如果处理消息的时间稍长就会被判失活，导致将正在消费的 partition rebalance 给其它消费者。因此解决办法就是升级到 0.10。这也告诉我们不要太快使用新发布的软件，因为有很多问题还没有生产环境中发现。</p><p>第 25 篇又是一篇吐槽文，工作中有时总是会遇到太“笨”的合作方，人家不会转一点脑子，什么问题都来问你，本来你就已经清楚地说明了。但一旦有什么在他们预期之外的事情，他就会来麻烦你。文中给出一些应对的办法，这当然需要后端去学习一些前端知识。工程师，终身学习是基本的。</p><p>第 26 篇，讲的是 redis 的 SDS 是不是二进制安全的。简单来说，通过使用<a href="https://www.cnblogs.com/jing99/p/11687308.html" target="_blank" rel="noopener">二进制安全的 SDS</a>，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，还可以保存任意格式的二进制数据。起因是看到群里有人看到 redis 里有 strlen 的调用，就怀疑 redis 的 SDS 的二进制安全是不是真的。之后，一番实验和看代码，发现真正调用 sdsnew 函数的是在内部字符串用或者是测试用。</p><p>嗯，2016 年的博客看完了，总共 26 篇，基本两周一篇的节奏。</p><p>第 27 篇，是一篇<a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">译文</a>。Redis 客户端和 Redis 服务器使用 RESP 协议通信，RESP 是 REdis Serialization Protocol 的简称。虽然 redis 协议设计得十分对阅读友好(human readable)并且十分容易实现，但实际实现起来和二进制协议的性能依然比较接近。例如，RESP 使用了前缀的 length 来传输 bulk 数据，所以没有必要像 JSON 一类的数据结构需要通过扫描来查找特殊字符，也没必要在发送数据的时候给数据加上引号（quote the payload）之类的。</p><p>第 28 篇，在某个本来想打游戏度过的周末，听说有 B 站的分享，于是去听了，结尾感慨：本来用来打游戏的周末又学了不少东西。整篇文章就是对这次分享的一次总结，其中又结合自己平时的思考。有一点是讲业务和基础架构绑在一起的好处。</p><p>第 29 篇，发现曹大有个习惯比较好，就是经常会翻译一些比较重要的文档。因为人总是容易遗忘，即使某个东西你现在很清晰，过了一段时间之后就会忘记。我想记住的具体的知识点就是：leader 会维护一个 in-sync replica (ISR) 的集合：是和 leader 的进度完全一致的那些 follower。其他的先不深究。</p><p>第 30 篇是一篇思考，关于系统如何处理错误，直白一点是如何向用户、向研发展示错误。应该管用户一些提示，而不是直接白屏，用户在故障之后恢复时能正常使用系统，而不是像有些权限系统设计的那样缓存个几天。对研发而言，根据错误能快速定位到错误的地方是最重要的。开头整理的一些错误场景总结如下：依赖组件挂了；依赖服务挂了；依赖方超时了；调用方的参数有问题；调用方的参数无法正确地通过校验；用户的某种操作在业务逻辑上不具有合理性，不能够接着让他执行下去；程序自身出错了，比如数组越界，对字符串和数字进行加和操作，或者是把 null 当成了某种合法的数据结构，通过点或者下标来获取某种属性。</p><p>第 31 篇，吐槽 Go 包非中心化管理的一些问题。最主要的一个问题是不好和开源项目“合作”的问题。</p><p>第 32 篇，介绍了分布式如何实现。首先是用 MySQL 实现，但解决不了租期的问题；接着用 redis 的 setexnx 命令，也有一个问题是：因为 redis 的主从同步是异步行为，在主上加锁成功，数据没有同步之前 master 挂掉了，那之后就可能会有多个实例（用户进程）持有锁，这显然不是我们希望的。（这里我的理解是其他用户进程会能向新主申请到锁）；然后就是 redis 的作者提出了 Redlock 的加锁方法。</p><p>第 33 篇，使用代码示例讲解如何使用 parser 包做一些“高级”的事情：基于 ast 做很多静态分析、自动化和代码生成的事情，非常酷炫。</p><p>第 34 篇，利用 MySQL 的 information_schema 表来自动生成代码，依然很酷炫。</p><p>第 35 篇，讲 awesome go 的入选标准，主要关注两方面：1. goreport（包含 gofmt/go_vet/gocyclo/golint/license/ineffassign/mispell） 的结果；2. 测试覆盖率（coveralls，或者 gocover）。</p><p>第 36 篇，17 年 6 月份，那时我快毕业了。当年如日中天的 ofo 也早已经一地鸡毛，用户的押金也得到几百年之后才能还清。想起那时的创始人何等风光，如今安在？本问主要探讨密码锁的一些方案设计。</p><p>第 37 篇，关于 pprof 和火焰图的使用，嗯，曹大少有的教程类文章。这里有个如果涉及到 http handler 的压测，profile 的时候可以有技巧地把 Write/Read 的开销除开。</p><p>第 38 篇，公司都是要盈利的，都有自己的业务，业务驱动其实是常态，老板只关心有没有实现想要的功能，你如何实现，实现的代码质量如何这些并不重要，这也是现在你看到的公司的各种垃圾代码，这个问题也没法解。但对于个人而言，多看好的开源代码、多看《重构》这样书，以及使用 test 等方法能一定程度上解决问题。</p><p>第 39 篇，一个比较常见的问题，之前我也写过一篇<a href="https://qcrao.com/2020/04/27/codec-accident/">类似的</a>，当时我用的一个主要工具就是：<code>perf top</code>。</p><p>第 40 篇，回顾从 07 年入校以来的点滴，真情流露。曹大多才多艺！</p><p>第 41 篇，先是场景引入（今天刚好看到 caoz 讲的如何做分享），再层层递进。得出如果在内存中计算交集的一个方法：map[int]int。</p><p>第 42 篇，讨论阿里的一个开源库 ApsaraCache（类 redis） 所做的优化是如何实现的。主要有两点：增加对 MemCache 的支持；优化短链接。</p><p>第 43 篇，举了两个 Go 语言中 panic 无法被用户 recover 的情况：并发 map 读写；reflect.Call。结论：go 服务不用 supervisor 又不加监控就等着被开除吧。哈哈哈~</p><p>第 44 篇和第 45 篇是关于《Clean Architecture》的读书笔记，摘一句：对于商业公司的金主来说，软件系统有两方面的价值，一方面是软件的行为价值，也就是指软件的业务功能；另一方面是软件的结构，指软件的架构，易变性，可维护性，属于软性价值。软件工程师的职责是保证系统两方面的价值都能够达到最大。但是实际情况是，大多数人就只会聚焦在某一个方面，顾此失彼。</p><p>第 46 篇，宣告《Go 语言高级编程》正在搞，而且会继续搞完。周末写完了 router 一节。</p><p>第 47 篇，讨论了部门内的一个不均衡的负载均衡算法。数学证明的部分没太看懂~</p><p>第 48 篇，除了拿 debugger 来 debug。还可以用 debugger 来了解了解程序运行的机制，或者用 disass 来查看程序运行的汇编码。在查资料的时候，看到鸟窝写的<a href="https://colobu.com/2018/03/12/Debugging-Go-Code-with-LLDB/" target="_blank" rel="noopener">文章</a>：最近看到滴滴的工程师分享的使用debugger在调试Go程序，我觉得有必要在尝试一下这方面的技术了。估计说的就是曹大这篇。</p><blockquote><p>gc 编译器产生的代码可能会包含内联的优化，这不方便调试器调试，为了禁止内联， 你可以使用 -gcflags “-N -l” 参数。</p></blockquote><p>我跟着这篇讲 lldb 调试的<a href="https://www.zddhub.com/memo/2015/12/20/lldb-golang-debug.html" target="_blank" rel="noopener">文章</a>走了一遍调试。设置断点有点问题，没完事做完。</p><p>这篇文章里还介绍了 dlv 的功能。由于好久没用到这些工具，暂时先不深入了。</p><p>第 49 篇，是对业务系统的接口上的思考，从功能上来说，可以抽象成 SQL。但实现起来，并且对用户友好，可能并没有那么简单。最后结论：支持什么 SQL/GraphQL 啊，thrift 大法好。</p><p>第 50 篇，这又是一篇译文（还是挺多的，所以这也是一种学习方法），关于 Go 汇编的。后来曹大在 Go 夜读上的 Go 汇编分享，这篇文章亦有贡献。</p><p>第 51 篇，关于协作式和非协作式抢占调度的特点以及关系。Go 实际上在 1.14 才真正实现了抢占式调度，使得 for 无限循环在 GC 的时候不会阻塞整个进程的执行，从而“卡死”。</p><p>第 52 篇，曹大开始进行源码阅读了，记住这个时间：2018-04-05。这篇文章开始会简单展示核心的关于 channel 的代码，包括读、写、关闭等，后面就主要是源码注释了。学到了一个在线的 markdown 编辑工具，好处是可以和 dropbox、github 绑定。</p><p>第 53 篇，启动流程分析。由于之前我已经追求一遍相关代码，不深入研究。</p><p>第 54 篇和第 50 篇来源于同一个 github 项目，但作者已经跑路了。文章是比较硬核的，作者的研究方法是从 binary asm 反推实现原理。</p><p>第 55 篇，这是曹大在 Go 夜读上所做分享的原文，牛逼。领先我们好几年。</p><p>第 56 篇，思考业务系统中的问题及解法。讨论的问题是如何收集、计算主业务流程相关的指标。开头由 DDIA 一书引入话题，然后说明场景，再谈解决办法，然后说问题，再来说方法……从这里也可以看到，曹大在 18 年就已经看完了 DDIA。我则是今年才开始看这本书，差距。</p><p>第 57 篇，G 和 P 的状态流转图，用的是“自动”生成的。相比我之前手动画的，改起来也比较容易。</p><p>第 58 篇，什么 TDD，BDD，DDD 都是浮云，事故驱动开发才是王道。不出事故，一切都好说，管你什么代码质量，有什么用？出事故，那马上得复盘、甚至罚款。结尾列出的三个案例也是值得好好看，尤其是尽可能要用 defer。</p><p>第 59 篇，喜大普奔，从 hexo 升级到 ghost，且升级了 gitalk 评论系统，直接和 github 打通。</p><p>第 60 篇，讲的《Concurrency In Go》里的一个活锁的例子，原因是没有协调好加锁的顺序，且使用的是 tryLock 的这种形式，即没有加锁成功，就先返回失败，再尝试。当然，如果不是 trylock 的话，不一致的加锁顺序会直接导致死锁。</p><blockquote><p>如果已经发现了活锁导致的问题，解决手段很简单，只要规定好加锁顺序，并且大家都按同样的顺序去加锁就可以了。活锁比较麻烦的是难以发现，因为在活锁状态下的程序实际上看起来很正常，只是性能表现会稍微差一些。</p></blockquote><p>另外，不得不说一句，我是今年才看的这本书。差距啊！</p><p>第 61 篇，毕业四年，列出的计划单，非常叼。我印象比较深刻的有：有个人的稳定的科学查资料方案，改天有机会当面请教一下。</p><p>第 62 篇，调度器的源码分析，由于我已经写过相关文章，不深入看，略过。</p><p>第 63 篇，《Concurrency In Go》的读书笔记，恰好我几个月前也写了一篇类似的读书笔记。不同的是，曹大这篇，代码样例为主，我的则以理解为主，代码样例则基本没有。</p><p>这有张操作 channel 的结果对照表，可以一用：</p><p><img src="https://user-images.githubusercontent.com/7698088/102634497-dfbf1180-418c-11eb-9b1f-e643df89f79c.png" alt="channel op"></p><p>第 64 篇，timer 源码分析，不深入看。</p><p>第 65 篇，syscall 原理，以后需要的时候再来仔细研究。</p><p>第 66 篇，列举了一些英文书的出版社。如 O’Reilly，NoStarch，Manning，Apress，packt，最近我也看了 packt 出版社的《Distributed Computing With Go》，当然也是跟着曹大的书单读的。嗯，落后了 2 年。</p><p>第 67 篇，map 的源码分析，当初我写《深度解密 Go 语言之 map》时，参考了不少。</p><p>第 68 篇，select 源码分析。</p><p>第 69 篇，slice 源码分析。</p><p>第 70 篇，报告阶段性胜利，《Go 语言高级编程》初稿完成。曹大写的是关于 Go Web 的部分，字里行间可以看出他花了大力气进行总结：对于个人来说，通过这本书，把所有 web 领域相关的知识全部进行了梳理和总结(虽然有些还没有写)。可以比较自信地认为在 web 开发方面，本人已经没有任何方面的盲点和短板。要说问题，那可能也就是业务领域相关的问题了。</p><p>第 71 篇，业务遇到的问题，最终查到是 Go 语言自身的一个 bug：循环中的指针变量做 map 的 key 使用，会在 GC 时触发该 bug。在 1.9.2 上是必现的。</p><p>第 72 篇，sync 包源码分析，以后再看。</p><p>第 73 篇，semaphore 源码分析，以后再看。</p><p>2018 年的文章完了，这一年，曹大主攻 Go 语言，完成了 golang-notes，并且完成了《Go 语言高级编程》。</p><p>第 74 篇，《中台的末路》，去年在公众号“码农桃花源”上发出后，全网疯转，仅“码农桃花源”上就达到 7w+ 阅读，其他公众号、平台的阅读数就更不知多少了。</p><p>第 75 篇，又是列举了几个实际工作中碰到了案例，一个开源库对 sync.Pool 的使用，和实际场景中对开源的使用并没有发挥 sync.Pool 的作用，且在高并发场景下导致了锁竞争；第 2 个例子是 metrics 上报也会遇到锁竞争；第 3 个例子是打日志。得出结论：不可能通过看源码就能看出问题，早做压测保平安。</p><blockquote><p>上面说的几个问题实际上本质都是并发场景下的 lock contention 问题，全局写锁是高并发场景下的性能杀手，一旦大量的 Goroutine 阻塞在写锁上，会导致系统的延迟飚升，直至接口超时。在开发系统时，涉及到 sync.Pool、单个 FD 的信息上报、以及写日志的场景时，应该多加注意。早做压测保平安。</p></blockquote><p>第 76 篇，ghost 支持了mermaid。</p><p>第 77 篇，年终总结和年初计划。这里看到了曹大和欧神的互动，名场面。</p><p><img src="https://user-images.githubusercontent.com/7698088/102680763-49273a80-41f6-11eb-9a05-93a20a7a2f66.png" alt="国外的兄弟"></p><p><img src="https://user-images.githubusercontent.com/7698088/102680794-afac5880-41f6-11eb-802c-96d11c3c76df.png" alt="大佬之间的交流"></p><p>第 78 篇，从功能上来讲，规则引擎的基本就是一个 bool 表达式的解析和求值过程。可以直接使用 Go 的内置 parser 库完成上面一个基本规则引擎的框架。</p><p>第 79 篇，主要内容应该是曹大之前竞选 Gopher China 讲师时准备的。又是根据实际业务系统的一次精彩总结，希望以后自己也能写这样的东西。即使不能公开，也能私下总结一下。</p><p>第 80 篇，流式计算中的分布式快照的算法介绍，看不太懂。主要内容是最早的一篇论文及之后 FaceBook 出的一篇新论文的介绍。</p><p>第 81 篇，从这篇开始，是一个序列专门讲微服务相关的内容，比较精彩。本文主要是说通用语言的问题，比如高层讲战略用的是中文，但底层程序员用的是英文，这中间有一个翻译导致的信息差。这在微服务上是很难解决的，例如对快车的翻译在不同的系统中叫法是不一样的。</p><blockquote><p>上面提到的 fastcar 出现在我们系统提供给别人所用的 api 的关键字段中，quickcar 出现在我们内部数据库的字段名中，kuaiche 出现在异步发送的消息中。</p></blockquote><p>但我的现公司其实用的是统一的一个 idl 库，可以解决很多问题。</p><p>第 82 篇，继续说微服务的问题，进行拆分之后，各个小模块理论上可以用最适合的语言去实现，但这就造成了技术栈不统一的一些毛病，例如同一个 client 需要用各种不同的语言来实现，当遇到组织架构变动的时候，接手都很麻烦。B 站是很早就统一了技术栈的。</p><p>第 83 篇，新增功能时，可能同时需要改很多模块，从设计原则上来讲，逻辑上相同或者类似的代码应该放在一个地方来实现。这个稍微学过一点 SOLID 中的 SRP 原则就应该知道。这样可以避免逻辑本身过于分散，好处是：“一个类(模块)只会因为一个理由而发生变化”，其实就是相同的需求，尽量能够控制在单模块内完成。但职场上很多人并不是这么考虑的，做这件事是否有收益是第一要务。</p><p>第 84 篇，业界有个名词叫 dependency hell，指的是软件系统因依赖过多，或依赖无法满足时会导致软件无法运行。服务之间的循环依赖也有很多。程序员在当前的微服务架构下，将持续地被外部的垃圾 SDK 和各种莫名其妙的依赖问题所困。</p><p>第 85 篇，拆分成微服务后，一致性是个大问题。大多数公司的架构师嘴里的最终一致，依靠的都是人肉而非技术。</p><p>第 86 篇，现实中总要考虑上“政治”因素，推动事情并不容易，尤其是跨部门的协作。</p><blockquote><p>如果一个公司的组织架构已经基本成型了，那么基本上设计出的系统架构和其人员组织架构必然是一致的。</p></blockquote><blockquote><p>之前和同事一起得到了一个在大公司内推进事情的靠谱结论，如果一件事情在一个部门内就可以解决，那可以开开心心地推动它解决。如果一件事情需要跨部门，那还需要本部门的大领导出面才能解决，哪怕这事情再小。如果一件事情需要跨两个部门，那就没治了，谁出面都不行。这种事情做不了的。而如果一件事情和你要跨的部门 KPI 有冲突，那就更别想了，把部门重组了才能解决，这是 CTO 才能干的事情。</p></blockquote><p>第 87 篇，一篇回答知乎上“有哪些优秀的 Go 面试题”的答案。当初第一次看文章的时候，很多不懂，现在看很多地方懂了。</p><p>第 88 篇和 89 篇是参与 tidb talent-plan 的题解。前者是一个 merge_sort，后者是 map-reduce。</p><p>第 90 篇，尝试对接入做到完全配置化，从 SQL 语句得到启发，通过定义的元组来描述外部的数据、内部的存储。其实我没太懂，以后再研究下。</p><p>第 91 篇，讲了 Go 1.13 在 defer 上的一些优化。主要在某些情况下，可以用 deferprocStack 来代替以前的从堆上分配资源，提升性能。</p><p>第 92 篇，探索一个案例代码的优化过程。起因是看到群里有人问的一个含有 dead code 的样例代码是如何优化的，然后使用 <code>GOSSAFUNC=main go build com.go</code> 看了下优化过程。结论是：优化是在编译器后端做的。关于后端的优化过程，这里有一个欧神开发的在线小工具，可以很方便的查看：<a href="https://golang.design/gossa%E3%80%82" target="_blank" rel="noopener">https://golang.design/gossa。</a></p><blockquote><p>从词法分析到语法分析一般被称为编译器的前端(frontend)，而中间代码生成和目标代码生成则是编译器后端(backend)。</p></blockquote><p>第 93 篇，某团圆节（应该是中秋节吧）线上发上的真实案例，不是事故：下游系统抖动了，超时，很多 g 挂在 gopark 上，没法复用；只能创建更多的 g，这些 g 会被 append 进 allgs 数组，在 sysmon/GC 等时机会扫描 allgs；即使下游恢复了，allgs 数组也不会收缩，使得 CPU 消耗变大。只能通过重启恢复。</p><p>第 94 篇，博客用 caddy2 上 https，看着导航栏左边的小绿锁，更开心了。</p><p>第 95 篇，一个小的程序代码，只用 Rlock 的时候竟然“发现”有锁冲突，不可思议，经过排查发现：大量的 g 调度下，在 g 的执行过程中如果有调用任意的会切换 g 调度的情况下，下次回到调度该 g 的时间无法保证。还是挺有意思的。</p><p>第 96 篇，依赖反转原则，在很多地方都被人用不同的名词说过。名词不同，但本质相同。</p><p>第 97 篇，讲 ACL 的一些问题，不太能 Get 到精髓。</p><p>第 98 篇，MQ 的数据生产方、消费方、MQ 的维护者，三方各怀鬼胎，真正关心 MQ 数据的只有整个消息流的末端团队，但他控制不了生产者。很多事故的发生都是因为生产者重构导致发出有问题的消息。本问提出了 2 种可能的数据检验方案。</p><p>2019 年的文章看完了。这一年，曹大比较关注工程领域，微服务方面有不少输出。另外，排查了很多线上 Go 相关的问题。上一年读完源码，这一年就大展身手了。</p><p>第 99 篇，2020 年第一篇，是一道知乎上的题目，有些地方可能还会拿来做面试题，但其实只要运行一下就知道答案。再看看逃逸分析、SSA 优化就可以知道为什么了。文章最后一句，送给面试官：<strong>要是哪位工程师拿这个去做面试题，那就太缺德啦！</strong></p><p>第 100 篇，线上的一个 panic case，偶现。最终排查的原因是 waitgroup 使用不当，造成并发读写 map，程序崩溃。文章里写一开始系统负责人声称一定是离职员工的锅，连代码都不愿意看。但曹大三下五除二，就还原了事实真相。</p><p>第 101 篇，举了一个打日志也可能造成锁竞争的例子，原因是最后都会加锁：fd.writeLock()。</p><blockquote><p>如果提前有一些预见性，做好针对性压测，那就不会让你的用户在关键时刻靠重启续命了。</p></blockquote><p>第 102 篇，主要讲了切片截取会导致内存泄露，并给出了相关的例子。</p><p>第 103 篇，《工程师应该怎么学习》，推荐所有的技术人都看看，我前前后后看了很多遍。据说是曹大跑路的时候发到内网上的。写得很赞，看书、看英文书、看博客、读论文、实践、总结、写博客、独立思考、代码库、笔记库、演讲能力，哪一个都值得我们认真学习、实战。</p><blockquote><p>你所要做的是提前做好准备，在那一天到来的时候，在聚光灯下旁征博引，谈笑风生。</p></blockquote><p>第 104 篇，内行的吐槽更为致命。因转到蚂蚁搞 mosn，这里就是过程中遇到的 go mod 的依赖问题，最后通过 replace 解决。</p><p>第 105 篇，因为 Go 错误处理的原因，提高 Go 项目的测试覆盖率其实比较难。</p><p>第 106 篇，又是一篇犀利的吐槽。架构师不常见，天下系统都一样。言必谈 DDD，中台，战略，一到了落地环节提不出合理的见解和建议。对于个人来说，脚踏实地，打好基础，从解决实际问题开始。</p><p>第 107 篇，首先用压测工具 wrk fasthttp，标准库，rust 写的 hello 程序，发现 fasthttp 几乎和 rust 一样快。fasthttp 快的原因：goroutine workerpool，对创建的 goroutine 进行了重用；在整个 serve 流程中，几乎所有对象全部都进行了重用。当然，因为 ctx 的重用，某些场景下会掉坑。</p><p>第 108 篇，介绍了一些 golang linter，以及怎么集成到代码 CR 的流程中。</p><blockquote><p>所以如果你在维护有节操的开源项目的话，可以考虑给你的项目加个 github action 了，试用下来，感觉 reviewdog 是最简单直观的。</p></blockquote><p>第 109 篇，分析了一些常见组件的连接池的具体实现。包括：http 标准库、http2、fasthttp、gRPC、thrift、redigo、go-redis/redis、database/sql。</p><p>第 110 篇，Go context 的源码实现分析。</p><p>第 111 篇，Go 如何实现自动抓取 profile，快速定位问题。这篇介绍了实现原理。</p><p>第 112 篇，如何 patch 私有函数，原理+代码实现，非常过瘾。主要原理就是找到原私有函数的代码位置，将前面的数个字节用一段跳转指令覆盖，这样就能实现“劫持”，跳转到目标函数。真牛逼。</p><p>在 mac 上跑的时候，函数名有一小点不同，修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := generateFuncName2PtrDict()</span><br><span class="line"></span><br><span class="line">heiheiPrivate()</span><br><span class="line">origin := replaceFunction(m[<span class="string">"main.heiheiPrivate"</span>], (<span class="keyword">uintptr</span>)(getPtr(reflect.ValueOf(Replace))))</span><br><span class="line">heiheiPrivate()</span><br><span class="line">copyToLocation(m[<span class="string">"main.heiheiPrivate"</span>], origin)</span><br><span class="line">heiheiPrivate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“劫持”完之后，再“恢复现场”，再次调用 <code>heiheiPrivate()</code>，又恢复原样。妙啊！</p><p>第 113 篇，介绍了 LockOSThread 的奇技淫巧，它可以“杀”死线程：在退出的时候和当前 g 绑定的线程就会直接销毁。</p><p>第 114 篇，曹大看的 youtube 上的一个吐槽微服务的视频的总结笔记，很有曹大的风格，花式吐槽。</p><p>第 115 篇，自动 dump 的实现及样例说明。这是 mosn 上的一个开源项目，有了这个项目，绩效稳了。</p><p>第 116 篇，一篇 2013 年 Google 对 packetdrill 的论文翻译。看不太懂，先跳过，以后有用到的时候再来看。</p><p>第 117 篇，介绍了一个 Google 的 subset 算法解决微服务场景下连接数量的问题。</p><p>第 118 篇，详细解释 Go 1.14 中 defer 的优化。</p><hr><table><thead><tr><th>序号</th><th>时间</th><th>题目</th><th>内容</th></tr></thead><tbody><tr><td>1</td><td>2015-10-13</td><td><a href="https://xargin.com/configure-of-lnmp-developmenft-env/" target="_blank" rel="noopener">从零搭建 lnmp 环境</a></td><td>介绍如何使用 vagrant 搭建开发 lnmp 环境</td></tr><tr><td>2</td><td>2015-11-01</td><td><a href="https://xargin.com/consistent-hash/" target="_blank" rel="noopener">一致性哈希详解</a></td><td>介绍一致性哈希原理</td></tr><tr><td>3</td><td>2015-11-05</td><td><a href="https://xargin.com/use-solr-to-index-mysql-data/" target="_blank" rel="noopener">Solr 5.3.1索引MySQL数据配置流程</a></td><td>一篇实战教程</td></tr><tr><td>4</td><td>2015-11-13</td><td><a href="https://xargin.com/es-river-1/" target="_blank" rel="noopener">Elasticsearch环境搭建和river数据导入</a></td><td>一篇实战教程，把 Solr 换成 ES 2.0 了</td></tr><tr><td>5</td><td>2015-11-15</td><td><a href="https://xargin.com/about-microservice-1/" target="_blank" rel="noopener">漫谈服务化、微服务(一)</a></td><td>PHP 怎么做服务间调用</td></tr><tr><td>6</td><td>2015-11-16</td><td><a href="https://xargin.com/es-river-2/" target="_blank" rel="noopener">Elasticsearch环境搭建和river数据导入（二）</a></td><td>接着第 4 篇，如何解决导入大表数据时虚拟机卡住的问题</td></tr><tr><td>7</td><td>2020-11-28</td><td><a href="https://xargin.com/about-optimistic-locking/" target="_blank" rel="noopener">关于乐观锁</a></td><td>乐观锁，是一种写入、更新数据库时的逻辑特性</td></tr><tr><td>8</td><td>2020-11-30</td><td><a href="https://xargin.com/redis-transaction/" target="_blank" rel="noopener">[译]Redis事务详解</a></td><td>官方 Transactions 小节的文档翻译</td></tr><tr><td>9</td><td>2016-01-10</td><td><a href="https://xargin.com/es-river-3/" target="_blank" rel="noopener">Elasticsearch环境搭建和river数据导入（三）</a></td><td>因为 MySQL 主从延迟导致的丢数据问题的解决</td></tr><tr><td>10</td><td>2016-02-01</td><td><a href="https://xargin.com/consistent-hash-2/" target="_blank" rel="noopener">一致性哈希-虚拟结点生成</a></td><td>介绍了 groupcache 和 memcached 如何生成虚拟节点</td></tr><tr><td>11</td><td>2016-03-05</td><td><a href="https://xargin.com/elasticsearchfu-service-summary/" target="_blank" rel="noopener">elasticsearch服务开发总结</a></td><td>开发过程中遇到的问题及解决</td></tr><tr><td>12</td><td>2016-03-09</td><td><a href="https://xargin.com/es-river-4/" target="_blank" rel="noopener">Elasticsearch环境搭建和river数据导入（四）</a></td><td>估计是 ES 最后一篇总结了</td></tr><tr><td>13</td><td>2016-04-11</td><td><a href="https://xargin.com/middleware-and-pipeline/" target="_blank" rel="noopener">中间件与责任链模式</a></td><td>laravel 框架里的一个实现</td></tr><tr><td>14</td><td>2016-06-26</td><td><a href="https://xargin.com/about-beanstalkd/" target="_blank" rel="noopener">beanstalkd 源码剖析</a></td><td>一个用 C 写的消息队列源码分析</td></tr><tr><td>15</td><td>2016-08-09</td><td><a href="https://xargin.com/about-gated-launch/" target="_blank" rel="noopener">关于灰度发布</a></td><td>灰度发布的一些概念和实践</td></tr><tr><td>16</td><td>2016-08-10</td><td><a href="https://xargin.com/some-things-about-es/" target="_blank" rel="noopener">谈一谈es的优势和限制</a></td><td>从数据库、检索服务、日志三个方面来谈 ES 能做的事，以及优势和限制</td></tr><tr><td>17</td><td>2016-08-28</td><td><a href="https://xargin.com/use-sql-to-query-elasticsearch/" target="_blank" rel="noopener">使用sql来查询es</a></td><td>开发了一个 elasticsql 项目，可以用 SQL 来查 ES</td></tr><tr><td>18</td><td>2016-10-14</td><td><a href="https://xargin.com/about-thunder/" target="_blank" rel="noopener">关于迅雷</a></td><td>简要介绍迅雷下载的原理</td></tr><tr><td>19</td><td>2016-10-23</td><td><a href="https://xargin.com/rookie-programmer-faults/" target="_blank" rel="noopener">初级程序员常犯错误一览</a></td><td>列举“初级”程序员的做法，共勉~</td></tr><tr><td>20</td><td>2016-11-06</td><td><a href="https://xargin.com/es-stack-upgrade-to-5/" target="_blank" rel="noopener">es stack升级5.0了</a></td><td>把 logstash/kibana/elasticsearch 之类的东西统统变成 5.0</td></tr><tr><td>21</td><td>2016-11-12</td><td><a href="https://xargin.com/about-token/" target="_blank" rel="noopener">关于我们每天都在用的token</a></td><td>公司登陆验证用的 Google Authenticator 来做校验的原理</td></tr><tr><td>22</td><td>2016-12-09</td><td><a href="https://xargin.com/backend-engineer-interview/" target="_blank" rel="noopener">后端程序员面试题</a></td><td>翻译的一个后 GitHub 上的后端面试项目，并给出一些问题的回答</td></tr><tr><td>23</td><td>2016-12-16</td><td><a href="https://xargin.com/middleware/" target="_blank" rel="noopener">重新探讨middleware</a></td><td>Go web 中间件如何写</td></tr><tr><td>24</td><td>2016-12-22</td><td><a href="https://xargin.com/kafka-0-9-debug/" target="_blank" rel="noopener">一次kafka 0.9的重复消费问题排查</a></td><td>仅通过读文档将发现了问题</td></tr><tr><td>25</td><td>2016-12-25</td><td><a href="https://xargin.com/how-to-debug-with-lower-programmer/" target="_blank" rel="noopener">如何与低水平web开发联调</a></td><td>吐槽和低水平前端联调的事，并给出了应付的办法</td></tr><tr><td>26</td><td>2016-12-26</td><td><a href="https://xargin.com/is-sds-really-binary-safe/" target="_blank" rel="noopener">sds与二进制安全</a></td><td>redis set 命令是否是二进制安全的实验</td></tr><tr><td>27</td><td>2017-01-24</td><td><a href="https://xargin.com/redis-protocal/" target="_blank" rel="noopener">[译]redis通信协议</a></td><td>一篇 redis client 和 server 的通信协议</td></tr><tr><td>28</td><td>2017-02-19</td><td><a href="https://xargin.com/weekend/" target="_blank" rel="noopener">周末</a></td><td>听 B 站分享的一个总结</td></tr><tr><td>29</td><td>2017-03-11</td><td><a href="https://xargin.com/kafka-replication-translation/" target="_blank" rel="noopener">[译]Kafka Replication</a></td><td>一篇 Kafka 消息 Replication 的原理的译文</td></tr><tr><td>30</td><td>2017-03-30</td><td><a href="https://xargin.com/error-design/" target="_blank" rel="noopener">业务系统错误设计</a></td><td>从用户和研发的角度，来看业务系统如何处理错误的一些思考</td></tr><tr><td>31</td><td>2017-04-25</td><td><a href="https://xargin.com/about-package-and-go/" target="_blank" rel="noopener">关于go的包管理</a></td><td>Go 包管理的一些问题，这时还是 GOPATH</td></tr><tr><td>32</td><td>2017-04-27</td><td><a href="https://xargin.com/distlock/" target="_blank" rel="noopener">分布式锁</a></td><td>从 MySQL 到 redis 再到 redlock</td></tr><tr><td>33</td><td>2017-05-10</td><td><a href="https://xargin.com/ast/" target="_blank" rel="noopener">golang 和 ast</a></td><td>直接用源码展示如何用 parser 生成 ast，以及实际应用</td></tr><tr><td>34</td><td>2017-05-20</td><td><a href="https://xargin.com/web-dao-generation/" target="_blank" rel="noopener">从 information_schema 到自动生成的 web dao</a></td><td>利用 information_schema 自动生成代码</td></tr><tr><td>35</td><td>2017-05-24</td><td><a href="https://xargin.com/how-to-meet-the-quality-standard-of-awesome-go/" target="_blank" rel="noopener">如何使你的 golang 项目达到 awesome go 的入选标准</a></td><td>关注两点：goreport、测试覆盖率（coveralls，或者 gocover）</td></tr><tr><td>36</td><td>2017-06-20</td><td><a href="https://xargin.com/about-ofo/" target="_blank" rel="noopener">关于 ofo</a></td><td>关于 ofo 密码锁的一些方案设计</td></tr><tr><td>37</td><td>2017-07-11</td><td><a href="https://xargin.com/pprof-and-flamegraph/" target="_blank" rel="noopener">pprof 和火焰图</a></td><td>一篇实例教程</td></tr><tr><td>38</td><td>2017-06-21</td><td><a href="https://xargin.com/tech-battle/" target="_blank" rel="noopener">企业级应用与屎一样的代码</a></td><td>公司级的代码质量问题及一些解决办法</td></tr><tr><td>39</td><td>2017-08-31</td><td><a href="https://xargin.com/how-to-locate-for-block-in-golang/" target="_blank" rel="noopener">如何定位 golang 进程 hang 死的 bug</a></td><td>如何定位 Go 的协作式调度的一个 bug</td></tr><tr><td>40</td><td>2017-09-12</td><td><a href="https://xargin.com/ten-years/" target="_blank" rel="noopener">十周年</a></td><td>回顾本科、工作</td></tr><tr><td>41</td><td>2017-10-11</td><td><a href="https://xargin.com/intersection/" target="_blank" rel="noopener">从求交集开始</a></td><td>求交集的一个计法</td></tr><tr><td>42</td><td>2017-10-28</td><td><a href="https://xargin.com/apsaracache-diff-analysis/" target="_blank" rel="noopener">ApsaraCache 源码 diff 分析</a></td><td>分析优化如何实现</td></tr><tr><td>43</td><td>2017-11-30</td><td><a href="https://xargin.com/recover-is-not-perfect/" target="_blank" rel="noopener">recover 并不是无懈可击的</a></td><td>有些情况下加 recover 也没用，例如并发 map 读写</td></tr><tr><td>44</td><td>2017-12-28</td><td><a href="https://xargin.com/clean-architecture-1/" target="_blank" rel="noopener">clean architecture(上)</a></td><td>《Clean Architecture》读书笔记 1</td></tr><tr><td>45</td><td>2017-12-30</td><td><a href="https://xargin.com/clean-architecture-2/" target="_blank" rel="noopener">clean architecture(下)</a></td><td>《Clean Architecture》读书笔记 2</td></tr><tr><td>46</td><td>2018-01-07</td><td><a href="https://xargin.com/about-open-src-book/" target="_blank" rel="noopener">开源书</a></td><td>宣告一下，《Go 语言》高级编程还在搞，而且会搞完</td></tr><tr><td>47</td><td>2018-01-22</td><td><a href="https://xargin.com/load-balance/" target="_blank" rel="noopener">你的负载均衡真的均衡么？</a></td><td>实验+推理说明一个均衡算法并不均衡</td></tr><tr><td>48</td><td>2018-01-31</td><td><a href="https://xargin.com/debugger/" target="_blank" rel="noopener">使用 debugger 学习 golang</a></td><td>lldb 和 dlv 的功能和使用</td></tr><tr><td>49</td><td>2018-02-09</td><td><a href="https://xargin.com/use-sql-on-kv-store/" target="_blank" rel="noopener">如何在 kv 系统中支持简单的 SQL</a></td><td>对在线特征系统的接口的思考</td></tr><tr><td>50</td><td>2018-03-08</td><td><a href="https://xargin.com/go-and-plan9-asm/" target="_blank" rel="noopener">[译]go 和 plan9 汇编</a></td><td>一篇 Go 汇编的翻译</td></tr><tr><td>51</td><td>2018-03-30</td><td><a href="https://xargin.com/go-schedule/" target="_blank" rel="noopener">协作/非协作式抢占</a></td><td>宏观上描述两者的运行过程</td></tr><tr><td>52</td><td>2018-04-05</td><td><a href="https://xargin.com/channel-from-usage-to-src-analysis/" target="_blank" rel="noopener">Go 系列文章1：Channel 从使用到源码分析</a></td><td>channel 的使用及源码分析</td></tr><tr><td>53</td><td>2018-04-08</td><td><a href="https://xargin.com/go-bootstrap/" target="_blank" rel="noopener">Go 系列文章2：Go 程序的启动流程</a></td><td>Go 程序启动流程</td></tr><tr><td>54</td><td>2018-04-14</td><td><a href="https://xargin.com/go-and-interface/" target="_blank" rel="noopener">[译]Go 和 interface 探究</a></td><td>interface 如何组装等等</td></tr><tr><td>55</td><td>2018-04-22</td><td><a href="https://xargin.com/plan9-assembly/" target="_blank" rel="noopener">Go 系列文章3 ：plan9 汇编入门</a></td><td>Go 汇编相关，非常好</td></tr><tr><td>56</td><td>2018-05-01</td><td><a href="https://xargin.com/unreliable-replication-in-distributed-systems/" target="_blank" rel="noopener">分布式系统中的不可靠复制问题</a></td><td>业务指标如何收集、计算</td></tr><tr><td>57</td><td>2018-05-17</td><td><a href="https://xargin.com/state-of-goroutine/" target="_blank" rel="noopener">goroutine 的状态切换</a></td><td>整理的 G 和 P 的状态切换图</td></tr><tr><td>58</td><td>2018-06-09</td><td><a href="https://xargin.com/accident-driven-development/" target="_blank" rel="noopener">事故驱动开发</a></td><td>过于真实的互联网开发指南</td></tr><tr><td>59</td><td>2018-06-09</td><td><a href="https://xargin.com/blog-upgraded/" target="_blank" rel="noopener">blog 升级了。。</a></td><td>喜大普奔，博客升级</td></tr><tr><td>60</td><td>2018-06-09</td><td><a href="https://xargin.com/livelock/" target="_blank" rel="noopener">livelock</a></td><td>《Concurrency In Go》里的一个活锁的例子</td></tr><tr><td>61</td><td>2018-06-10</td><td><a href="https://xargin.com/2018-plan/" target="_blank" rel="noopener">2018 年的几个目标</a></td><td>年终总结</td></tr><tr><td>62</td><td>2018-06-17</td><td><a href="https://xargin.com/go-scheduler/" target="_blank" rel="noopener">Go 系列文章4 : 调度器</a></td><td>源码分析</td></tr><tr><td>63</td><td>2018-06-18</td><td><a href="https://xargin.com/concurrency-in-go-notes/" target="_blank" rel="noopener">concurrency in go 读书笔记</a></td><td>记录的一些代码样例</td></tr><tr><td>64</td><td>2018-06-23</td><td><a href="https://xargin.com/go-timer/" target="_blank" rel="noopener">Go 系列文章5 : 定时器</a></td><td>timer 源码分析</td></tr><tr><td>65</td><td>2018-06-28</td><td><a href="https://xargin.com/syscall/" target="_blank" rel="noopener">Go 系列文章6: syscall</a></td><td>syscall 原理</td></tr><tr><td>66</td><td>2018-07-04</td><td><a href="https://xargin.com/diss-packt/" target="_blank" rel="noopener">packt 出版的书吐槽</a></td><td>一些英文书的出版社</td></tr><tr><td>67</td><td>2018-07-07</td><td><a href="https://xargin.com/go-map/" target="_blank" rel="noopener">Go 系列文章 7: map</a></td><td>map 源码分析</td></tr><tr><td>68</td><td>2018-07-16</td><td><a href="https://xargin.com/go-select/" target="_blank" rel="noopener">Go 系列文章 8: select</a></td><td>select 源码分析</td></tr><tr><td>69</td><td>2018-08-31</td><td><a href="https://xargin.com/go-slice/" target="_blank" rel="noopener">Go 系列文章 9: slice</a></td><td>slice 源码分析</td></tr><tr><td>70</td><td>2018-09-01</td><td><a href="https://xargin.com/relax/" target="_blank" rel="noopener">松一口气</a></td><td>《Go 语言高级编程》初稿完成</td></tr><tr><td>71</td><td>2018-09-17</td><td><a href="https://xargin.com/go-bug/" target="_blank" rel="noopener">Go 1.9.2 的 bug</a></td><td>Go 语言自身的一个 bug 复现</td></tr><tr><td>72</td><td>2018-10-04</td><td><a href="https://xargin.com/go-sync/" target="_blank" rel="noopener">Go 系列文章 10: sync</a></td><td>sync 包源码分析</td></tr><tr><td>73</td><td>2018-11-24</td><td><a href="https://xargin.com/go-sema/" target="_blank" rel="noopener">Go 系列文章 11: semaphore</a></td><td>semaphore 源码分析</td></tr><tr><td>74</td><td>2019-01-01</td><td><a href="https://xargin.com/the-death-of-middleground/" target="_blank" rel="noopener">中台的末路</a></td><td>中台的困境</td></tr><tr><td>75</td><td>2019-01-06</td><td><a href="https://xargin.com/lock-contention-in-go/" target="_blank" rel="noopener">几个 Go 系统可能遇到的锁问题</a></td><td>几个锁相关的案例</td></tr><tr><td>76</td><td>2019-01-24</td><td><a href="https://xargin.com/support-mermaid-in-ghost-blog/" target="_blank" rel="noopener">在 ghost 中支持 mermaid</a></td><td>博客的优化</td></tr><tr><td>77</td><td>2019-02-06</td><td><a href="https://xargin.com/2018-summary-and-2019-plan/" target="_blank" rel="noopener">2018 总结 &amp;&amp; 2019 目标</a></td><td>年终总结和年初计划</td></tr><tr><td>78</td><td>2019-02-08</td><td><a href="https://xargin.com/rule-engine-on-go-parser/" target="_blank" rel="noopener">基于 Go 的内置 Parser 打造轻量级规则引擎</a></td><td>使用 parser 可以实现一套规则引擎</td></tr><tr><td>79</td><td>2019-04-13</td><td><a href="https://xargin.com/feature-system-dev/" target="_blank" rel="noopener">一套实时特征系统的迭代过程</a></td><td>真实的业务场景的迭代升级过程，非常精彩</td></tr><tr><td>80</td><td>2019-04-14</td><td><a href="https://xargin.com/distributed-snapshot-in-stream-sys/" target="_blank" rel="noopener">流式计算中的分布式快照</a></td><td>最早的一篇论文及之后 FaceBook 出的一篇新论文的介绍</td></tr><tr><td>81</td><td>2019-05-01</td><td><a href="https://xargin.com/disaster-of-microservice-ul/" target="_blank" rel="noopener">微服务的灾难-通用语言</a></td><td>通用语言的问题，很难重构解决</td></tr><tr><td>82</td><td>2019-05-01</td><td><a href="https://xargin.com/disaster-of-microservice-techstack/" target="_blank" rel="noopener">微服务的灾难-技术栈</a></td><td>技术栈不统一也是有问题的</td></tr><tr><td>83</td><td>2019-05-02</td><td><a href="https://xargin.com/disaster-of-microservice-divide/" target="_blank" rel="noopener">微服务的灾难-拆分</a></td><td>依赖设计原则划分责任是不太可能的</td></tr><tr><td>84</td><td>2019-05-02</td><td><a href="https://xargin.com/disaster-of-microservice-dephell/" target="_blank" rel="noopener">微服务的灾难-依赖地狱</a></td><td>依赖过多、多重依赖、依赖冲突、依赖循环</td></tr><tr><td>85</td><td>2019-05-03</td><td><a href="https://xargin.com/disaster-of-microservice-evconst/" target="_blank" rel="noopener">微服务的灾难-最终一致</a></td><td>人肉最终一致</td></tr><tr><td>86</td><td>2019-05-03</td><td><a href="https://xargin.com/disaster-of-microservice-conway-law/" target="_blank" rel="noopener">微服务的灾难-康威定律和 KPI 冲突</a></td><td>除了组织架构的问题，还需要考虑 KPI 的问题</td></tr><tr><td>87</td><td>2019-05-11</td><td><a href="https://xargin.com/answers-for-some-interview-questions/" target="_blank" rel="noopener">一些问题的答案</a></td><td>一篇知乎回答</td></tr><tr><td>88</td><td>2019-05-11</td><td><a href="https://xargin.com/talent-plan-week1-solution/" target="_blank" rel="noopener">talent-plan tidb 部分个人题解-week 1</a></td><td>tidb 题解 1</td></tr><tr><td>89</td><td>2019-05-11</td><td><a href="https://xargin.com/talent-plan-week2-solution/" target="_blank" rel="noopener">talent-plan tidb 部分个人题解-week 2</a></td><td>tidb 题解 2</td></tr><tr><td>90</td><td>2019-08-31</td><td><a href="https://xargin.com/integrate-downstream-data-system-all-in-one/" target="_blank" rel="noopener">一劳永逸接入所有下游数据系统</a></td><td>接入做到完全配置化</td></tr><tr><td>91</td><td>2019-09-04</td><td><a href="https://xargin.com/go-1-13-defer-change/" target="_blank" rel="noopener">Go 1.13 defer 的变化</a></td><td>用 deferprocStack 提升性能</td></tr><tr><td>92</td><td>2019-09-22</td><td><a href="https://xargin.com/go-compiler-opt/" target="_blank" rel="noopener">查看 Go 的代码优化过程</a></td><td>探索一个样例代码的优化过程</td></tr><tr><td>93</td><td>2019-09-22</td><td><a href="https://xargin.com/cpu-idle-cannot-recover-after-peak-load/" target="_blank" rel="noopener">为什么 Go 模块在下游服务抖动恢复后，CPU 占用无法恢复</a></td><td>线上发生的真实案例</td></tr><tr><td>94</td><td>2019-10-04</td><td><a href="https://xargin.com/migrate-from-nginx-to-caddy/" target="_blank" rel="noopener">从 nginx 切换到 caddy</a></td><td>博客系统用 caddy2 上 https</td></tr><tr><td>95</td><td>2019-10-13</td><td><a href="https://xargin.com/a-rlock-story/" target="_blank" rel="noopener">一个和 RLock 有关的小故事</a></td><td>如何用 trace 查案</td></tr><tr><td>96</td><td>2019-10-20</td><td><a href="https://xargin.com/about-dip/" target="_blank" rel="noopener">依赖反转相关</a></td><td>很多不同的概念，但本质是一个东西</td></tr><tr><td>97</td><td>2019-11-02</td><td><a href="https://xargin.com/acl-and-matryoshka/" target="_blank" rel="noopener">ACL 和俄罗斯套娃</a></td><td>ACL 的一些问题</td></tr><tr><td>98</td><td>2019-11-24</td><td><a href="https://xargin.com/mq-is-becoming-sewer/" target="_blank" rel="noopener">MQ 正在变成臭水沟</a></td><td>MQ 的问题以及提出数据检验方案</td></tr><tr><td>99</td><td>2020-01-06</td><td><a href="https://xargin.com/addr-of-empty-struct-may-not-eq/" target="_blank" rel="noopener">一个空 struct 的“坑”</a></td><td>如何看穿一些弱智面试题</td></tr><tr><td>100</td><td>2020-01-09</td><td><a href="https://xargin.com/map-concurrent-throw/" target="_blank" rel="noopener">map 并发崩溃一例</a></td><td>waitgroup 使用不当造成的并发读写 context，导致 panic</td></tr><tr><td>101</td><td>2020-01-13</td><td><a href="https://xargin.com/born-from-nb-die-in-log/" target="_blank" rel="noopener">生于非阻塞，死于日志</a></td><td>写日志也可能会导致锁竞争</td></tr><tr><td>102</td><td>2020-01-19</td><td><a href="https://xargin.com/logic-of-slice-memory-leak/" target="_blank" rel="noopener">slice 类型内存泄露的逻辑</a></td><td>切片截取会导致内存泄露</td></tr><tr><td>103</td><td>2020-01-26</td><td><a href="https://xargin.com/how-to-learn/" target="_blank" rel="noopener">工程师应该怎么学习</a></td><td>终生学习，成为更好的自己</td></tr><tr><td>104</td><td>2020-04-19</td><td><a href="https://xargin.com/go-mod-is-rubbish/" target="_blank" rel="noopener">go mod 的智障版本选择</a></td><td>Go mod 的问题</td></tr><tr><td>105</td><td>2020-05-01</td><td><a href="https://xargin.com/its-hard-to-improve-go-proj-coverage/" target="_blank" rel="noopener">为什么提升 Go 项目的测试覆盖率有点难</a></td><td>因为 Go 的错误处理</td></tr><tr><td>106</td><td>2020-06-06</td><td><a href="https://xargin.com/every-arch-will-finally-become-shit/" target="_blank" rel="noopener">架构的腐化是必然的</a></td><td>业务驱动下，能上升的不是系统做的好的，而是堆业务的</td></tr><tr><td>107</td><td>2020-06-14</td><td><a href="https://xargin.com/why-fasthttp-is-fast-and-the-cost-of-it/" target="_blank" rel="noopener">fasthttp 快在哪里</a></td><td>fasthttp 快的原因是几乎所有对象全部都进行了重用</td></tr><tr><td>108</td><td>2020-07-06</td><td><a href="https://xargin.com/add-reviewdog-for-your-project/" target="_blank" rel="noopener">reviewdog</a></td><td>如何在提 RP 的时候，检测代码质量</td></tr><tr><td>109</td><td>2020-07-11</td><td><a href="https://xargin.com/some-connection-pool/" target="_blank" rel="noopener">一些连接池相关的总结</a></td><td>常用组件的连接池实现</td></tr><tr><td>110</td><td>2020-07-11</td><td><a href="https://xargin.com/go-context/" target="_blank" rel="noopener">Go context</a></td><td>Go context 源码分析</td></tr><tr><td>111</td><td>2020-08-13</td><td><a href="https://xargin.com/autodumper-for-go/" target="_blank" rel="noopener">无人值守的自动 dump(一)</a></td><td>自动抓取 profile</td></tr><tr><td>112</td><td>2020-09-04</td><td><a href="https://xargin.com/patching-private-function-in-go/" target="_blank" rel="noopener">在 Go 语言中 Patch 非导出函数</a></td><td>如何 patch 私有函数，原理加代码实现</td></tr><tr><td>113</td><td>2020-09-18</td><td><a href="https://xargin.com/shrink-go-threads/" target="_blank" rel="noopener">极端情况下收缩 Go 的线程数</a></td><td>LockOSThread 的奇技淫巧</td></tr><tr><td>114</td><td>2020-10-06</td><td><a href="https://xargin.com/10-tips/" target="_blank" rel="noopener">10 个让微服务完全失败的 tips</a></td><td>老外的一个演讲，花式吐槽微服务</td></tr><tr><td>115</td><td>2020-11-03</td><td><a href="https://xargin.com/autodumper-for-go-ii/" target="_blank" rel="noopener">无人值守的自动 dump(二)</a></td><td>书接第 111 篇，自动 dump 的实现及说明</td></tr><tr><td>116</td><td>2020-11-04</td><td><a href="https://xargin.com/packetdrill-intro/" target="_blank" rel="noopener">packetdrill 简介</a></td><td>论文翻译</td></tr><tr><td>117</td><td>2020-11-28</td><td><a href="https://xargin.com/limiting-conn-wih-subset/" target="_blank" rel="noopener">用 subsetting 限制连接池中的连接数量</a></td><td>介绍的一个 Google 的算法 subsetting</td></tr><tr><td>118</td><td>2020-12-03</td><td><a href="https://xargin.com/open-coded-defer-in-go-1-14/" target="_blank" rel="noopener">open coded defer 是怎么实现的</a></td><td>Go 1.14 对 defer 的优化</td></tr></tbody></table><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>KVM：Kernel-based Virtual Machine is a virtualization module in the Linux kernel that allows the kernel to function as a hypervisor. </p><p>Consistent hashing：consistent hashing is a special kind of hashing such that when a hash table is resized, only n/m keys need to be remapped on average where n is the number of keys and m is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation. </p><p>二八原则：网站开发有一个比较著名的二八原则，就是 80% 的用户其实访问的都是 20% 的数据。所以实际上你只要把这 20% 的数据缓存好，就可以让网站整体的响应和吞吐量上一个等级。</p><p>Solr：Solr is an open-source enterprise-search platform, written in Java, from the Apache Lucene project. Its major features include full-text search, hit highlighting, faceted search, real-time indexing, dynamic clustering, database integration, NoSQL features and rich document handling. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;某天晚上看到曹大在群里指点江山，折服。感叹为何曹大如此渊博，遂决定从头到尾研读完他所有的博文。&lt;/p&gt;
&lt;p&gt;前后共花了一个月的时间，今天终于读完了（2020-11-24~2020-12-26），总共 118 篇。从 15 年 10 月 31 日开始的第一篇，到今天，总共写</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://qcrao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="牛人" scheme="https://qcrao.com/tags/%E7%89%9B%E4%BA%BA/"/>
    
  </entry>
  
</feed>
