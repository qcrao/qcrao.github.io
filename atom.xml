<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qcrao</title>
  
  <subtitle>码农桃花源</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qcrao.com/"/>
  <updated>2020-06-06T13:24:58.695Z</updated>
  <id>https://qcrao.com/</id>
  
  <author>
    <name>饶全成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Head First 设计模式》读书笔记</title>
    <link href="https://qcrao.com/2020/05/10/head-first-design-pattern-reading-notes/"/>
    <id>https://qcrao.com/2020/05/10/head-first-design-pattern-reading-notes/</id>
    <published>2020-05-10T14:50:12.000Z</published>
    <updated>2020-06-06T13:24:58.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-设计模式入门"><a href="#第一章-设计模式入门" class="headerlink" title="第一章 设计模式入门"></a>第一章 设计模式入门</h1><blockquote><p>使用模式最好的方式是：”把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”</p></blockquote><p>通过一个给 Duck 类型添加 fly 功能的实例，一步步地提出解决方案。</p><p>先是使用继承，但是继承并不能很好地解决问题，因为鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不恰当的。</p><p>接着又提出使用接口，但是 Java 接口不具有实现代码，所以继承接口无法达到代码的复用。这意味着: 无论何时你需要修改某个行为，你必须得往下追踪并在每一个定义此行为的类中修改它，一不小心，可能会造成新的错误!</p><p>进而提出了第一个设计原则：</p><blockquote><p>设计原则一：封装变化。找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p></blockquote><p>这样的概念很简单，几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510222131.png" alt="取出易于变化的部分"></p><blockquote><p>设计原则二：针对接口编程，而不是针对实现编程。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510223436.png" alt="接口和对应的类"></p><p>关键在于，鸭子现在会将飞行和呱呱叫的动作“委托”(delegate)别人处理，而不是使用定义在 Duck 类(或子类)内的呱呱叫和飞行方法。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200510224745.png" alt="整合鸭子的行为"></p><blockquote><p>设计原则三：多用组合，少用继承。</p></blockquote><h1 id="第二章-观察者模式"><a href="#第二章-观察者模式" class="headerlink" title="第二章 观察者模式"></a>第二章 观察者模式</h1><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103228.png" alt="观察者模式"></p><blockquote><p>定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><p>类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516103804.png" alt="类图"></p><blockquote><p>设计原则四：为了交互对象之间的松耦合设计而努力。</p></blockquote><p>松耦合的设计之所以能让我们建立有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</p><h1 id="第三章-装饰者模式"><a href="#第三章-装饰者模式" class="headerlink" title="第三章 装饰者模式"></a>第三章 装饰者模式</h1><blockquote><p>设计原则五：类应该对扩展开放，对修改关闭。</p></blockquote><p>怎么理解呢？允许系统在不修改代码的情况下，进行功能扩展。想想观察者模式（在第 2 章）……通过加入新的观察者，我们可以在任何时候扩展 Subject（主题），而且不需向主题中添加代码。</p><blockquote><p>要让 OO 设计同时具备开放性和关闭性，又不修改现有的代码，需要花费许多时间和努力。一般来说，我们实在没有闲工夫把设计的每个部分都这么设计（而且，就算做得到， 也可能只是一种浪费）。遵循<code>开放-关闭</code>原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用<code>开放-关闭</code>原则。</p></blockquote><blockquote><p>定义：装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><p>类图：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200516112728.png" alt="类图"></p><h1 id="第四章-工厂模式"><a href="#第四章-工厂模式" class="headerlink" title="第四章 工厂模式"></a>第四章 工厂模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂并不是一个设计模式，它是一个编程习惯。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525114337.png" alt="简单工厂类图"></p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码和子类对象创建代码解耦了。</p><p>通过让子类决定该创建的对象是什么，来达到将对象的创建过程封装的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115100.png" alt="工厂方法 —— pizza"></p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525115941.png" alt="工厂方法类图 —— pizza"></p><p>创建者类和产品类可以放平：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120204.png" alt="平行的类层级"></p><blockquote><p>定义：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><p>注意，上面的“决定”并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525120706.png" alt="工厂方法类图"></p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525121832.png" alt="简单工厂和工厂方法的工区别"></p><blockquote><p>设计原则：依赖倒置原则。要依赖抽象，不要依赖具体类。</p></blockquote><p>不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。倒置是指和一般 OO 设计的思考方式完全相反。低层组件现在依赖高层的抽象，而高层组件现在也在依赖相同的抽象。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote><p>定义：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125846.png" alt="抽象工厂类图"></p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200525125943.png" alt="抽象工厂类图 —— pizza"></p><h1 id="第五章-单件模式"><a href="#第五章-单件模式" class="headerlink" title="第五章 单件模式"></a>第五章 单件模式</h1><p>也就是我们常说的单例模式，有些对象只能有一个实例，例如线程池、数据库连接等。全局变量也可以做到这一点，但全局变量必须一开始就要创建好对象，如果一直没用到，就形成浪费了。</p><blockquote><p>定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。</p></blockquote><p>应对多线程，有三种应对方法：</p><ol><li>直接加同步原语，在 Java 中是 synchronized。很简单，可能会有一些性能问题。</li><li>使用饿汉式，启动时即创建。</li><li>用双重加锁检查，即 double-checked locking。</li></ol><p>用 Go 来实现，非常简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton 是单例模式类</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetInstance 用于获取单例模式对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章-命令模式"><a href="#第六章-命令模式" class="headerlink" title="第六章 命令模式"></a>第六章 命令模式</h1><blockquote><p>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销操作。</p></blockquote><p>命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。</p><h1 id="第七章-适配器模式和外观模式"><a href="#第七章-适配器模式和外观模式" class="headerlink" title="第七章 适配器模式和外观模式"></a>第七章 适配器模式和外观模式</h1><p>这两个模式比较简单，工作中也用得比较多，只是叫不出名字。</p><blockquote><p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p></blockquote><p>有对象适配器和类适配器两类，前者使用组合，后者使用多重继承。后者的好处是不用实现目标类的所有方法。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123621.png" alt="对象适配器、类适配器"></p><blockquote><p>外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><p>两者的区别：只能从意图上来区别。适配器的意图是将接口转换成不同接口；而外观模式的意图是简化接口。另外需要注意的是：虽然大多数教科书所采用的例子中适配器只适配一个类，但是实际上适配器模式也可以将多个类接口转换成客户希望的一个接口。</p><blockquote><p>设计原则七：最少知识原则。只和你的密友谈话。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200531123757.png" alt="外观模式"></p><h1 id="第八章-模板方法模式"><a href="#第八章-模板方法模式" class="headerlink" title="第八章 模板方法模式"></a>第八章 模板方法模式</h1><p>很多模式之前或多或少地用过，像这一章的模板方法模式，去年在重构热力图的时候就用到过。当然，那时并不知道有这么个名字，只是很自然地一个想法。所有很多东西还是最后要上升到理论层次，就感觉不一样了。</p><blockquote><p>定义：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><p>因为 Golang 不提供继承机制，需要使用匿名组合模拟实现继承。</p><p>此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。</p><h1 id="第九章-迭代器与组合模式"><a href="#第九章-迭代器与组合模式" class="headerlink" title="第九章 迭代器与组合模式"></a>第九章 迭代器与组合模式</h1><blockquote><p>定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p></blockquote><blockquote><p>定义：组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p></blockquote><p>组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【读书会】<a href="https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE" target="_blank" rel="noopener">https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE</a></p><p>【设计模式中文网站】<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p><p>【Go 设计模式】<a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></p><h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><p>【读书会】<a href="https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE" target="_blank" rel="noopener">https://shimo.im/sheets/2nVYYYYNtjo82fTg/9YqrE</a></p><p>【设计模式中文网站】<a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns</a></p><p>【Go 设计模式】<a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener">https://github.com/senghoo/golang-design-pattern</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-设计模式入门&quot;&gt;&lt;a href=&quot;#第一章-设计模式入门&quot; class=&quot;headerlink&quot; title=&quot;第一章 设计模式入门&quot;&gt;&lt;/a&gt;第一章 设计模式入门&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用模式最好的方式是：”把模式装进脑子里，然后在你
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://qcrao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计模式" scheme="https://qcrao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之sync.map</title>
    <link href="https://qcrao.com/2020/05/06/dive-into-go-sync-map/"/>
    <id>https://qcrao.com/2020/05/06/dive-into-go-sync-map/</id>
    <published>2020-05-06T01:40:56.000Z</published>
    <updated>2020-05-06T02:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中，经常会碰到并发读写 map 而造成 panic 的情况，为什么在并发读写的时候，会 panic 呢？因为在并发读写的情况下，map 里的数据会被写乱，之后就是 <code>Garbage in, garbage out</code>，还不如直接 panic 了。</p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。而 <code>sync.map</code> 则是一种并发安全的 map，在 Go 1.9 引入。</p><blockquote><p><code>sync.map</code> 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。</p></blockquote><blockquote><p><code>sync.map</code> 的零值是有效的，并且零值是一个空的 map。在第一次使用之后，不允许被拷贝。</p></blockquote><h1 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h1><p>一般情况下解决并发读写 map 的思路是加一把大锁，或者把一个 map 分成若干个小 map，对 key 进行哈希，只操作相应的小 map。前者锁的粒度比较大，影响效率；后者实现起来比较复杂，容易出错。</p><p>而使用 <code>sync.map</code> 之后，对 map 的读写，不需要加锁。并且它通过空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>使用非常简单，和普通 map 相比，仅遍历的方式略有区别：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"><span class="comment">// 1. 写入</span></span><br><span class="line">m.Store(<span class="string">"qcrao"</span>, <span class="number">18</span>)</span><br><span class="line">m.Store(<span class="string">"stefno"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 读取</span></span><br><span class="line">age, _ := m.Load(<span class="string">"qcrao"</span>)</span><br><span class="line">fmt.Println(age.(<span class="keyword">int</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 遍历</span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">name := key.(<span class="keyword">string</span>)</span><br><span class="line">age := value.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 删除</span></span><br><span class="line">m.Delete(<span class="string">"qcrao"</span>)</span><br><span class="line">age, ok := m.Load(<span class="string">"qcrao"</span>)</span><br><span class="line">fmt.Println(age, ok)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 读取或写入</span></span><br><span class="line">m.LoadOrStore(<span class="string">"stefno"</span>, <span class="number">100</span>)</span><br><span class="line">age, _ = m.Load(<span class="string">"stefno"</span>)</span><br><span class="line">fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 1 步，写入两个 k-v 对；</p><p>第 2 步，使用 Load 方法读取其中的一个 key；</p><p>第 3 步，遍历所有的 k-v 对，并打印出来；</p><p>第 4 步，删除其中的一个 key，再读这个 key，得到的就是 nil；</p><p>第 5 步，使用 LoadOrStore，尝试读取或写入 “Stefno”，因为这个 key 已经存在，因此写入不成功，并且读出原值。</p><p>程序输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">stefno 20</span><br><span class="line">qcrao 18</span><br><span class="line">&lt;nil&gt; false</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p><code>sync.map</code> 适用于读多写少的场景。对于写多的场景，会导致 read map 缓存失效，需要加锁，导致冲突变多；而且由于未命中 read map 次数过多，导致 dirty map 提升为 read map，这是一个 O(N) 的操作，会进一步降低性能。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>先来看下 map 的数据结构。去掉大段的注释后：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥量 <code>mu</code> 保护 read 和 dirty。</p><p><code>read</code> 是 atomic.Value 类型，可以并发地读。但如果需要更新 <code>read</code>，则需要加锁保护。对于 read 中存储的 entry 字段，可能会被并发地 CAS 更新。但是如果要更新一个之前已被删除的 entry，则需要先将其状态从 expunged 改为 nil，再拷贝到 dirty 中，然后再更新。</p><p><code>dirty</code> 是一个非线程安全的原始 map。包含新写入的 key，并且包含 <code>read</code> 中的所有未被删除的 key。这样，可以快速地将 <code>dirty</code> 提升为 <code>read</code> 对外提供服务。如果 <code>dirty</code> 为 nil，那么下一次写入时，会新建一个新的 <code>dirty</code>，这个初始的 <code>dirty</code> 是 <code>read</code> 的一个拷贝，但除掉了其中已被删除的 key。</p><p>每当从 read 中读取失败，都会将 <code>misses</code> 的计数值加 1，当加到一定阈值以后，需要将 dirty 提升为 read，以期减少 miss 的情形。</p><blockquote><p><code>read map</code> 和 <code>dirty map</code> 的存储方式是不一致的。</p></blockquote><blockquote><p>前者使用 atomic.Value，后者只是单纯的使用 map。</p></blockquote><blockquote><p>原因是 read map 使用 lock free 操作，必须保证 load/store 的原子性；而 dirty map 的 load+store 操作是由 lock（就是 mu）来保护的。</p></blockquote><p>真正存储 <code>key/value</code> 的是 read 和 dirty 字段。<code>read</code> 使用 atomic.Value，这是 lock-free 的基础，保证 load/store 的原子性。<code>dirty</code> 则直接用了一个原始的 map，对于它的 load/store 操作需要加锁。</p><p><code>read</code> 字段里实际上是存储的是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 read 和 dirty 里存储的东西都包含 <code>entry</code>，来看一下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，它是一个指针，指向 value。看来，read 和 dirty 各自维护一套 key，key 指向的都是同一个 value。也就是说，只要修改了这个 entry，对 read 和 dirty 都是可见的。这个指针的状态有三种：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200504093007.png" alt="p 的三种状态"></p><p>当 <code>p == nil</code> 时，说明这个键值对已被删除，并且 m.dirty == nil，或 m.dirty[k] 指向该 entry。</p><p>当 <code>p == expunged</code> 时，说明这条键值对已被删除，并且 m.dirty != nil，且 m.dirty 中没有这个 key。</p><p>其他情况，p 指向一个正常的值，表示实际 <code>interface{}</code> 的地址，并且被记录在 m.read.m[key] 中。如果这时 m.dirty 不为 nil，那么它也被记录在 m.dirty[key] 中。两者实际上指向的是同一个值。</p><p>当删除 key 时，并不实际删除。一个 entry 可以通过原子地（CAS 操作）设置 p 为 nil 被删除。如果之后创建 m.dirty，nil 又会被原子地设置为 expunged，且不会拷贝到 dirty 中。</p><p>如果 p 不为 expunged，和 entry 相关联的这个 value 可以被原子地更新；如果 <code>p == expunged</code>，那么仅当它初次被设置到 m.dirty 之后，才可以被更新。</p><p>整体用一张图来表示：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200505120255.png" alt="sync.map 整体结构"></p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>先来看 expunged：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;))</span><br></pre></td></tr></table></figure><p>它是一个指向任意类型的指针，用来标记从 dirty map 中删除的 entry。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果 read map 中存在该 key  则尝试直接更改(由于修改的是 entry 内部的 pointer，因此 dirty map 也可见)</span></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line"><span class="comment">// 如果 read map 中存在该 key，但 p == expunged，则说明 m.dirty != nil 并且 m.dirty 中不存在该 key 值 此时:</span></span><br><span class="line"><span class="comment">//    a. 将 p 的状态由 expunged  更改为 nil</span></span><br><span class="line"><span class="comment">//    b. dirty map 插入 key</span></span><br><span class="line">m.dirty[key] = e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新 entry.p = value (read map 和 dirty map 指向同一个 entry)</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">// 如果 read map 中不存在该 key，但 dirty map 中存在该 key，直接写入更新 entry(read map 中仍然没有这个 key)</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果 read map 和 dirty map 中都不存在该 key，则：</span></span><br><span class="line"><span class="comment">//  a. 如果 dirty map 为空，则需要创建 dirty map，并从 read map 中拷贝未删除的元素到新创建的 dirty map</span></span><br><span class="line"><span class="comment">//    b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key</span></span><br><span class="line"><span class="comment">//    c. 将 kv 写入 dirty map 中，read 不变</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">    <span class="comment">// 到这里就意味着，当前的 key 是第一次被加到 dirty map 中。</span></span><br><span class="line"><span class="comment">// store 之前先判断一下 dirty map 是否为空，如果为空，就把 read map 浅拷贝一次。</span></span><br><span class="line">m.dirtyLocked()</span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入新 key，在 dirty 中存储 value</span></span><br><span class="line">m.dirty[key] = newEntry(value)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程：</p><ol><li>如果在 read 里能够找到待存储的 key，并且对应的 entry 的 p 值不为 expunged，也就是没被删除时，直接更新对应的 entry 即可。</li><li>第一步没有成功：要么 read 中没有这个 key，要么 key 被标记为删除。则先加锁，再进行后续的操作。</li><li>再次在 read 中查找是否存在这个 key，也就是 double check 一下，这也是 lock-free 编程里的常见套路。如果 read 中存在该 key，但 <code>p == expunged</code>，说明 m.dirty != nil 并且 m.dirty 中不存在该 key 值 此时: a. 将 p 的状态由 expunged  更改为 nil；b. dirty map 插入 key。然后，直接更新对应的 value。</li><li>如果 read 中没有此 key，那就查看 dirty 中是否有此 key，如果有，则直接更新对应的 value，这时 read 中还是没有此 key。</li><li>最后一步，如果 read 和 dirty 中都不存在该 key，则：a. 如果 dirty 为空，则需要创建 dirty，并从 read 中拷贝未被删除的元素；b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key；c. 将 k-v 写入 dirty map 中，read.m 不变。最后，更新此 key 对应的 value。</li></ol><p>再来看一些子函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 entry 没被删，tryStore 存储值到 entry 中。如果 p == expunged，即 entry 被删，那么返回 false。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryStore</code> 在 Store 函数最开始的时候就会调用，是比较常见的 <code>for</code> 循环加 CAS 操作，尝试更新 entry，让 p 指向新的值。</p><p><code>unexpungeLocked</code> 函数确保了 entry 没有被标记成已被清除：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unexpungeLocked 函数确保了 entry 没有被标记成已被清除。</span></span><br><span class="line"><span class="comment">// 如果 entry 先前被清除过了，那么在 mutex 解锁之前，它一定要被加入到 dirty map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="comment">// 如果没在 read 中找到，并且 amended 为 true，即 dirty 中存在 read 中没有的 key</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock() <span class="comment">// dirty map 不是线程安全的，所以需要加上互斥锁</span></span><br><span class="line"><span class="comment">// double check。避免在上锁的过程中 dirty map 提升为 read map。</span></span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="comment">// 仍然没有在 read 中找到这个 key，并且 amended 为 true</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">e, ok = m.dirty[key] <span class="comment">// 从 dirty 中找</span></span><br><span class="line"><span class="comment">// 不管 dirty 中有没有找到，都要"记一笔"，因为在 dirty 提升为 read 之前，都会进入这条路径</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">// 如果没找到，返回空，false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理路径分为 fast path 和 slow path，整体流程如下：</p><ol><li>首先是 fast path，直接在 read 中找，如果找到了直接调用 entry 的 load 方法，取出其中的值。</li><li>如果 read 中没有这个 key，且 amended 为 fase，说明 dirty 为空，那直接返回 空和 false。</li><li>如果 read 中没有这个 key，且 amended 为 true，说明 dirty 中可能存在我们要找的 key。当然要先上锁，再尝试去 dirty 中查找。在这之前，仍然有一个 double check 的操作。若还是没有在 read 中找到，那么就从 dirty 中找。不管 dirty 中有没有找到，都要”记一笔”，因为在 dirty 被提升为 read 之前，都会进入这条路径</li></ol><p>这里主要看下 <code>missLocked</code> 的函数的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dirty map 晋升</span></span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将 misses 的值加 1，表示一次未命中，如果 misses 值小于 m.dirty 的长度，就直接返回。否则，将 m.dirty 晋升为 read，并清空 dirty，清空 misses 计数值。这样，之前一段时间新加入的 key 都会进入到 read 中，从而能够提升 read 的命中率。</p><p>再来看下 entry 的 load 方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 nil 和 expunged 状态的 entry，直接返回 <code>ok=false</code>；否则，将 p 转成 <code>interface{}</code> 返回。</p><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="comment">// 如果 read 中没有这个 key，且 dirty map 不为空</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key) <span class="comment">// 直接从 dirty 中删除这个 key</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">e.<span class="built_in">delete</span>() <span class="comment">// 如果在 read 中找到了这个 key，将 p 置为 nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，基本套路还是和 Load，Store 类似，都是先从 read 里查是否有这个 key，如果有则执行 <code>entry.delete</code> 方法，将 p 置为 nil，这样 read 和 dirty 都能看到这个变化。</p><p>如果没在 read 中找到这个 key，并且 dirty 不为空，那么就要操作 dirty 了，操作之前，还是要先上锁。然后进行 double check，如果仍然没有在 read 里找到此 key，则从 dirty 中删掉这个 key。但不是真正地从 dirty 中删除，而是更新 entry 的状态。</p><p>来看下 <code>entry.delete</code> 方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它真正做的事情是将正常状态（指向一个 interface{}）的 p 设置成 nil。没有设置成 expunged 的原因是，当 p 为 expunged 时，表示它已经不在 dirty 中了。这是 p 的状态机决定的，在 <code>tryExpungeLocked</code> 函数中，会将 nil 原子地设置成 expunged。</p><p><code>tryExpungeLocked</code> 是在新创建 dirty 时调用的，会将已被删除的 entry.p 从 nil 改成 expunged，这个 entry 就不会写入 dirty 了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果原来是 nil，说明原 key 已被删除，则将其转为 expunged。</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到如果 key 同时存在于 read 和 dirty 中时，删除只是做了一个标记，将 p 置为 nil；而如果仅在 dirty 中含有这个 key 时，会直接删除这个 key。原因在于，若两者都存在这个 key，仅做标记删除，可以在下次查找这个 key 时，命中 read，提升效率。若只有在 dirty 中存在时，read 起不到“缓存”的作用，直接删除。</p><h2 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h2><p>这个函数结合了 Load 和 Store 的功能，如果 map 中存在这个 key，那么返回这个 key 对应的 value；否则，将 key-value 存入 map。这在需要先执行 Load 查看某个 key 是否存在，之后再更新此 key 对应的 value 时很有效，因为 LoadOrStore 可以并发执行。</p><p>具体的过程不再一一分析了，可参考 Load 和 Store 的源码分析。</p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range 的参数是一个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>由使用者提供实现，Range 将遍历调用时刻 map 中的所有 k-v 对，将它们传给 f 函数，如果 f 返回 false，将停止遍历。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> read.amended &#123;</span><br><span class="line">read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">m.read.Store(read)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">v, ok := e.load()</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 amended 为 true 时，说明 dirty 中含有 read 中没有的 key，因为 Range 会遍历所有的 key，是一个 O(n) 操作。将 dirty 提升为 read，会将开销分摊开来，所以这里直接就提升了。</p><p>之后，遍历 read，取出 entry 中的值，调用 f(k, v)。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>关于为何 <code>sync.map</code> 没有 Len 方法，参考资料里给出了 <a href="https://github.com/golang/go/issues/20680" target="_blank" rel="noopener">issue</a>，<code>bcmills</code> 认为对于并发的数据结构和非并发的数据结构并不一定要有相同的方法。例如，map 有 Len 方法，sync.map 却不一定要有。就像 sync.map 有 LoadOrStore 方法，map 就没有一样。</p><p>有些实现增加了一个计数器，并原子地增加或减少它，以此来表示 sync.map 中元素的个数。但 <code>bcmills</code> 提出这会引入竞争：<code>atomic</code> 并不是 <code>contention-free</code> 的，它只是把竞争下沉到了 CPU 层级。这会给其他不需要 Len 方法的场景带来负担。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p><code>sync.map</code> 是线程安全的，读取，插入，删除也都保持着常数级的时间复杂度。</p></li><li><p>通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。</p></li><li><p>Range 操作需要提供一个函数，参数是 <code>k,v</code>，返回值是一个布尔值：<code>f func(key, value interface{}) bool</code>。</p></li><li><p>调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。</p></li><li><p>新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。</p></li><li><p>当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【德志大佬-设计并发安全的 map】<a href="https://halfrost.com/go_map_chapter_one/" target="_blank" rel="noopener">https://halfrost.com/go_map_chapter_one/</a></p><p>【德志大佬-设计并发安全的 map】<a href="https://halfrost.com/go_map_chapter_two/" target="_blank" rel="noopener">https://halfrost.com/go_map_chapter_two/</a></p><p>【关于 sync.map 为什么没有 len 方法的 issue】<a href="https://github.com/golang/go/issues/20680" target="_blank" rel="noopener">https://github.com/golang/go/issues/20680</a></p><p>【芮神增加了 len 方法】<a href="http://xiaorui.cc/archives/4972" target="_blank" rel="noopener">http://xiaorui.cc/archives/4972</a></p><p>【图解 map 操作】<a href="https://wudaijun.com/2018/02/go-sync-map-implement/" target="_blank" rel="noopener">https://wudaijun.com/2018/02/go-sync-map-implement/</a></p><p>【从一道面试题开始】<a href="https://segmentfault.com/a/1190000018657984" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018657984</a></p><p>【源码分析】<a href="https://zhuanlan.zhihu.com/p/44585993" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44585993</a></p><p>【行文通畅，流程图清晰】<a href="https://juejin.im/post/5d36a7cbf265da1bb47da444" target="_blank" rel="noopener">https://juejin.im/post/5d36a7cbf265da1bb47da444</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作中，经常会碰到并发读写 map 而造成 panic 的情况，为什么在并发读写的时候，会 panic 呢？因为在并发读写的情况下，map 里的数据会被写乱，之后就是 &lt;code&gt;Garbage in, garbage out&lt;/code&gt;，还不如直接 panic 了。&lt;/
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>“���”引发的线上事故</title>
    <link href="https://qcrao.com/2020/04/27/codec-accident/"/>
    <id>https://qcrao.com/2020/04/27/codec-accident/</id>
    <published>2020-04-26T16:10:53.000Z</published>
    <updated>2020-04-28T00:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一起依赖升级 + 异常数据引发的线上事故，教训惨痛，本文对此进行回故和总结。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>起因是我们使用的服务框架版本比较老，GC 次数的 metrics 打点一直为 0，咨询了相关同学后，决定升级框架。升级的过程中，出现了 <code>use of internal package xxx not allowed</code> 的报错，又咨询了一下相关同学后，尝试使用 <code>go mod</code> 解决。</p><p>从 <code>go vendor</code> 到 <code>go mod</code> 的升级的过程也不太顺利，这里按下不表，最终是升级成功了。一同升级的还有 Go 版本，从 1.11 升级到 1.13。</p><p>周四上完线后，一切都看似很不错：内存占用、GC 消耗的 CPU 有了优化，GC 次数的监控也有了。因为涉及到公司内部数据，图我就不放了。</p><p>周五、周六都平安度过，周日出问题了，小组的同学从下午 12 点左右一直肝到凌晨 12 点，才松了一口气。可怜我们来之不易的一个周日！</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>周日 11 点 45 左右，端口的调用失败率报警，同时有业务方反馈调用接口报错。</p><p>同志们，关键时刻，完善的报警能给事故的处理和恢复赢得时间啊！</p><p>By case 排查，发现服务 shard3 集群的机器报 <code>i/o timeout</code> 错误。服务共有 4 个分片集群（根据 ID hash 到对应分片），其他 3 个集群完全正常。接着发现 shard3 集群的机器内存正常、端口还在，但 <code>in/out</code> 流量全部掉到几十 KB/s，看日志也没有发现任何异常。</p><p>重启 shard3 集群的服务，重启后的服务恢复正常，访问 debug 端口，也是正常的。然而，十几分钟后，恢复的服务再次出现异常：<code>in/out</code> 流量再次掉到几十 KB/s，访问 debug 端口也没有任何响应，开始慌了。</p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><blockquote><p>上线出问题，第一时间回滚！</p></blockquote><p>稳定性里面很重要的一条就是：有问题，先回滚。先止损，将事故影响降到最低，事后再来追查根因，总结复盘。</p><p>于是开始操作回滚，<code>reset</code> 到周四上线之前的一个 commit，重新打包，上线 shard3 集群。之后，对外接口完全恢复，操作回滚其他集群。</p><p>服务启动之前，需要先加载几十个 G 左右的数据，启动过程长达 10+ min。我申请了一台线上问题机器的 root 权限，执行了 <code>strace -p</code> 命令：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200424084816.png" alt="strace -p"></p><p>发现服务卡在 futex 系统调用上，这很明显是一个 timer，但是 timer 为何会卡住？正常情况下，会有各种像 write，read 的系统调用，至少打日志、上报 mertrics 打点数据都会有 write 系统调用吧，哈？再执行 <code>perf top</code> 命令：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200426134421.png" alt="perf top"></p><p>相关的只有 <code>codec</code> 函数，再看服务进程：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200426134739.png" alt="perf top -r 80 -g -p"></p><p>看 perf 输出的结果，全部聚焦到 codec 这个第三方库上，主要的两个函数竟然是 <code>codec.quoteStr</code> 和 <code>utf8.DecodeRuneInString</code>。而我们用 codec 的地方是在程序启动时加载数据文件以及定时的 dump 文件到本地。现在程序已经启动了，只可能是 dump 文件出问题了。查看相关日志，果然有开始 dump 文件的日志记录，却一直没有 dump 成功的记录。</p><h1 id="追查"><a href="#追查" class="headerlink" title="追查"></a>追查</h1><p>事后追查阶段尝试在 <code>test</code> 集群上重现故障，因为只有单个分片出问题，说明此故障和特定数据有关，是 hash 到分片 3 的数据引起的问题。</p><p>又因为 <code>test</code> 集群并没有分片，所以强行（改代码 &amp;&amp; 改环境变量）将其伪装成 shard3 集群，然则并没有复现，猜测可能是计划下线了。</p><p>周二的时候，终于在 test 集群上模拟分片 1 时重现了线上故障。</p><p>对比 codec 的版本问题，果然有问题：周四上线前，<code>vendor.json</code> 里的版本是 v1.1.7，上线后，升级到了 v1.1.8，看来找到问题了！修改 codec 的版本，重新编译、部署，问题依然存在！</p><p>这时，组里其他同学反馈 2018 年的时候也出过 codec 的问题，当时也是出现了异常数据导致重启时加载文件不成功。于是我直接将周四上线前 vendor 文件夹里 <code>codec.quoteStr</code> 函数的代码和 codec 的 v1.1.7 代码进行对比，并不相同！<code>vendor.json</code> 里的版本并没有正确反应 vendor 里实际的 codec 版本！！！</p><p>进一步查看提交记录，发现在 2017 年 11 月份的时候有一次提交，修改了 vendor 文件夹里的代码，但这时 <code>vendor.json</code> 并没有 codec 记录。而在 2019 年 11 月的一次提交，则只在 <code>vendor.json</code> 里增加了一条 codec 记录，vendor 文件夹里的代码并没有更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"checksumSHA1": "wfboMqCTVImg0gW31jvyvCymJPE=",</span><br><span class="line">"path": "github.com/ugorji/go/codec",</span><br><span class="line">"revision": "e118e2d506a6b252f6b85f2e2f2ac1bfed82f1b8",</span><br><span class="line">"revisionTime": "2019-07-23T09:17:30Z",</span><br><span class="line">"tree": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细比对代码，主要差异在这：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200425173458.png" alt="codec 版本对比"></p><p>从现象及源码看，大概率是在 <code>codec.quoteStr</code> 里死循环了！由于 Go 1.14 前都无法抢占正在执行无限循环且没有任何函数调用的 goroutine，因此一旦出现死循环，将要进行 GC 的时候，其他所有 goroutine 都会停止，并且都在等着无限循环的 goroutine 停下来，遗憾的是，由于 <code>for {}</code> 循环里没有进行函数调用，无法插入抢占标记并进行抢占。于是，就出现了这样一幕：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/swwwkwqwy.jpeg" alt="围观"></p><p>只有 dump 数据文件这一个 goroutine 在干活，而且做的又是无限循环，服务整体对外表现就像是“死机”了一样。并且这个 goroutine 由一个 timer 触发工作，所以一开始我们看到的卡在一个 futex 调用上就可以解释得通。因为 runtime 都停止工作了，timer 自然就没法“到期”了。</p><p>接着，使用 Go 1.14 去编译有问题的代码版本，上到 test 集群，果然问题“消失”。服务状态完全恢复正常，唯一不正常的是数据文件无法 dump 下来了，因为即使是 Go 1.14，也依然在执行无限循环，不干“正事”。</p><p>接下来的问题就是找到异常的数据了。使用上线前的版本（使用 go vendor），将 codec 替换为最新的 v1.1.8 版本，并且在 <code>quoteStr</code> 函数里打上了几行日志：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200424110256.png" alt="加上 debug 日志"></p><p>部署到 test 集群，问题复现：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200424110546.png" alt="问题日志"></p><p>异常数据就是：“孙���雷”：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200424111127.png" alt="中文转 Unicode"></p><p>为什么会引发死循环，在调用 <code>utf8.DecodeRuneInString</code> 函数后：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c == utf8.RuneError</span><br><span class="line">size == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>再看 <code>RuneError</code> 的定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RuneError = <span class="string">'\uFFFD'</span></span><br></pre></td></tr></table></figure><p>看一下两个版本的代码不同之处：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200425173458.png" alt="codec 版本对比"></p><p>老版本的代码，不会进入 if 分支，而新版本的代码，由于 <code>c == utf8.RuneError</code>，所以先进入 if 分支，之后，<code>size == 3</code>，不满足里层分支，直接 continue 了，因此 <code>i</code> 值并没有发生变化，死循环就这么发生了。</p><p>最后就是找到异常数据到底属于哪个计划。我尝试去每个集群的机器上，从数据文件里寻找“孙���雷”。但文件太大了，几十个 G，<code>grep</code> 搞不定，没关系，使用 dd 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=model_20200423155728 bs=1024 skip=3600000 count=1200 | grep '孙���雷'</span><br></pre></td></tr></table></figure><p>使用二分法找到了“孙���雷”！关于 <code>dd + grep</code> 的用法，总结了几点：</p><ol><li>每次从文件开头先跳过 <code>skip*bs</code> 大小的内容，复制 <code>count*bs</code> 大小的内容过来用 grep 查询。</li><li>如果不设置 count，就会查找整个文件，如果查到，则会有输出；否则无。</li><li>对于特别大的文件，可以先把 count 设为跳过一半文件大小的值，采用二分法查找。如果找到，则限定在了前半范围，否则在后半部分。使用类似的方法继续查找……</li><li>如果找到，最后会输出 count*bs 大小的内容。</li></ol><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol><li>服务重大版本更新，至少在线下跑一周。</li><li>有问题，第一时间回滚。</li><li>对于工具的使用要规范。如不要随意更改 vendor 文件夹的内容而不同步更新 <code>vendor.json</code> 文件，反之亦然。</li><li>因为 <code>go mod</code> 的版本选择以及不遵守开源规范的第三方库作者会让使用者不知不觉、被动地引入一些难以发现的问题。可以使用 <code>go mod vendor</code> 代替，如果要锁死版本的话，使用 replace。</li></ol><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><p>【stw 如何停止 goroutine】<a href="https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846</a></p><p>【Go Modules 终极入门】<a href="https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/" target="_blank" rel="noopener">https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到了一起依赖升级 + 异常数据引发的线上事故，教训惨痛，本文对此进行回故和总结。&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;起因是我们使用的服务框架版本比较老，G
      
    
    </summary>
    
      <category term="性能优化" scheme="https://qcrao.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="故障排查" scheme="https://qcrao.com/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之sync.pool</title>
    <link href="https://qcrao.com/2020/04/20/dive-into-go-sync-pool/"/>
    <id>https://qcrao.com/2020/04/20/dive-into-go-sync-pool/</id>
    <published>2020-04-20T01:34:32.000Z</published>
    <updated>2020-05-06T01:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中碰到了 GC 的问题：项目中大量重复地创建许多对象，造成 GC 的工作量巨大，CPU 频繁掉底。准备使用 <code>sync.Pool</code> 来缓存对象，减轻 GC 的消耗。为了用起来更顺畅，我特地研究了一番，形成此文。本文从使用到源码解析，循序渐进，一一道来。</p><blockquote><p>本文基于 Go 1.14</p></blockquote><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 <code>sync.Cache</code> 是一个更合适的名字。</p><h1 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h1><p>对于很多需要重复分配、回收内存的地方，<code>sync.Pool</code> 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 <code>sync.Pool</code> 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</p><h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。</p></blockquote><blockquote><p>在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>首先来看一个简单的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool *sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">pool = &amp;sync.Pool &#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">fmt.Println(<span class="string">"Creating a new Person"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(Person)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">initPool()</span><br><span class="line"></span><br><span class="line">p := pool.Get().(*Person)</span><br><span class="line">fmt.Println(<span class="string">"首次从 pool 里获取："</span>, p)</span><br><span class="line"></span><br><span class="line">p.Name = <span class="string">"first"</span></span><br><span class="line">fmt.Printf(<span class="string">"设置 p.Name = %s\n"</span>, p.Name)</span><br><span class="line"></span><br><span class="line">pool.Put(p)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: "</span>, pool.Get().(*Person))</span><br><span class="line">fmt.Println(<span class="string">"Pool 没有对象了，调用 Get: "</span>, pool.Get().(*Person))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="built_in">new</span> Person</span><br><span class="line">首次从 pool 里获取： &amp;&#123;&#125;</span><br><span class="line">设置 p.Name = first</span><br><span class="line">Pool 里已有一个对象：&amp;&#123;first&#125;，Get:  &amp;&#123;first&#125;</span><br><span class="line">Creating a <span class="built_in">new</span> Person</span><br><span class="line">Pool 没有对象了，Get:  &amp;&#123;&#125;</span><br></pre></td></tr></table></figure><p>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，最好的做法是在 Put 前，将对象清空。</p><h2 id="fmt-包如何用"><a href="#fmt-包如何用" class="headerlink" title="fmt 包如何用"></a>fmt 包如何用</h2><p>这部分主要看 <code>fmt.Printf</code> 如何使用：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fprintf(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>Fprintf</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintf(format, a)</span><br><span class="line">n, err = w.Write(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newPrinter allocates a new pp struct or grabs a cached one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span> *<span class="title">pp</span></span> &#123;</span><br><span class="line">p := ppFree.Get().(*pp)</span><br><span class="line">p.panicking = <span class="literal">false</span></span><br><span class="line">p.erroring = <span class="literal">false</span></span><br><span class="line">p.wrapErrs = <span class="literal">false</span></span><br><span class="line">p.fmt.init(&amp;p.buf)</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ppFree = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free saves used pp structs in ppFree; avoids an allocation per invocation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">free</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.buf = p.buf[:<span class="number">0</span>]</span><br><span class="line">p.arg = <span class="literal">nil</span></span><br><span class="line">p.value = reflect.Value&#123;&#125;</span><br><span class="line">p.wrappedErr = <span class="literal">nil</span></span><br><span class="line">ppFree.Put(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归还到 Pool 前将对象的一些字段清零，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h2 id="pool-test"><a href="#pool-test" class="headerlink" title="pool_test"></a>pool_test</h2><p>通过 test 文件学习源码是一个很好的途径，因为它代表了“官方”的用法。更重要的是，测试用例会故意测试一些“坑”，学习这些坑，也会让自己在使用的时候就能学会避免。</p><p><code>pool_test</code> <a href="https://github.com/golang/go/blob/release-branch.go1.14/src/sync/pool_test.go" target="_blank" rel="noopener">文件</a>里共有 7 个测试，4 个 BechMark。</p><p><code>TestPool</code> 和 <code>TestPoolNew</code> 比较简单，主要是测试 Get/Put 的功能。我们来看下 <code>TestPoolNew</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPoolNew</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// disable GC so we can control when it happens.</span></span><br><span class="line"><span class="keyword">defer</span> debug.SetGCPercent(debug.SetGCPercent(<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">p := Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v := p.Get(); v != <span class="number">1</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"got %v; want 1"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v := p.Get(); v != <span class="number">2</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"got %v; want 2"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure that the goroutine doesn't migrate to another P</span></span><br><span class="line"><span class="comment">// between Put and Get calls.</span></span><br><span class="line">Runtime_procPin()</span><br><span class="line">p.Put(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> v := p.Get(); v != <span class="number">42</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"got %v; want 42"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">Runtime_procUnpin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v := p.Get(); v != <span class="number">3</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">"got %v; want 3"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置了 <code>GC=-1</code>，作用就是停止 GC。那为啥要用 defer？函数都跑完了，还要 defer 干啥。注意到，<code>debug.SetGCPercent</code> 这个函数被调用了两次，而且这个函数返回的是上一次 GC 的值。因此，defer 在这里的用途是还原到调用此函数之前的 GC 设置，也就是恢复现场。</p><p>接着，调置了 Pool 的 New 函数：直接返回一个 int，变且每次调用 New，都会自增 1。然后，连续调用了两次 Get 函数，因为这个时候 Pool 里没有缓存的对象，因此每次都会调用 New 创建一个，所以第一次返回 1，第二次返回 2。</p><p>然后，调用 <code>Runtime_procPin()</code> 防止 goroutine 被强占，目的是保护接下来的一次 Put 和 Get 操作，使得它们操作的对象都是同一个 P 的“池子”。并且，这次调用 Get 的时候并没有调用 New，因为之前有一次 Put 的操作。</p><p>最后，再次调用 Get 操作，因为没有“存货”，因此还是会再次调用 New 创建一个对象。</p><p><code>TestPoolGC</code> 和 <code>TestPoolRelease</code> 则主要测试 GC 对 Pool 里对象的影响。这里用了一个函数，用于计数有多少对象会被 GC 回收：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime.SetFinalizer(v, <span class="function"><span class="keyword">func</span><span class="params">(vv *<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">atomic.AddUint32(&amp;fin, <span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当垃圾回收检测到 <code>v</code> 是一个不可达的对象时，并且 <code>v</code> 又有一个关联的 <code>Finalizer</code>，就会另起一个 goroutine 调用设置的 finalizer 函数，也就是上面代码里的参数 func。这样，就会让对象 v 重新可达，从而在这次 GC 过程中不被回收。之后，解绑对象 v 和它所关联的 <code>Finalizer</code>，当下次 GC 再次检测到对象 v 不可达时，才会被回收。</p><p><code>TestPoolStress</code> 从名字看，主要是想测一下“压力”，具体操作就是起了 10 个 goroutine 不断地向 Pool 里 Put 对象，然后又 Get 对象，看是否会出错。</p><p><code>TestPoolDequeue</code> 和 <code>TestPoolChain</code>，都调用了 <code>testPoolDequeue</code>，这是具体干活的。它需要传入一个 <code>PoolDequeue</code> 接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poolDequeue testing.</span></span><br><span class="line"><span class="keyword">type</span> PoolDequeue <span class="keyword">interface</span> &#123;</span><br><span class="line">PushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></span><br><span class="line">PopHead() (<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span><br><span class="line">PopTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PoolDequeue</code> 是一个双端队列，可以从头部入队元素，从头部和尾部出队元素。调用函数时，前者传入 <code>NewPoolDequeue(16)</code>，后者传入 <code>NewPoolChain()</code>，底层其实都是 <code>poolDequeue</code> 这个结构体。具体来看 <code>testPoolDequeue</code> 做了什么：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200410125923.png" alt="双端队列"></p><p>总共起了 10 个 goroutine：1 个生产者，9 个消费者。生产者不断地从队列头 pushHead 元素到双端队列里去，并且每 push 10 次，就 popHead 一次；消费者则一直从队列尾取元素。不论是从队列头还是从队列尾取元素，都会在 map 里做标记，最后检验每个元素是不是只被取出过一次。</p><p>剩下的就是 Benchmark 测试了。第一个 <code>BenchmarkPool</code> 比较简单，就是不停地 Put/Get，测试性能。</p><p><code>BenchmarkPoolSTW</code> 函数会先关掉 GC，再向 pool 里 put 10 个对象，然后强制触发 GC，记录 GC 的停顿时间，并且做一个排序，计算 P50 和 P95 的 STW 时间。这个函数可以加入个人的代码库了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPoolSTW</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// Take control of GC.</span></span><br><span class="line"><span class="keyword">defer</span> debug.SetGCPercent(debug.SetGCPercent(<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mstats runtime.MemStats</span><br><span class="line"><span class="keyword">var</span> pauses []<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p Pool</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="comment">// Put a large number of items into a pool.</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100000</span></span><br><span class="line"><span class="keyword">var</span> item <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">p.Put(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do a GC.</span></span><br><span class="line">runtime.GC()</span><br><span class="line"><span class="comment">// Record pause time.</span></span><br><span class="line">runtime.ReadMemStats(&amp;mstats)</span><br><span class="line">pauses = <span class="built_in">append</span>(pauses, mstats.PauseNs[(mstats.NumGC+<span class="number">255</span>)%<span class="number">256</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get pause time stats.</span></span><br><span class="line">sort.Slice(pauses, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> pauses[i] &lt; pauses[j] &#125;)</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">for</span> _, ns := <span class="keyword">range</span> pauses &#123;</span><br><span class="line">total += ns</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ns/op for this benchmark is average STW time.</span></span><br><span class="line">b.ReportMetric(<span class="keyword">float64</span>(total)/<span class="keyword">float64</span>(b.N), <span class="string">"ns/op"</span>)</span><br><span class="line">b.ReportMetric(<span class="keyword">float64</span>(pauses[<span class="built_in">len</span>(pauses)*<span class="number">95</span>/<span class="number">100</span>]), <span class="string">"p95-ns/STW"</span>)</span><br><span class="line">b.ReportMetric(<span class="keyword">float64</span>(pauses[<span class="built_in">len</span>(pauses)*<span class="number">50</span>/<span class="number">100</span>]), <span class="string">"p50-ns/STW"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在 mac 上跑了一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -run=none -bench=BenchmarkPoolSTW</span><br></pre></td></tr></table></figure><p>得到输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: sync</span><br><span class="line">BenchmarkPoolSTW-12    361    3708 ns/op    3583 p50-ns/STW    5008 p95-ns/STW</span><br><span class="line">PASS</span><br><span class="line">ok      sync    1.481s</span><br></pre></td></tr></table></figure><p>最后一个 <code>BenchmarkPoolExpensiveNew</code> 测试当 New 的代价很高时，Pool 的表现。也可以加入个人的代码库。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>标准库中 <code>encoding/json</code> 也用到了 sync.Pool 来提升性能。著名的 <code>gin</code> 框架，对 context 取用也到了 <code>sync.Pool</code>。</p><p>来看下 <code>gin</code> 如何使用 sync.Pool。设置 New 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">allocateContext</span><span class="params">()</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine, KeysMutex: &amp;sync.RWMutex&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP conforms to the http.Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">c := engine.pool.Get().(*Context)</span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset()</span><br><span class="line"></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 Get 取出来缓存的对象，然后会做一些 reset 操作，再执行 <code>handleHTTPRequest</code>，最后再 Put 回 Pool。</p><p>另外，Echo 框架也使⽤了 <code>sync.Pool</code> 来管理 <code>context</code>，并且⼏乎达到了零堆内存分配：</p><blockquote><p>It leverages sync pool to reuse memory and achieve zero dynamic memory allocation with no GC overhead.</p></blockquote><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Pool-结构体"><a href="#Pool-结构体" class="headerlink" title="Pool 结构体"></a>Pool 结构体</h2><p>首先来看 Pool 的结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 P 的本地队列，实际类型为 [P]poolLocal</span></span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span></span><br><span class="line"><span class="comment">// [P]poolLocal的大小</span></span><br><span class="line">localSize <span class="keyword">uintptr</span>        <span class="comment">// size of the local array</span></span><br><span class="line"></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">victimSize <span class="keyword">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的对象创建回调函数，当 pool 中无可用对象时会调用此函数</span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Pool 不希望被复制，所以结构体里有一个 noCopy 的字段，使用 <code>go vet</code> 工具可以检测到用户代码是否复制了 Pool。</p><blockquote><p><code>noCopy</code> 是 go1.7 开始引入的一个静态检查机制。它不仅仅工作在运行时或标准库，同时也对用户代码有效。 </p></blockquote><blockquote><p>用户只需实现这样的不消耗内存、仅用于静态分析的结构，来保证一个对象在第一次使用后不会发生复制。</p></blockquote><p>实现非常简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noCopy 用于嵌入一个结构体中来保证其第一次使用后不会被复制</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 见 https://golang.org/issues/8005#issuecomment-190753527</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock 是一个空操作用来给 `go vet` 的 -copylocks 静态分析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span> <span class="title">Lock</span><span class="params">()</span></span>   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针，<code>localSize</code> 则表示 local 数组的大小。访问时，P 的 id 对应 <code>[P]poolLocal</code> 下标索引。通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</p><p>在一轮 GC 到来时，victim 和 victimSize 会分别“接管” local 和 localSize。<code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑。</p><blockquote><p>Victim Cache 本来是计算机架构里面的一个概念，是 CPU 硬件处理缓存的一种技术，<code>sync.Pool</code> 引入的意图在于降低 GC 压力的同时提高命中率。</p></blockquote><p>当 Pool 没有缓存的对象时，调用 <code>New</code> 方法生成一个新的对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">poolLocalInternal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 poolLocal 补齐至两个缓存行的倍数，防止 false sharing,</span></span><br><span class="line"><span class="comment">// 每个缓存行具有 64 bytes，即 512 bit</span></span><br><span class="line"><span class="comment">// 目前我们的处理器一般拥有 32 * 1024 / 64 = 512 条缓存行</span></span><br><span class="line"><span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal</span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local per-P Pool appendix.</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// P 的私有缓存区，使用时无需要加锁</span></span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 公共缓存区。本地 P 可以 pushHead/popHead；其他 P 则只能 popTail</span></span><br><span class="line">shared  poolChain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段 <code>pad</code> 主要是防止 <code>false sharing</code>，董大的<a href="https://www.jianshu.com/p/dc4b5562aad2" target="_blank" rel="noopener">《什么是 cpu cache》</a>里讲得比较好：</p><blockquote><p>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。</p></blockquote><blockquote><p>程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><p><code>poolChain</code> 是一个双端队列的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 只有生产者会 push to，不用加锁</span></span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写需要原子控制。 pop from</span></span><br><span class="line">tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">poolDequeue</span><br><span class="line"></span><br><span class="line"><span class="comment">// next 被 producer 写，consumer 读。所以只会从 nil 变成 non-nil</span></span><br><span class="line"><span class="comment">// prev 被 consumer 写，producer 读。所以只会从 non-nil 变成 nil</span></span><br><span class="line">next, prev *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The head index is stored in the most-significant bits so</span></span><br><span class="line"><span class="comment">// that we can atomically add to it and the overflow is</span></span><br><span class="line"><span class="comment">// harmless.</span></span><br><span class="line"><span class="comment">// headTail 包含一个 32 位的 head 和一个 32 位的 tail 指针。这两个值都和 len(vals)-1 取模过。</span></span><br><span class="line"><span class="comment">// tail 是队列中最老的数据，head 指向下一个将要填充的 slot</span></span><br><span class="line">    <span class="comment">// slots 的有效范围是 [tail, head)，由 consumers 持有。</span></span><br><span class="line">headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vals 是一个存储 interface&#123;&#125; 的环形队列，它的 size 必须是 2 的幂</span></span><br><span class="line"><span class="comment">// 如果 slot 为空，则 vals[i].typ 为空；否则，非空。</span></span><br><span class="line"><span class="comment">// 一个 slot 在这时宣告无效：tail 不指向它了，vals[i].typ 为 nil</span></span><br><span class="line"><span class="comment">// 由 consumer 设置成 nil，由 producer 读</span></span><br><span class="line">vals []eface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。</p></blockquote><blockquote><p><code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p></blockquote><p>我们用一幅图来完整地描述 Pool 结构体：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125200.png" alt="Pool 结构体"></p><p>结合木白的技术私厨的<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487149&idx=1&sn=f38f2d72fd7112e19e97d5a2cd304430&source=41#wechat_redirect" target="_blank" rel="noopener">《请问sync.Pool有什么缺点?》</a>里的一张图，对于双端队列的理解会更容易一些：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/image-20190805225842592.png" alt="Pool 结构体"></p><p>我们看到 Pool 并没有直接使用 poolDequeue，原因是它的大小是固定的，而 Pool 的大小是没有限制的。因此，在 poolDequeue 之上包装了一下，变成了一个 <code>poolChainElt</code> 的双向链表，可以动态增长。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>直接上源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">l, pid := p.pin()</span><br><span class="line">x := l.private</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">x, _ = l.shared.popHead()</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.getSlow(pid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.New()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略号的内容是 <code>race</code> 相关的，属于阅读源码过程中的一些噪音，暂时注释掉。这样，Get 的整个过程就非常清晰了：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除非抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><p>我用一张流程图来展示整个过程：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418091935.png" alt="Get 流程图"></p><p>整体流程梳理完了，我们再来看一下其中的一些关键函数。</p><h3 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h3><p>先来看 <code>Pool.pin()</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方必须在完成取值后调用 runtime_procUnpin() 来取消抢占。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">s := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">l := p.local                          <span class="comment">// load-consume</span></span><br><span class="line"><span class="comment">// 因为可能存在动态的 P（运行时调整 P 的个数）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pin</code> 的作用就是将当前 groutine 和 P 绑定在一起，禁止抢占。并且返回对应的 poolLocal 以及 P 的 id。</p><p>如果 G 被抢占，则 G 的状态从 running 变成 runnable，会被放回 P 的 localq 或 globaq，等待下一次调度。下次再执行时，就不一定是和现在的 P 相结合了。因为之后会用到 pid，如果被抢占了，有可能接下来使用的 pid 与所绑定的 P 并非同一个。</p><p>“绑定”的任务最终交给了 <code>procPin</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procPin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line">mp := _g_.m</span><br><span class="line"></span><br><span class="line">mp.locks++</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(mp.p.ptr().id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的代码很简洁：将当前 goroutine 绑定的 m 上的一个锁字段 locks 值加 1，即完成了“绑定”。关于 pin 的原理，可以参考<a href="https://zhuanlan.zhihu.com/p/99710992" target="_blank" rel="noopener">《golang的对象池sync.pool源码解读》</a>，文章详细分析了为什么执行 <code>procPin</code> 之后，不可抢占，且 GC 不会清扫 Pool 里的对象。</p><p>我们再回到 <code>p.pin()</code>，原子操作取出 <code>p.localSize</code> 和 <code>p.local</code>，如果当前 <code>pid</code> 小于 <code>p.localSize</code>，则直接取 poolLocal 数组中的 pid 索引处的元素。否则，说明 Pool 还没有创建 poolLocal，调用 <code>p.pinSlow()</code> 完成创建工作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pinSlow</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Retry under the mutex.</span></span><br><span class="line"><span class="comment">// Can not lock the mutex while pinned.</span></span><br><span class="line">runtime_procUnpin()</span><br><span class="line">allPoolsMu.Lock()</span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line"><span class="comment">// poolCleanup won't be called while we are pinned.</span></span><br><span class="line"><span class="comment">// 没有使用原子操作，因为已经加了全局锁了</span></span><br><span class="line">s := p.localSize</span><br><span class="line">l := p.local</span><br><span class="line"><span class="comment">// 因为 pinSlow 中途可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查。 如果 pid 在 p.local 大小范围内，则不用创建 poolLocal 切片，直接返回。</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line"><span class="comment">// 当前 P 的数量</span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line"><span class="comment">// 旧的 local 会被回收</span></span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.localSize, <span class="keyword">uintptr</span>(size))         <span class="comment">// store-release</span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为要上一把大锁 <code>allPoolsMu</code>，所以函数名带有 <code>slow</code>。我们知道，锁粒度越大，竞争越多，自然就越“slow”。不过要想上锁的话，得先解除“绑定”，锁上之后，再执行“绑定”。原因是锁越大，被阻塞的概率就越大，如果还占着 P，那就浪费资源。</p><p>在解除绑定后，pinSlow 可能被其他的线程调用过了，p.local 可能会发生变化。因此这时候需要再次对 pid 进行检查。如果 pid 在 p.localSize 大小范围内，则不用再创建 poolLocal 切片，直接返回。</p><p>之后，根据 P 的个数，使用 make 创建切片，包含 <code>runtime.GOMAXPROCS(0)</code> 个 poolLocal，并且使用原子操作设置 p.local 和 p.localSize。</p><p>最后，返回 p.local 对应 pid 索引处的元素。</p><p>关于这把大锁 <code>allPoolsMu</code>，曹大在<a href="https://xargin.com/lock-contention-in-go/" target="_blank" rel="noopener">《几个 Go 系统可能遇到的锁问题》</a>里讲了一个例子。第三方库用了 <code>sync.Pool</code>，内部有一个结构体 <code>fasttemplate.Template</code>，包含 <code>sync.Pool</code> 字段。而 rd 在使用时，每个请求都会新建这样一个结构体。于是，处理每个请求时，都会尝试从一个空的 Pool 里取缓存的对象，最后 goroutine 都阻塞在了这把大锁上，因为都在尝试执行：<code>allPools = append(allPools, p)</code>，从而造成性能问题。</p><h3 id="popHead"><a href="#popHead" class="headerlink" title="popHead"></a>popHead</h3><p>回到 Get 函数，再来看另一个关键的函数：<code>poolChain.popHead()</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// There may still be unconsumed elements in the</span></span><br><span class="line"><span class="comment">// previous dequeue, so try backing up.</span></span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popHead</code> 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 popHead 方法。注意这两个 popHead 方法实际上并不相同，一个是 <code>poolChain</code> 的，一个是 <code>poolDequeue</code> 的，有疑惑的，不妨回头再看一下 Pool 结构体的图。我们来看 <code>poolDequeue.popHead()</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/local/go/src/sync/poolqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popHead</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> slot *eface</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;</span><br><span class="line"><span class="comment">// Queue is empty.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 位置是队头的前一个位置，所以此处要先退一位。</span></span><br><span class="line"><span class="comment">// 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制</span></span><br><span class="line">head--</span><br><span class="line">ptrs2 := d.pack(head, tail)</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line"><span class="comment">// We successfully took back slot.</span></span><br><span class="line">slot = &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 val</span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))</span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">val = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置 slot，typ 和 val 均为 nil</span></span><br><span class="line"><span class="comment">// 这里清空的方式与 popTail 不同，与 pushHead 没有竞争关系，所以不用太小心</span></span><br><span class="line">*slot = eface&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 <code>unpack</code> 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 <code>nil，false</code>。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 <code>pack</code> 打包 head 和 tail 指针。使用 <code>atomic.CompareAndSwapUint64</code> 比较 headTail 在这之间是否有变化，如果没变化，相当于获取到了这把锁，那就更新 headTail 的值。并且把 vals 相应索引处的元素赋值给 slot。</p><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 相与，实际就是取 head 低 n 位的值。</p><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/local/go/src/sync/poolqueue.go</span></span><br><span class="line"><span class="comment">// 因为使用 nil 代表空的 slots，因此使用 dequeueNil 表示 interface&#123;&#125;(nil)</span></span><br><span class="line"><span class="keyword">type</span> dequeueNil *<span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>最后，返回 val 之前，将 slot “归零”：<code>*slot = eface{}</code>。</p><p>回到 <code>poolChain.popHead()</code>，调用 <code>poolDequeue.popHead()</code> 拿到缓存的对象后，直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h3 id="getSlow"><a href="#getSlow" class="headerlink" title="getSlow"></a>getSlow</h3><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">// See the comment in pin regarding ordering of the loads.</span></span><br><span class="line">size := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">locals := p.local                        <span class="comment">// load-consume</span></span><br><span class="line"><span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line"><span class="comment">// 从其他 P 中窃取对象</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从victim cache中取对象。这发生在尝试从其他 P 的 poolLocal 偷去失败后，</span></span><br><span class="line"><span class="comment">// 因为这样可以使 victim 中的对象更容易被回收。</span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">locals = p.victim</span><br><span class="line">l := indexLocal(locals, pid)</span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 victim cache。下次就不用再从这里找了</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h3 id="popTail"><a href="#popTail" class="headerlink" title="popTail"></a>popTail</h3><p>最后，还剩一个 popTail 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 双向链表只有一个尾节点，现在为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的尾节点里的双端队列被“掏空”，所以继续看下一个节点。</span></span><br><span class="line"><span class="comment">// 并且由于尾节点已经被“掏空”，所以要甩掉它。这样，下次 popHead 就不会再看它有没有缓存对象了。</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line"><span class="comment">// 甩掉尾节点</span></span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">d = d2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for</code> 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 <code>c.tail</code> 更新为 <code>d2</code>，可以防止下次 <code>popTail</code> 的时候查看一个空的 <code>dequeue</code>；而将 <code>d2.prev</code> 设置为 <code>nil</code>，可以防止下次 <code>popHead</code> 时查看一个空的 <code>dequeue</code>。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/poolqueue.go:147</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">popTail</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> slot *eface</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="comment">// 判断队列是否空</span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;</span><br><span class="line"><span class="comment">// Queue is empty.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先搞定 head 和 tail 指针位置。如果搞定，那么这个 slot 就归属我们了</span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line"><span class="comment">// Success.</span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We now own slot.</span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))</span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">val = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slot.val = <span class="literal">nil</span></span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// At this point pushHead owns the slot.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>popTail</code> 从队列尾部移除一个元素，如果队列为空，返回 false。此函数可能同时被多个<code>消费者</code>调用。</p><p>函数的核心是一个无限循环，又是一个无锁编程。先解出 head，tail 指针值，如果两者相等，说明队列为空。</p><p>因为要从尾部移除一个元素，所以 tail 指针前进 1，然后使用原子操作设置 headTail。</p><p>最后，将要移除的 slot 的 val 和 typ “归零”：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slot.val = <span class="literal">nil</span></span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 将对象添加到 Pool </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">l, _ := p.pin()</span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = x</span><br><span class="line">x = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.shared.pushHead(x)</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">    <span class="comment">//…… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样删掉了 race 相关的函数，看起来清爽多了。整个 Put 的逻辑也很清晰：</p><ol><li><p>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</p></li><li><p>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。</p></li></ol><p>同样用流程图来展示整个过程：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200418092028.png" alt="Put 流程图"></p><h3 id="pushHead"><a href="#pushHead" class="headerlink" title="pushHead"></a>pushHead</h3><p>我们来看 <code>pushHead</code> 的源码，比较清晰：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span> <span class="title">pushHead</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">d := c.head</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// poolDequeue 初始长度为8</span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2</span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">c.head = d</span><br><span class="line">storePoolChainElt(&amp;c.tail, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前一个 poolDequeue 长度的 2 倍</span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line"><span class="comment">// Can't make it any bigger.</span></span><br><span class="line">newSize = dequeueLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首尾相连，构成链表</span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;</span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">c.head = d2</span><br><span class="line">storePoolChainElt(&amp;d.next, d2)</span><br><span class="line">d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dequeueBits = <span class="number">32</span></span><br><span class="line"><span class="keyword">const</span> dequeueLimit = (<span class="number">1</span> &lt;&lt; dequeueBits) / <span class="number">4</span></span><br></pre></td></tr></table></figure><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 val 添加到双端队列头部。如果队列已满，则返回 false。此函数只能被一个生产者调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pushHead</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">head, tail := d.unpack(ptrs)</span><br><span class="line"><span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line"><span class="comment">// 队列满了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测这个 slot 是否被 popTail 释放</span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 另一个 groutine 正在 popTail 这个 slot，说明队列仍然是满的</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The head slot is free, so we own it.</span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slot占位，将val存入vals中</span></span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 增加 1</span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断队列是否已满：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tail+<span class="keyword">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line"><span class="comment">// Queue is full.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将尾部指针加上 <code>d.vals</code> 的长度，再取低 31 位，看它是否和 head 相等。我们知道，<code>d.vals</code> 的长度实际上是固定的，因此如果队列已满，那么 if 语句的两边就是相等的。如果队列满了，直接返回 false。</p><p>否则，队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if the head slot has been released by popTail.</span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so</span></span><br><span class="line"><span class="comment">// the queue is actually still full.</span></span><br><span class="line"><span class="comment">// popTail 是先设置 val，再将 typ 设置为 nil。设置完 typ 之后，popHead 才可以操作这个 slot</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段用来判断是否和 popTail 有冲突发生，如果有，则直接返回 false。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slot占位，将val存入vals中</span></span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val</span><br></pre></td></tr></table></figure><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h2 id="pack-unpack"><a href="#pack-unpack" class="headerlink" title="pack/unpack"></a>pack/unpack</h2><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/poolqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dequeueBits = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">pack</span><span class="params">(head, tail <span class="keyword">uint32</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint64</span>(head) &lt;&lt; dequeueBits) |</span><br><span class="line"><span class="keyword">uint64</span>(tail&amp;mask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mask</code> 的低 31 位为全 1，其他位为 0，它和 tail 相与，就是只看 tail 的低 31 位。而 head 向左移 32 位之后，低 32 位为全 0。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</p><p>相应的解绑函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span> <span class="title">unpack</span><span class="params">(ptrs <span class="keyword">uint64</span>)</span> <span class="params">(head, tail <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line">head = <span class="keyword">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)</span><br><span class="line">tail = <span class="keyword">uint32</span>(ptrs &amp; mask)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。</p><blockquote><p>几乎所有的池技术中，都会在某个时刻清空或清除部分缓存对象，那么在 Go 中何时清理未使用的对象呢？</p></blockquote><p>答案是 GC 发生时。</p><p>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sync/pool.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在背后做了一些动作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/mgc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooks for other packages</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 利用编译器标志将 <span class="title">sync</span> 包中的清理注册到运行时</span></span><br><span class="line"><span class="function">//<span class="title">go</span>:<span class="title">linkname</span> <span class="title">sync_runtime_registerPoolCleanup</span> <span class="title">sync</span>.<span class="title">runtime_registerPoolCleanup</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">poolcleanup = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来看下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">p.victim = <span class="literal">nil</span></span><br><span class="line">p.victimSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">p.victim = p.local</span><br><span class="line">p.victimSize = p.localSize</span><br><span class="line">p.local = <span class="literal">nil</span></span><br><span class="line">p.localSize = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>poolCleanup</code> 会在 STW 阶段被调用。整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><blockquote><p>如果 <code>sync.Pool</code> 的获取、释放速度稳定，那么就不会有新的池对象进行分配。如果获取的速度下降了，那么对象可能会在两个 <code>GC</code> 周期内被释放，而不是以前的一个 <code>GC</code> 周期。</p></blockquote><blockquote><p>鸟窝的<a href="https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/" target="_blank" rel="noopener">【Go 1.13中 sync.Pool 是如何优化的?】</a>讲了 1.13 中的优化。</p></blockquote><p>参考资料<a href="https://zhuanlan.zhihu.com/p/110140126" target="_blank" rel="noopener">【理解 Go 1.13 中 sync.Pool 的设计与实现】</a> 手动模拟了一下调用 <code>poolCleanup</code> 函数前后 oldPools，allPools，p.vitcim 的变化过程，很精彩：</p><blockquote><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。</li></ol></blockquote><p>我根据这个流程画了一张图，可以理解地更清晰一些：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200416125040.png" alt="poolCleanup 过程"></p><p>需要指出的是，<code>allPools</code> 和 <code>oldPools</code> 都是切片，切片的元素是指向 Pool 的指针，Get/Put 操作不需要通过它们。在第 6 步，如果还有其他 Pool 执行了 Put 操作，<code>allPools</code> 这时就会有多个元素。</p><p>在 Go 1.13 之前的实现中，<code>poolCleanup</code> 比较“简单粗暴”：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        allPools[i] = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(p.localSize); i++ &#123;</span><br><span class="line">            l := indexLocal(p.local, i)</span><br><span class="line">            l.private = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="keyword">range</span> l.shared &#123;</span><br><span class="line">                l.shared[j] = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            l.shared = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    allPools = []*Pool&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接清空了所有 Pool 的 <code>p.local</code> 和 <code>poolLocal.shared</code>。</p><blockquote><p>通过两者的对比发现，新版的实现相比 Go 1.13 之前，GC 的粒度拉大了，由于实际回收的时间线拉长，单位时间内 GC 的开销减小。</p></blockquote><blockquote><p>由此基本明白 p.victim 的作用。它的定位是次级缓存，GC 时将对象放入其中，下一次 GC 来临之前如果有 Get 调用则会从 p.victim 中取，直到再一次 GC 来临时回收。</p></blockquote><blockquote><p>同时由于从 p.victim 中取出对象使用完毕之后并未放回 p.victim 中，在一定程度也减小了下一次 GC 的开销。原来 1 次 GC 的开销被拉长到 2 次且会有一定程度的开销减小，这就是 p.victim 引入的意图。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/110140126" target="_blank" rel="noopener">【理解 Go 1.13 中 sync.Pool 的设计与实现】</a> 这篇文章最后还总结了 <code>sync.Pool</code> 的设计理念，包括：无锁、操作对象隔离、原子操作代替锁、行为隔离——链表、Victim Cache 降低 GC 开销。写得非常不错，推荐阅读。</p><p>另外，关于 <code>sync.Pool</code> 中锁竞争优化的文章，推荐阅读芮大神的<a href="http://xiaorui.cc/archives/5878" target="_blank" rel="noopener">【优化锁竞争】</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文先是介绍了 Pool 是什么，有什么作用，接着给出了 Pool 的用法以及在标准库、一些第三方库中的用法，还介绍了 pool_test 中的一些测试用例。最后，详细解读了 <code>sync.Pool</code> 的源码。</p><p>本文的结尾部分，再来详细地总结一下关于 <code>sync.Pool</code> 的要点：</p><ol><li><p>关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p><code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>Go 语言内置的 fmt 包，encoding/json 包都可以看到 sync.Pool 的身影；<code>gin</code>，<code>Echo</code> 等框架也都使用了 sync.Pool。</p></li><li><p>不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li><li><p>Pool 不可以指定⼤⼩，⼤⼩只受制于 GC 临界值。</p></li><li><p><code>procPin</code> 将 G 和 P 绑定，防止 G 被抢占。在绑定期间，GC 无法清理缓存的对象。</p></li><li><p>在加入 <code>victim</code> 机制前，sync.Pool 里对象的最⼤缓存时间是一个 GC 周期，当 GC 开始时，没有被引⽤的对象都会被清理掉；加入 <code>victim</code> 机制后，最大缓存时间为两个 GC 周期。</p></li><li><p>Victim Cache 本来是计算机架构里面的一个概念，是 CPU 硬件处理缓存的一种技术，<code>sync.Pool</code> 引入的意图在于降低 GC 压力的同时提高命中率。</p></li><li><p><code>sync.Pool</code> 的最底层使用切片加链表来实现双端队列，并将缓存的对象存储在切片中。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【欧神 源码分析】<a href="https://changkun.us/archives/2018/09/256/" target="_blank" rel="noopener">https://changkun.us/archives/2018/09/256/</a></p><p>【Go 夜读】<a href="https://reading.hidevops.io/reading/20180817/2018-08-17-sync-pool-reading.pdf" target="_blank" rel="noopener">https://reading.hidevops.io/reading/20180817/2018-08-17-sync-pool-reading.pdf</a></p><p>【夜读第 14 期视频】<a href="https://www.youtube.com/watch?v=jaepwn2PWPk&amp;list=PLe5svQwVF1L5bNxB0smO8gNfAZQYWdIpI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jaepwn2PWPk&amp;list=PLe5svQwVF1L5bNxB0smO8gNfAZQYWdIpI</a></p><p>【源码分析，伪共享】<a href="https://juejin.im/post/5d4087276fb9a06adb7fbe4a" target="_blank" rel="noopener">https://juejin.im/post/5d4087276fb9a06adb7fbe4a</a></p><p>【golang的对象池sync.pool源码解读】<a href="https://zhuanlan.zhihu.com/p/99710992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/99710992</a></p><p>【理解 Go 1.13 中 sync.Pool 的设计与实现】<a href="https://zhuanlan.zhihu.com/p/110140126" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110140126</a></p><p>【优缺点，图】<a href="http://cbsheng.github.io/posts/golang%E6%A0%87%E5%87%86%E5%BA%93sync.pool%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/golang%E6%A0%87%E5%87%86%E5%BA%93sync.pool%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</a></p><p>【xiaorui 优化锁竞争】<a href="http://xiaorui.cc/archives/5878" target="_blank" rel="noopener">http://xiaorui.cc/archives/5878</a></p><p>【性能优化之路，自定义多种规格的缓存】<a href="https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool" target="_blank" rel="noopener">https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool</a></p><p>【sync.Pool 有什么缺点】<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487149&amp;idx=1&amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487149&amp;idx=1&amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;source=41#wechat_redirect</a></p><p>【1.12 和 1.13 的演变】<a href="https://github.com/watermelo/dailyTrans/blob/master/golang/sync_pool_understand.md" target="_blank" rel="noopener">https://github.com/watermelo/dailyTrans/blob/master/golang/sync_pool_understand.md</a></p><p>【董泽润 演进】<a href="https://www.jianshu.com/p/2e08332481c5" target="_blank" rel="noopener">https://www.jianshu.com/p/2e08332481c5</a></p><p>【noCopy】<a href="https://github.com/golang/go/issues/8005#issuecomment-190753527" target="_blank" rel="noopener">https://github.com/golang/go/issues/8005#issuecomment-190753527</a></p><p>【董泽润 cpu cache】<a href="https://www.jianshu.com/p/dc4b5562aad2" target="_blank" rel="noopener">https://www.jianshu.com/p/dc4b5562aad2</a></p><p>【gomemcache 例子】<a href="https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter16/16.01.html" target="_blank" rel="noopener">https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter16/16.01.html</a></p><p>【鸟窝 1.13 优化】<a href="https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/" target="_blank" rel="noopener">https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</a></p><p>【A journey with go】<a href="https://medium.com/a-journey-with-go/go-understand-the-design-of-sync-pool-2dde3024e277" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-understand-the-design-of-sync-pool-2dde3024e277</a></p><p>【封装了一个计数组件】<a href="https://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/" target="_blank" rel="noopener">https://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/</a></p><p>【伪共享】<a href="http://ifeve.com/falsesharing/" target="_blank" rel="noopener">http://ifeve.com/falsesharing/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在工作中碰到了 GC 的问题：项目中大量重复地创建许多对象，造成 GC 的工作量巨大，CPU 频繁掉底。准备使用 &lt;code&gt;sync.Pool&lt;/code&gt; 来缓存对象，减轻 GC 的消耗。为了用起来更顺畅，我特地研究了一番，形成此文。本文从使用到源码解析，循序渐进，
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 g0</title>
    <link href="https://qcrao.com/2020/04/03/talk-about-g0/"/>
    <id>https://qcrao.com/2020/04/03/talk-about-g0/</id>
    <published>2020-04-03T07:27:15.000Z</published>
    <updated>2020-04-03T07:27:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候，当我们跟着源码去理解某种事物时，基本上可以认为是以时间顺序展开，这是编年体的逻辑。还有另一种逻辑，纪传体，它以人物为中心编排史事，使得读者更聚焦于某个人物。以一种新的视角，把所有的事情串连起来，令人大呼过瘾。今天我们试着以这样一种逻辑再看 g0。</p><p>回顾一下 Go 夜读<a href="https://mp.weixin.qq.com/s/Yr4L2pt-__CK7Q7JVz_guw" target="_blank" rel="noopener">第 78 期</a>，关于调度器源码分析的内容。我们讲过，与主线程绑定的 M 对应的 g0 的主要作用是提供一个比一般 goroutine 要大的多栈（64K）供 runtime 代码执行。</p><p>初始化的过程中，在函数 <code>runtime·rt0_go</code> 里会给主线程的 g0 分配栈空间：</p><p><img src="https://user-images.githubusercontent.com/7698088/64071133-d400c080-cca5-11e9-8563-d5f882e34e0a.png" alt="g0 栈空间"></p><p>之后，主线程会与 m0 绑定，m0 又与 g0 绑定：</p><p><img src="https://user-images.githubusercontent.com/7698088/75735730-54c47600-5d36-11ea-912a-7ab8dcbda1dc.png" alt="主线程绑定 m0，g0"></p><p>之后，又与 p0 绑定：</p><p><img src="https://user-images.githubusercontent.com/7698088/64071128-97cd6000-cca5-11e9-95a9-344f2a0a6474.png" alt="g0-p0-m0"></p><p>这样，主线程的这一套 GPM 就可以转起来了。接着，就创建了 main goroutine，放入 p0 的本地待运行队列。最后，通过 <code>schedule()</code> 函数进入调度循环。</p><p>前面说的是程序初始化的过程中，g0 是如何诞生的。当执行到 <code>main.main()</code> 函数，也说是用户在 main 包下写的 main 函数里，我们随手一句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 要做的事</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>就启动了一个 goroutine 时，在 Go 编译器的作用下，最终会转化成 newproc 函数。在 newproc 函数的内部，会在 g0 栈上调用 <code>newproc1</code> 函数，完成后续的工作。创建完成后，会将新创建的 goroutine 放入 <code>_p_</code> 的本地待运行队列。</p><p>因为新增加了一个 g，这时会尝试去唤醒一个 P 来一起执行任务。判断条件是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即在有空闲 P 以及没有正在“找工作的 M”的情况下，才会尝试去唤醒一个 P。我们又知道，其实 P 的数量在程序运行过程中一般不会变化，所以这里所谓的唤醒其实就是把空闲的 P 利用起来。</p><p>通过 <code>wakep() -&gt; startm() -&gt; newm() -&gt; allocm() -&gt; malg()</code> 这条链路创建 g0，这里 g0 的栈大小实际上为 <code>8KB</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier) <span class="comment">// sys.StackGuardMultiplier 在 linux 里为 1</span></span><br></pre></td></tr></table></figure><p><code>g0</code> 作为一个特殊的 goroutine，为 scheduler 执行调度循环提供了场地（栈）。对于一个线程来说，g0 总是它第一个创建的 goroutine。之后，它会不断地寻找其他普通的 goroutine 来执行，直到进程退出。</p><p>当需要执行一些任务，且不想扩栈时，就可以用到 g0 了，因为 g0 的栈比较大。g0 其他的一些“职责”有：创建 goroutine、deferproc 函数里新建 _defer、垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。</p><p>因为 g0 这样一个特殊的 goroutine 所做的工作，使得 Go 程序运行地更快。</p><p>注：最近在 medium 上看到了一个非常赞的关于 Go 的<a href="https://medium.com/a-journey-with-go" target="_blank" rel="noopener">博客</a>，题图画得很有阅读的欲望。这篇文章也是参考于<a href="https://medium.com/a-journey-with-go/go-g0-special-goroutine-8c778c6704d8" target="_blank" rel="noopener">其中的一篇</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候，当我们跟着源码去理解某种事物时，基本上可以认为是以时间顺序展开，这是编年体的逻辑。还有另一种逻辑，纪传体，它以人物为中心编排史事，使得读者更聚焦于某个人物。以一种新的视角，把所有的事情串连起来，令人大呼过瘾。今天我们试着以这样一种逻辑再看 g0。&lt;/p&gt;
&lt;p&gt;回
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>defer 链表如何被遍历执行</title>
    <link href="https://qcrao.com/2020/03/23/how-to-traverse-defer-links/"/>
    <id>https://qcrao.com/2020/03/23/how-to-traverse-defer-links/</id>
    <published>2020-03-23T01:32:16.000Z</published>
    <updated>2020-03-30T02:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年开始写文章的第一篇就是关于 defer，名字比较文艺：<a href="https://mp.weixin.qq.com/s/txj7jQNki_8zIArb9kSHeg" target="_blank" rel="noopener">《Golang 之轻松化解 defer 的温柔陷阱》</a>，还被吐槽了。因为这篇文章，到《Go 夜读》讲了一期。不过当时纯粹是应用层面的，也还没有跳进 Go 源码这个大坑，文章看着比较清新，也没有大段的源码解析。</p><p>自从听了曹大在《Go 夜读》分享的 Go 汇编，以及研读了阿波张的 Go 调度器源码分析的文章后，各种源码、汇编满天飞……</p><p>上次欧神写了一篇<a href="https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q" target="_blank" rel="noopener">《Go GC 20 问》</a>，全文也没有一行源码，整体读下来很畅快。今天这篇也来尝试一下这种写法，不过，我们先从一个小的主题开始：defer 链表是如何被遍历并执行的。</p><p>关于 defer 的源码分析文章，网络上也有很多。不过，很少有能完全说明白这个话题的，除了阿波张的。</p><p>我们知道，为了在退出函数前执行一些资源清理的操作，例如关闭文件、释放连接等。会在函数里写上多个 defer 语句，被 defered 的函数，以“先进后出”的顺序，在 <code>RET</code> 指令前得以执行。</p><p>在一条函数调用链中，多个函数中会出现多个 defer 语句。例如：<code>a() -&gt; b() -&gt; c()</code> 中，每个函数里都有 defer 语句，而这些 defer 语句会创建对应个数的 <code>_defer</code> 结构体，这些结构体以链表的形式挂在 <code>goroutine</code> 结构体下。看起来像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200321185857.png" alt="defer 挂在 g 上"></p><p>在编译器的加持下，defer 语句会先调用 deferporc 函数，new 一个 <code>_defer</code> 结构体，挂到 g 上。当然，这里的 new 会优先从当前绑定的 P 的 defer pool 里取，没取到会去全局的 defer pool 里取，实在没有的话就新建一个，很熟悉的套路。</p><p>这样做好之后，等待函数体执行完，在 RET 指令之前（注意不是 return 之前），调用 <code>deferreturn</code> 函数完成 <code>_defer</code> 链表的遍历，执行完这条链上所有被 <code>defered</code> 的函数（如关闭文件、释放连接等）。这里的问题是在 <code>deferreturn</code> 函数的最后，会使用 <code>jmpdefer</code> 跳转到之前被 defered 的函数，这时控制权转移到了用户自定义的函数。这只是执行了一个被 defered 的函数，这条链上其他的被 defered 的函数，该如何得到执行呢？</p><p>答案就是控制权会再次交给 runtime，并再次执行 deferreturn 函数，完成 defer 链表的遍历。那这一切是如何完成的呢？</p><p>这就要从 Go 汇编的栈帧说起了。先看一个汇编函数的声明：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br></pre></td></tr></table></figure><p>最后两个数字表示 gogo 函数的栈帧大小为 16B，即函数的局部变量和为调用子函数准备的参数和返回值需要 16B 的栈空间；参数和返回值的大小加起来是 8B。实际上 gogo 函数的声明是这样的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func gogo(buf *gobuf)</span></span><br></pre></td></tr></table></figure><p>参数及返回值的大小是给调用者“看”的，调用者根据这个数字可以构造栈：准备好被调函数需要的参数及返回值。</p><p>典型的函数调用场景下参数布局图如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213247.png" alt="函数调用参数布局"></p><p>左图中，主调函数准备好调用子函数的参数及返回值，执行 <code>CALL</code> 指令，将返回地址压入栈顶，相当于执行了 <code>PUSH IP</code>，之后，将 BP 寄存器的值入栈，相当于执行了 <code>PUSH BP</code>，再 jmp 到被调函数。</p><p>图中 <code>return address</code> 表示子函数执行完毕后，返回到上层函数中调用子函数语句的下一条要执行的指令，它属于 caller 的栈帧。而调用者的 BP 则属于被调函数的栈帧。</p><p>子函数执行完毕后，执行 <code>RET</code> 指令：首先将子函数栈底部的值赋到 CPU 的 BP 寄存器中，于是 BP 指向上层函数的 BP；再将 <code>return address</code> 赋到 IP 寄存器中，这时 SP 回到左图所示的位置。相当于还原了整个调用子函数的现场，像是一切都没发生过；接着，CPU 继续执行 IP 寄存器里的下一条指令。</p><p>再回到 defer 上来，其实在构造 <code>_defer</code> 结构体的时候，需要将当前函数的 SP、被 defered 的函数指针保存到 <code>_defer</code> 结构体中。并且会将被 defered 的函数所需要的参数 copy 到 _defer 结构体相邻的位置。最终在调用被 defered 的函数的时候，用的就是这时被 copy 的值，相当于使用了它的一个快照，如果此参数不是指针或引用类型的话，会产生一些意料之外的 bug。</p><p>最后，在 deferreturn 函数里，这些被 defered 的函数得以执行，<code>_defer</code> 链表也会被逐渐“消耗”完。</p><p>使用一个阿波张<a href="https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g" target="_blank" rel="noopener">文章</a>中的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Println(<span class="string">"sum:"</span> , c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> sum(a, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"a: %d, b: %d\n"</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    f(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完 <code>f</code> 函数时，最终会进入 deferreturn 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> d.siz &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Do nothing.</span></span><br><span class="line"><span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz)) <span class="comment">// 移动参数</span></span><br><span class="line">&#125;</span><br><span class="line">fn := d.fn</span><br><span class="line">d.fn = <span class="literal">nil</span></span><br><span class="line">gp._defer = d.link</span><br><span class="line">freedefer(d)</span><br><span class="line"></span><br><span class="line">_ = fn.fn</span><br><span class="line">jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>免不了还是要看一下代码，不然的话很难讲清楚。</p><p>因为我们是在遍历 <code>_defer</code> 链表，所以得有一个终止的条件：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是当 _defer 链表为空的时候，终止遍历。在后面的代码里会看到，每执行完一个被 defered 的函数后，都会将 _defer 结构体从链表中删除并回收，所以 _defer 链表会越来越短。</p><p><code>switch</code> 语句里要做的就是准备好被 defered 的函数（例子中就是 sum 函数）所需要的 a，b 两个 int 型参数。参数从哪来呢？从 _defer 结构体相邻的位置，还记得吗，这是在 deferproc 函数里 copy 过去的。<code>deferArgs(d)</code> 返回的就是当时 copy 的目的地址。那现在要拷贝到哪去呢？答案是：<code>unsafe.Pointer(&amp;arg0)</code>。我们知道，arg0 是 deferreturn 函数的参数，我们又知道，在 Go 汇编中，一个函数的参数是由它的主调函数准备的。因此 arg0 的地址实际上就是它的上层函数（在这里就是 f 函数）的栈上放参数的位置。</p><p>函数的最后，通过 <code>jmpdefer</code> 跳转到被 defered 的 sum 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br></pre></td></tr></table></figure><p>核心在于 jmpdefer 所做的事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16</span><br><span class="line">    MOVQfv+0(FP), DX// fn // defer 的函数的地址</span><br><span class="line">    MOVQargp+8(FP), BX</span><br><span class="line">    LEAQ-8(BX), SP// caller sp after CALL</span><br><span class="line">    MOVQ-8(SP), BP// restore BP as if deferreturn returned (harmless if framepointers not in use)</span><br><span class="line">    SUBQ$5, (SP)// return to CALL again</span><br><span class="line">    MOVQ0(DX), BX</span><br><span class="line">    JMPBX// but first run the deferred function</span><br></pre></td></tr></table></figure><p>首先将 sum 函数的地址放到 DX 寄存器中，最后通过 JMP 指令去执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVQargp+8(FP), BX</span><br><span class="line">LEAQ-8(BX), SP// caller sp after CALL // 执行 CALL 指令后 f 函数的栈顶</span><br></pre></td></tr></table></figure><p>这两行实际上是调整了下当前 SP 寄存器的值，因为 argp+8(FP) 实际上是 jmpdefer 的第二个参数（它在 deferreturn 函数中），它指向 f 函数栈帧中的刚被 copy 过来的 sum 函数的参数。而 <code>-8(BX)</code> 就代表了 f 函数调用 deferreturn 的返回地址，实际上就是 deferreturn 函数的下一条指令地址。</p><p>接着，<code>MOVQ    -8(SP), BP</code> 这条指令则重置了 BP 寄存器，使它指向了 f 栈帧 的 BP。这样，SP、BP 寄存器回到了 f 函数调用 deferreturn 之前的状态：f 刚准备好调用 deferreturn 的参数，并且把返回值压栈了。相当于抛弃了 deferreturn 函数的栈帧，不过，确实也没什么用了。</p><p>接着 <code>SUBQ    $5, (SP)</code> 把返回地址减少了 5B，刚好是一个 CALL 指令的长度。什么意思？当执行完 deferreturn 函数之后，执行流程会返回到 <code>CALL deferreturn</code> 的下一条指令，将这个值减少 5B，也就又回到了 <code>CALL deferreturn</code> 指令，从而实现了“递归地”调用 deferreturn 函数的效果。当然，栈却不会在增长！</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213332.png" alt="执行 jmpdefer"></p><p><code>jmpdefer</code> 函数的最后会执行 sum 函数，看起来就像是 f 函数亲自调用 sum 函数一样，参数、返回值都是就绪的。</p><p>等到 sum 函数执行完，执行流程就会跳转到 <code>call deferreturn</code> 指令处重新进入 deferreturn 函数，遍历完所有的 _defer 结构体，执行完所有的被 defered 的函数，才真正执行完 deferretrun 函数。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322213438.png" alt="重新调用 deferreturn"></p><p>到这里，全文就结束了。我们可以看到，实现遍历 defer 链表的关键就是 jmpdefer 函数所做的一些“见不得人”的工作，将调用 deferreturn 函数的返回地址减少了 5 个字节，使得被 defered 的函数执行完后，又回到 <code>CALL deferreturn</code> 指令处，从而实现“递归地”调用 deferreturn 函数，完成 _defer 链表的遍历。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【阿波张 defer 源码分析】<a href="https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g</a></p><p>【阿波张 panic&amp;recover】<a href="https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw</a></p><p>【阿波张 defer 基础】<a href="https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw</a></p><p>【汇编分析】<a href="https://segmentfault.com/a/1190000019804120?utm_medium=referral&amp;utm_source=tuicool" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019804120?utm_medium=referral&amp;utm_source=tuicool</a></p><p>【曹大 Go 汇编分享】<a href="https://github.com/cch123/asmshare/blob/master/layout.md" target="_blank" rel="noopener">https://github.com/cch123/asmshare/blob/master/layout.md</a></p><p>【曹大 Go 汇编】<a href="https://xargin.com/plan9-assembly" target="_blank" rel="noopener">https://xargin.com/plan9-assembly</a></p><p>【曹大利用汇编写的 goid 获取】<a href="https://github.com/cch123/goroutineid" target="_blank" rel="noopener">https://github.com/cch123/goroutineid</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年开始写文章的第一篇就是关于 defer，名字比较文艺：&lt;a href=&quot;https://mp.weixin.qq.com/s/txj7jQNki_8zIArb9kSHeg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Golang 之轻松化解 def
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>《高性能 MySQL》读书笔记</title>
    <link href="https://qcrao.com/2020/03/08/high-performance-mysql-reading-notes/"/>
    <id>https://qcrao.com/2020/03/08/high-performance-mysql-reading-notes/</id>
    <published>2020-03-08T11:17:23.000Z</published>
    <updated>2020-05-10T14:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>MySQL 的灵活性体现在很多方面，但其中最与众不同的特性是它的存储引擎架构：将查询处理以及其他系统任务和数据的存储/提取相分离。这种设计使得我们可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。</p><p>MySQL 架构整体上分为三层：第一层处理连接、权限等；第二层包含所有核心的功能，例如，查询解析、分析、优化、缓存、所有的内置函数，存储过程、触发器、视图等等。第三层则是存储引擎。服务器通过包含几十个底层函数的存储引擎 API 来与存储引擎通信，API 可以屏蔽不同存储引擎的差异，使得对上层的查询过程透明。架构如下图：</p><p><img src="https://user-images.githubusercontent.com/7698088/73418129-71474a00-4355-11ea-98f9-afcfe96ff973.png" alt="MySQL 架构"></p><p>整个 MySQL 程序包括客户端和服务端，客户端和服务端通过网络进行通信。当某个客户端和服务端建立连接后，就会在服务器进程中拥有一个线程。使用线程池可以避免频繁地创建和销毁线程。</p><p>MySQL 会将一条查询语句解析成内部数据结构——解析树，然后对其进行优化：重写查询、决定表的读取顺序、选择合适的索引等。对于 Select 语句，会用整个查询语句作为 Key，去缓存中查询处理结果。</p><p>关于并发控制。MySQL 会在两个层面来进行：服务器层、存储引擎层。最经典的解决方案就是锁机制，它通过两种类型的锁组成锁系统：共享锁（读锁）、排它锁（写锁）。锁的粒度会决定系统的并发度。一种提高共享资源的并发性的方法就是让锁更具有选择性，即只锁定需要修改的部分数据，而不是所有。在给定的资源上，锁定的数据量越少，则系统的并发程度越高。</p><p>另一方面，关于锁的操作：获得锁、检查锁是否解决、释放锁等都会增加系统的开销。因此锁策略就是在锁的开销和数据的安全性之间寻求平衡，既保证数据并发安全又能提高数据库的性能。各种数据库系统一般都是实现的行级锁。MySQL 的存储引擎可以实现自己的锁策略和锁粒度。</p><p>表锁是 MySQL 中开销最小、最基本的锁策略。尽管存储引擎可以管理自己的锁，但在执行诸如 <code>Alter table</code> 之类的语句时，服务器会忽略存储引擎的锁，而直接用表锁。</p><p>行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。行级锁只在存储引擎中实现，服务器层没有实现，行级锁对服务器是透明的。</p><p>关于事务。一个运行良好的事务处理系统，必须具备：</p><blockquote><p>原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）</p></blockquote><p>也就是常说的 <code>ACID 特性</code>。一一解释：</p><p><code>原子性</code>：一个事务中的所有操作，要么全部提交成功，要么全部失败回滚。<br><code>一致性</code>：数据库总是从一个一致性的状态转换到另一个一致性的状态。<br><code>隔离性</code>：通常来说，一个事务所做的修改在提交之前，对其他事务是不可见的。之所以说通常，因为这和事务的隔离级别是相关的。<br><code>持久性</code>：一旦事务提交，则其所做的修改会永久保存到数据库中。</p><p>在 SQL 标准中，定义了四种隔离级别，每种都规定了一个事务中所做的修改，哪些在事务内、事务间是可见的，哪些是不可见的。隔离级别越低，系统开销越小，并发越大。四种隔离级别如下：</p><p>未提交读（READ UNCOMMITTED）：一个事务可以读取其他事务未提交的修改，这也被称为“脏读”。实际中一般很少使用。</p><p>提交读（READ COMMITTED）：一个事务从开始到提交之前，所做的任何修改对其他事务是不可见的。这是大多数数据库系统的默认的事务隔离级别。这个级别也被称为<code>不可重复读</code>，因为在一个事务中，执行两次相同的查询，可能会得到不一样的结果。例如，第二次执行时，可以读到其他事务的提交。</p><p>可重复读（REPEATABLE READ）：同一个事务中，多次读取同样记录的结果是一致的。这是 MySQL 默认的事务隔离级别。另外，InnoDB 通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。</p><p>可串行化（SERIALIZABLE）：强制事务串行执行，解决了幻读的问题。由于需要在读取的每一行数据上都加锁，因此存在大量的超时和锁争用的问题。在实际中很少使用，只有在非常需要确保数据的一致性且可以接受没有并发的情况下，才考虑使用。</p><p><img src="https://user-images.githubusercontent.com/7698088/73434336-8639d280-4381-11ea-9020-a77d9899cf28.png" alt="事务隔离级别"></p><p><code>死锁</code>是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁；多个事务同时锁定同一个资源时，也会产生死锁。书中给出了一个例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/73434964-af0e9780-4382-11ea-8942-30c369a141e6.png" alt="死锁的例子"></p><p>当两个事务都同时执行完了第一条更新语句时，并锁定了该行。然后两个事务都去执行第二条语句，却发现已经被对方被锁定了。所以，这两个事务都在等待对方释放锁，并且同时持有对方需要的锁，陷入死循环。死锁发生后，只有部分或完全回滚其中一个事务，才能打破死锁。InnoDB 目前处理死锁的方法就是将持有最少行级排他锁的事务进行回滚。死锁的发生还和存储引擎的实现有关。</p><p>存储引擎在修改数据表时，只需要先修改表的内存拷贝，再通过事务日志将所做的修改顺序追加到磁盘上的事务日志中，而对数据表的修改可以在后台慢慢地刷回磁盘，这样提高了事务的执行效率。这种实现方式称为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p><p>MySQL 提供了两种支持事务的存储引擎：InnoDB 和 NDB Cluster；比较知名的第三方的存储引擎，如 XtraDB 和 PBXT 也支持事务。</p><p>MySQL 默认采用自动提交模式，即如果不显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。一些会导致大量数据改变的操作，如 <code>Alter Table</code>，<code>Lock Tables</code>（在服务层实现，和存储引擎无关） 等语句，在执行之前，会强制执行 commit 提交当前的活动事务。</p><p>MySQL 服务器层不管理事务，由底层的存储引擎实现事务。在同一个事务中，使用多种存储引擎是不可靠的。例如，在一个事务中混用了事务型和非事务型的表，非事务型表无法完成回滚操作，会导致数据库处于不一致的状态。</p><p><code>Lock Tables</code> 和 <code>UnLock Tables</code> 语句是在服务器层实现的，有自己的用途，不能代替事务处理。</p><p>关于 <code>MVCC</code>。它是行级锁的一个变种，在很多情况下避免了锁操作，因此开销更低。因为 MVCC 并没有一个统一的实现标准，所以不同库的实现机制有所不同，但都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 是通过保存数据在某个时间点的快照来实现的。不管事务执行多长时间，在一个事务中，它看到的数据都是一致的。而事务开始的时间不同，不同事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>InnoDB 实现的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现。一个保存了行的创建版本号（系统版本号，system version number），一个保存了行的过期（或删除）版本号。每开始一个事务，系统版本号会自动递增。事务开始时的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较。对于不同的命令，MVCC 的实现描述如下：</p><table><thead><tr><th>命令</th><th>操作</th></tr></thead><tbody><tr><td>select</td><td>a. 只查找版本早于（小于或等于）当前事务版本的数据行。b. 行的删除版本未定义或者大于当前事务版本号</td></tr><tr><td>insert</td><td>为新插入的每一行保存当前版本号作为版本号</td></tr><tr><td>delete</td><td>为删除的每一行保存当前版本号作为删除标识</td></tr><tr><td>update</td><td>插入新的一行，保存当前系统版本号作为版本号；同时将当前系统版本号保存到原来的行作为删除标识</td></tr></tbody></table><p>MVCC 只在可重复读（REPEATABLE READ）、提交读（READ COMMITTED）两个隔离级别下工作。因为 未提交读（READ UNCOMMITTED）总是读取最新的数据行，而不是符合当前事务版本的数据行；可串行化（SERIALIZABLE）则会对所有读取的行都加锁。</p><p>MVCC 多出的两列使得很多数据操作不用上锁，提升了性能；不足之处是需要额外的存储空间。</p><p>InnoDB 是 MySQL 的默认事务型存储引擎，也是最重要、使用最广泛的存储引擎。通过间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入，从而防止幻读。</p><p>一般情况下，都应该使用 InnoDB 存储引擎，除非需要用到某些 InnoDB 不具备的特性。另外，不要混合使用多种存储引擎。对存储引擎的选择，可以考虑以下几个因素：事务、备份、崩溃恢复、特有的特性。当然，还要根据具体的使用场景决定使用何种存储引擎。InnoDB 对于 95% 以上的用户都是最佳选择。</p><p>三种可以转换表的存储引擎的方法：<code>Alter Table</code>、<code>导出与导入</code>、<code>创建与查询</code>。</p><p>第一章主要从整体层面上讲了关于 MySQL 数据库的各个方面，这也是我第一次系统地学习 MySQL，很有收获。</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>选择正确的数据类型对于获得高性能至关重要，几个原则：</p><p><code>更小的通常更好</code>：尽量选择能正确存储数据的最小数据类型。<br><code>简单就好</code>：简单数据类型的操作通常需要更小的数据周期。例如，整型优于字符串，使用整型而非字符串来存储 ip。<br><code>尽量避免 NULL</code>：NULL 使得索引、索引统计、值比较都比较复杂；需要更多的存储空间；需要特殊处理。</p><p>关于数据类型，整理了一个思维导图：</p><p><img src="https://user-images.githubusercontent.com/7698088/73602178-5588b180-45aa-11ea-929b-59e020539d99.png" alt="数据类型"></p><p>设计表的时候有一些陷阱要避免：</p><ol><li>太多的列。</li><li>太多的关联。单个查询最好在 12 个表以内做关联。</li><li>全能的枚举。防止过度使用枚举。</li><li>变相的枚举。</li><li>非此发明的 NULL。避免使用 NULL，但也不要走极端。</li></ol><h2 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h2><p>在范式化的数据库中，每个事实数据都会出现并且只出现一次，相反，在反范式化的数据中，信息是冗余的，可能会存储在多个地方。</p><p>范式化的好处：</p><ul><li>范式化的更新操作通常比反范式化要快。</li><li>当数据较好地范式化时，只有很少或者没有重复数据，所以只需要修改更少的数据。</li><li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。</li><li>很少有多余的数据意味着检索列表数据时更少需要 <code>DISTINCT</code> 或者 <code>GROUP BY</code> 语句。</li></ul><p>范式化的缺点：</p><ul><li>范式化设计的 schema 的缺点是通常需要关联。</li><li>范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。</li></ul><p>反范式的优点：</p><ul><li>数据通常在一张表中，可以很好地避免关联。</li><li>单独的表也能使用更有效的索引策略。</li></ul><p>真实世界中，经常混用范式化和反范式化设计。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。实现上可以使用触发器更新缓存值，例如需要统计每个用户发了多少条消息，可以在 <code>user</code> 表中建一个 <code>num_messages</code> 列，每当用户发送消息时更新这个值。</p><h2 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h2><p>为了提升读查询的速度，经常会需要一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法虽然会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变慢了，同时还增加了读操作和写操作的开发难度，但是显著地提高了读操作的性能。</p><p>当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这就需要通过使用“影子表”来实现，“影子表”指的是一张在真实表“背后”创建的表。当完成了建表操作后，可以通过一个原子的重命名操作切换影子表和原表。</p><p>例如，需要重建 <code>my_summary</code>，可以先创建 <code>my_summary_new</code>，然后真充好数据，最后和真实表做切换：</p><p><img src="https://user-images.githubusercontent.com/7698088/74589333-50fad900-503f-11ea-8f6d-a75d70a0f739.png" alt="影子表"></p><p>在将 <code>my_summary</code> 这个名字分配给新建的表之前将原始的 <code>my_summary</code> 表重命名为 <code>my_summary_old</code>，就可以在下一次重建之前一直保留旧版本的数据。如果新表有问题，可以很容易地进行快速回滚操作。</p><h2 id="加速-ALTER-TABLE-操作"><a href="#加速-ALTER-TABLE-操作" class="headerlink" title="加速 ALTER TABLE 操作"></a>加速 ALTER TABLE 操作</h2><p>MySQL 的 ALTER TABLE 操作的性能对大表来说是个大问题。MySQL 执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能会花费很长时间，如果内存不足而表又很大，而且有很多索引的情况下尤其如此。</p><p>一般而言，大部分 ALTER TABLE 操作将导致 MySQL 服务中断。</p><p>对常见的场景，有两种技巧：</p><ul><li>先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换。</li><li>影子拷贝。用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。</li></ul><p>不是所有的 ALTER TABLE 操作都会引起表重建。例如，有两种方法可以改变或者删除一个列的默认值。一种很慢：</p><p><img src="https://user-images.githubusercontent.com/7698088/74589542-1a25c280-5041-11ea-820b-b6ec6e6c56c4.png" alt="很慢"></p><p>因为所有的 MODIFY COLUMN 操作都将导致表重建。</p><p>另一种则很快，它无需要改动表本身，只用修改 <code>.frm</code> 文件，因为列的默认值实际上就存在表的 <code>.frm</code> 中。<br><img src="https://user-images.githubusercontent.com/7698088/74589550-2447c100-5041-11ea-9fe4-fb0372938b0b.png" alt="很快"></p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>索引是存储引擎用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化的最有效的手段了。索引能够轻易地将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。</p><p>索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。</p><p>MySQL 支持 B-Tree 索引、哈希索引、空间数据索引（R-Tree）、全文索引。</p><p>B-Tree 索引使用 B-Tree 数据结构来存储数据。很多存储引擎，包括 InnoDB 使用的是 B+Tree。InnoDB 索引大致是这样工作的：</p><p><img src="https://user-images.githubusercontent.com/7698088/75112331-c4bf6600-567d-11ea-8463-facae4630d33.png" alt="InnoDB 索引工作原理"></p><p>B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。支持：全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另一列、只访问索引的查询。</p><p>B-Tree 索引也有一些限制：</p><ol><li>如果不是按照索引的最左列开始查找，则无法使用索引。</li><li>不能跳过索引中的列。</li><li>如果某个查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li></ol><p>在 MySQL 中，只有 Memory 引擎显式支持哈希索引。</p><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p><p>索引的优点：</p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机 IO 变为顺序 IO。</li></ol><p>当然，索引也并不总是最好的工具。只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。非常小的表，大部分直接全表扫描更有效；中到大型的表，索引非常有效。特大型的表，则建立和使用索引的代价将随之增长，需要一种技术可以区分出查询需要的一组数据，如分区技术。</p><hr><p>正确地创建和使用索引是实现高性能查询的基础。下面是一些如何高效使用索引的方式：</p><ul><li><p>独立的列<br>索引列不能是表达式的一部分，也不能是函数的参数。</p></li><li><p>前缀索引和索引选择性<br>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数（#T）的比值，范围从 <code>1/#T</code> 到 <code>1</code> 之间。索引的选择性越高则查询效率越高，因为可以在查找时过滤掉更多的行。唯一索引的选择性是 1，性能最好。</p></li></ul><p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。</p><p>前缀越长，选择性越高。同时又不能太长，以便节约空间。选择的诀窍就是前缀的基数应该接近于完整列的基数。</p><ul><li>多列索引</li></ul><p>如果在 EXPLAIN 中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。</p><ul><li><p>选择合适的索引列顺序</p></li><li><p>聚簇索引</p></li><li><p>覆盖索引</p></li></ul><p>如果一个索引包含（或者说是覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>查询的生命周期大致可以按照顺序来看：客户端 -&gt; 服务器 -&gt; 服务器解析 -&gt; 生成执行计划 -&gt; 执行 -&gt; 返回结果给客户端。其中执行是最重要的阶段，包括大量为了检索数据到存储引擎的调用及调用后的数据处理，包括排序、分组等。</p><p>查询需要在这些不同的地方花费时间：网络、CPU 计算、生成统计信息和执行计划、锁等待、内存、IO 等。</p><p>如果把查询看成一个任务，由一系列子任务组成。优化查询，实际上就是要优化其子任务，要么消除一些子任务，要么减少子任务的执行次数，要么让子任务运行地更快。</p><p>查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询可以通过减少访问的数据量的方式进行优化。对于低效的查询，可以通过如下两个步骤进行分析：</p><ol><li>确认应用程序是否在检索大量超过需要的数据。通常是访问了太多的行或列。</li><li>确认 MySQL 服务层是否在分析大量超过需要的数据行。</li></ol><p>对于 MySQL，最简单的衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。</p><hr><p>优化有问题的查询时，可以将查询转换一种写法让其返回一样的结果。例如：</p><ol><li>一个复杂查询分成多个简单查询。</li><li>切分查询。</li></ol><p>很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200315205315.png" alt="查询执行路径"></p><p>优化特定类型的查询：</p><ul><li>优化 COUNT() 查询<br>它有两个不同的作用：统计某个列值的数量、统计行数。注意：COUNT(*) 并不会扩展成所有的列，相反，这样的写法更清晰。</li></ul><p>可用使用近似值、增加汇总表等来优化。</p><ul><li>优化关联查询</li><li>优化子查询</li><li>优化 GROUP BY 和 DISTINCT</li><li>优化 LIMIT 分页</li></ul><p>……</p><p>书中给出两个例子：使用 MySQL 构建一个队列表、计算两点之间的距离。</p><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一台主库的数据可以同步到多台备库上，备库也可以配置成另外一台服务器的主库。</p><p>MySQL 支持两种复制方式：基于行、基于语句。两者都是通过重放二进制日志实现。</p><p>复制的用途：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p><p>所谓的二进制日志就是我们常说的 Binlog，复制的原理图：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200322230949.png" alt="复制原理"></p><p>MySQL 按照事务提交的顺序而非每条语句的执行顺序来记录进进制日志，记录完日志后，主库会告诉存储引擎可以提交事务。</p><p>MySQL 配置复制的步骤：1. 在每台服务器上创建复制帐号；2. 配置主库和备库；3. 通知备库连接到主库并从主库复制数据。</p><hr><p>基于语句的复制模式下，主库会记录那些造成数据更改的查询，当备库读取并重放这些事件时，实际上只是把主库上执行过的 SQL 再执行一遍。好处是实现简单，MySQLBinLog 工具是使用基于语句的日志的最佳工具。缺点是存在一些无法被正确复制的 SQL，例如使用 CURRENT_USER() 函数的语句等。</p><p>基于行的复制会将实际数据记录在进进制日志中，好处是可以正确地复制每一行。占用更少的 CPU，有些情况下的开销会比基于语句大。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">MySQL&gt;</span> UPDATE enormous_table SET col1 = 0;</span><br></pre></td></tr></table></figure><p>基于行的复制更新一个黑盒，出问题时难以找到问题所在。</p><p>MySQL 能在这两种复制模式间动态切换。</p><p>设置 log_save_updates 选项可以让备库变成其他服务器的主库。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200329225706.png" alt="备库变主库"></p><p>可以在任意个主库和备库之间建立复制，只有一个限制：每一个备库只能有一个主库。</p><p>最简单的拓扑结构是一主多备。还有主动-主动模式下的主-主复制，互为对方的主库和备库；主动-被动模式下的主-主复制；拥有备库的主-主结构；环形结构；拥有备库的环形结构。</p><p>备库会在主库上创建一个线程，并执行 binlog dump 命令，该命令会读取日志文件中的数据并将其发送给备库。因此备库足够多时，会对主库造成很大的负载。可以使用分发主库：</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200329232003.png" alt="分发主库"></p><p>复制只能扩展读操作，无法扩展写操作。</p><p>一旦配置了复制，监控和管理复制拓扑应该成为一项日常工作，不管有多少服务器。</p><p>MySQL 并不能很好地从服务器崩溃。掉电、磁盘损坏、内存或网络错误中恢复。大部分由于非正常关机后导致的复制问题都是由于没有把数据及时地刷到磁盘。</p><p>MySQL 复制是内建功能中的“瑞士军刀”，显著增加了 MySQL 的功能和可用性。</p><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><p>容量可以简单地认为是处理负载的能力，从不同的角度来考虑负载很有帮助：数据量、用户量、用户活跃度、相对数据集的大小。</p><p>可扩展性是当增加资源以处理负载和增加容量时系统能够获得的投资产出率（ROI）。</p><p>当我们增加了一倍的服务器，结果增加了一倍的容量，这就是线性扩展。大部分系统并不是线性扩展，只能以比线性扩展略低的扩展系统进行扩展。</p><p>在扩展之前，可以做一些准备工作：优化性能、购买性能更强的硬件。</p><p>向上扩展比较简单，但很快会达到天花板。因此更多地考虑向外扩展。</p><p>向外扩展策略分为三个部分：复制、拆分、数据分片。</p><ul><li><p>复制：备库提供读。</p></li><li><p>拆分：按功能拆分，不同节点执行不同的任务。</p></li><li><p>数据分片：通常有一个数据库访问抽象层。如非必要，尽量不分片。目标是对那些重要并且频繁查询的数据减少分片。</p></li><li><p>分区键：选择分区键的时候，尽可能选择那些能够避免跨分片查询的，但同时也要让分片足够小，以免过大的数据片导致问题。</p></li><li><p>多个分片键：需要多个分区键并不意味着需要去设计两个完全冗余的数据存储。</p></li><li><p>跨分片查询：可以借助汇总表来执行。</p></li><li><p>分配数据、分片和节点：应该尽可能地让分片的大小比节点容量小很多，这样就可以在单个节点上存储多个分片。小分片更容易管理、便于迁移。</p></li><li><p>在节点上部署分片</p></li><li><p>固定分配：采用取模等方法。不灵活，修改分片策略比较难。</p></li><li><p>动态分配：如采用一个表来指定 userID 被分到哪个分片。可以使用动态分配策略。</p></li><li><p>混合动态分配和固定分配</p></li><li><p>显式分配</p></li></ul><hr><ul><li>重新均衡分片数据</li><li>生成全局唯一 ID</li><li>分片工具</li></ul><p>通过多实例扩展，每个实例监听不同的网络端口，或绑定到不同的 IP。</p><p>通过集群扩展：MySQL Cluster(NDB Cluster)、Clustrix、ScalaBase、GenieDB、Akiban。</p><p>向内扩展：处理不断增长的数据和负载最简单的办法是对不再需要的数据进行归档和清理。可以作为争取时间的短期策略。要注意：对应用的影响、要归档的行、维护数据一致性、避免数据丢失、解除归档。</p><p>保持活跃数据独立：</p><ol><li>将表划分为几个部分，如将 users 表划分为  <code>active_users</code> 和 <code>inactive_users</code>。</li><li>MySQL 分区。</li><li>基于时间的数据分区。</li></ol><p>负载均衡的思路：在一个服务器集群中尽可能地平均负载量。</p><p><img src="https://cdn.jsdelivr.net/gh/qcrao/images/blog/20200412201407.png" alt="一个典型的读密集型网站负载均衡架构"></p><p>如上图，包含两个负载均衡设备，一个用于 HTTP 流量，另一个用于 MySQL 访问。</p><p>负载均衡的五个常见目的：可扩展性、高效性、可用性、透明性、一致性。</p><p>在 MySQL 相关的领域里，负载均衡架构通常与数据分片及复制紧密相关。可以把负载均衡和高可用性结合在一起，部署到应用的任一层次上。</p><p>负载均衡的方法包括：直接连接、引入中间件、一主多备。</p><p>负载均衡的算法决定哪个服务器接受下一个连接，下面是一些可用的方法：随机、轮询、最少连接数、最快响应、哈希、权重。</p><p>在 MySQL 扩展策略方面，典型的应用在增长到非常庞大时，通常先从单个服务器转移到向外扩展的拥有读备库的架构，再到数据分片和/或按功能分区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;MySQL 的灵活性体现在很多方面，但其中最与众不同的特性是它的存储引擎架构：将查询处理以及其他系统任务和数据的存储/提取相分离。这
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://qcrao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="https://qcrao.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之pprof</title>
    <link href="https://qcrao.com/2019/11/10/dive-into-go-pprof/"/>
    <id>https://qcrao.com/2019/11/10/dive-into-go-pprof/</id>
    <published>2019-11-10T14:25:48.000Z</published>
    <updated>2020-04-20T01:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人都听过“雷神 3”关于性能优化的故事。在一个 3D 游戏引擎的源码里，John Carmack 将 <code>1/sqrt(x)</code> 这个函数的执行效率优化到了极致。</p><p>一般我们使用二分法，或者牛顿迭代法计算一个浮点数的平方根。但在这个函数里，作者使用了一个“魔数”，根本没有迭代，两步就直接算出了平方根。令人叹为观止！</p><p>因为它是最底层的函数，而游戏里涉及到大量的这种运算，使得在运算资源极其紧张的 DOS 时代，游戏也可以流畅地运行。这就是性能优化的魅力！</p><p>工作中，当业务量比较小的时候，用的机器也少，体会不到性能优化带来的收益。而当一个业务使用了几千台机器的时候，性能优化 20%，那就能省下几百台机器，一年能省几百万。省下来的这些钱，给员工发年终奖，那得多 Happy！</p><p>一般而言，性能分析可以从三个层次来考虑：应用层、系统层、代码层。</p><p>应用层主要是梳理业务方的使用方式，让他们更合理地使用，在满足使用方需求的前提下，减少无意义的调用；系统层关注服务的架构，例如增加一层缓存；代码层则关心函数的执行效率，例如使用效率更高的开方算法等。</p><p>做任何事，都要讲究方法。在很多情况下，迅速把事情最关键的部分完成，就能拿到绝大部分的收益了。其他的一些边边角角，可以慢慢地缝合。一上来就想完成 100%，往往会陷入付出了巨大的努力，却收获寥寥的境地。</p><p>性能优化这件事也一样，识别出性能瓶颈，会让我们付出最小的努力，而得到最大的回报。</p><p>Go 语言里，pprof 就是这样一个工具，帮助我们快速找到性能瓶颈，进而进行有针对性地优化。</p><h1 id="什么是-pprof"><a href="#什么是-pprof" class="headerlink" title="什么是 pprof"></a>什么是 pprof</h1><p>代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性能算是有个底。</p><p>但是压测是线下的模拟流量，如果到了线上呢？会遇到高并发、大流量，不靠谱的上下游，突发的尖峰流量等等场景，这些都是不可预知的。</p><p>线上突然大量报警，接口超时，错误数增加，除了看日志、监控，就是用性能分析工具分析程序的性能，找到瓶颈。当然，一般这种情形不会让你有机会去分析，降级、限流、回滚才是首先要做的，要先止损嘛。回归正常之后，通过线上流量回放，或者压测等手段，制造性能问题，再通过工具来分析系统的瓶颈。</p><p>一般而言，性能分析主要关注 CPU、内存、磁盘 IO、网络这些指标。</p><p><code>Profiling</code> 是指在程序执行过程中，收集能够反映程序执行状态的数据。在软件工程中，性能分析（performance analysis，也称为 profiling），是以收集程序运行时信息为手段研究程序行为的分析方法，是一种动态程序分析的方法。</p><p>Go 语言自带的 pprof 库就可以分析程序的运行情况，并且提供可视化的功能。它包含两个相关的库：</p><ul><li><p>runtime/pprof<br>对于只跑一次的程序，例如每天只跑一次的离线预处理程序，调用 pprof 包提供的函数，手动开启性能数据采集。</p></li><li><p>net/http/pprof<br>对于在线服务，对于一个 HTTP Server，访问 pprof 提供的 HTTP 接口，获得性能数据。当然，实际上这里底层也是调用的 runtime/pprof 提供的函数，封装成接口对外提供网络访问。</p></li></ul><h1 id="pprof-的作用"><a href="#pprof-的作用" class="headerlink" title="pprof 的作用"></a>pprof 的作用</h1><p><code>pprof</code> 是 Go 语言中分析程序运行性能的工具，它能提供各种性能数据：</p><p><img src="https://user-images.githubusercontent.com/7698088/68523507-3ce36500-02f5-11ea-8e8f-438c9ef2b9f8.png" alt="pprof 采集的信息类型"></p><p><code>allocs</code> 和 <code>heap</code> 采样的信息一致，不过前者是所有对象的内存分配，而 heap 则是活跃对象的内存分配。</p><blockquote><p>The difference between the two is the way the pprof tool reads there at start time. Allocs profile will start pprof in a mode which displays the total number of bytes allocated since the program began (including garbage-collected bytes). </p></blockquote><p>上图来自参考资料【wolfogre】的一篇 pprof 实战的文章，提供了一个样例程序，通过 pprof 来排查、分析、解决性能问题，非常精彩。</p><blockquote><ol><li>当 CPU 性能分析启用后，Go runtime 会每 10ms 就暂停一下，记录当前运行的 goroutine 的调用堆栈及相关数据。当性能分析数据保存到硬盘后，我们就可以分析代码中的热点了。</li></ol></blockquote><blockquote><ol start="2"><li>内存性能分析则是在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的。</li></ol></blockquote><blockquote><ol start="3"><li>阻塞分析是一个很独特的分析，它有点儿类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，在排除 CPU 和内存瓶颈前，不应该用它来分析。</li></ol></blockquote><h1 id="pprof-如何使用"><a href="#pprof-如何使用" class="headerlink" title="pprof 如何使用"></a>pprof 如何使用</h1><blockquote><p>我们可以通过 <code>报告生成</code>、<code>Web 可视化界面</code>、<code>交互式终端</code> 三种方式来使用 <code>pprof</code>。</p></blockquote><blockquote><p>—— 煎鱼《Golang 大杀器之性能剖析 PProf》</p></blockquote><h2 id="runtime-pprof"><a href="#runtime-pprof" class="headerlink" title="runtime/pprof"></a>runtime/pprof</h2><p>拿 CPU profiling 举例，增加两行代码，调用 <code>pprof.StartCPUProfile</code> 启动 cpu profiling，调用 <code>pprof.StopCPUProfile()</code> 将数据刷到文件里：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime/pprof"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to file"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">        </span><br><span class="line">    pprof.StartCPUProfile(f)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="net-http-pprof"><a href="#net-http-pprof" class="headerlink" title="net/http/pprof"></a>net/http/pprof</h2><p>启动一个端口（和正常提供业务服务的端口不同）监听 pprof 请求：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initPprofMonitor</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">pPort := global.Conf.MustInt(<span class="string">"http_server"</span>, <span class="string">"pprofport"</span>, <span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">addr := <span class="string">":"</span> + strconv.Itoa(pPort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err = http.ListenAndServe(addr, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(<span class="string">"funcRetErr=http.ListenAndServe||err=%s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pprof</code> 包会自动注册 handler， 处理相关的请求：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/net/http/pprof/pprof.go:71</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">"/debug/pprof/"</span>, http.HandlerFunc(Index))</span><br><span class="line">http.Handle(<span class="string">"/debug/pprof/cmdline"</span>, http.HandlerFunc(Cmdline))</span><br><span class="line">http.Handle(<span class="string">"/debug/pprof/profile"</span>, http.HandlerFunc(Profile))</span><br><span class="line">http.Handle(<span class="string">"/debug/pprof/symbol"</span>, http.HandlerFunc(Symbol))</span><br><span class="line">http.Handle(<span class="string">"/debug/pprof/trace"</span>, http.HandlerFunc(Trace))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个路径 <code>/debug/pprof/</code> 下面其实还有 5 个子路径：</p><blockquote><p>goroutine<br>threadcreate<br>heap<br>block<br>mutex</p></blockquote><p>启动服务后，直接在浏览器访问：</p><blockquote><p><a href="http://47.93.238.9:8080/debug/pprof/" target="_blank" rel="noopener">http://47.93.238.9:8080/debug/pprof/</a></p></blockquote><p>就可以得到一个汇总页面：</p><p><img src="https://user-images.githubusercontent.com/7698088/68526001-46c79100-0312-11ea-9a7f-7eb41cf482d6.png" alt="页面 /debug/pprof"></p><p>可以直接点击上面的链接，进入子页面，查看相关的汇总信息。</p><p>关于 goroutine 的信息有两个链接，<code>goroutine</code> 和 <code>full goroutine stack dump</code>，前者是一个汇总的消息，可以查看 goroutines 的总体情况，后者则可以看到每一个 goroutine 的状态。页面具体内容的解读可以参考【大彬】的文章。</p><p>点击 <code>profile</code> 和 <code>trace</code> 则会在后台进行一段时间的数据采样，采样完成后，返回给浏览器一个 profile 文件，之后在本地通过 <code>go tool pprof</code> 工具进行分析。</p><p>当我们下载得到了 profile 文件后，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof ~/Downloads/profile</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/68529660-bb62f580-033b-11ea-9ff3-67630ce1d21f.png" alt="pprof profile"></p><p>就可以进入命令行交互式使用模式。执行 <code>go tool pprof -help</code> 可以查看帮助信息。</p><p>直接使用如下命令，则不需要通过点击浏览器上的链接就能进入命令行交互模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://47.93.238.9:8080/debug/pprof/profile</span><br></pre></td></tr></table></figure><p>当然也是需要先后台采集一段时间的数据，再将数据文件下载到本地，最后进行分析。上述的 Url 后面还可以带上时间参数：<code>?seconds=60</code>，自定义 CPU Profiling 的时长。</p><p>类似的命令还有：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 下载 cpu profile，默认从当前开始收集 <span class="number">30s</span> 的 cpu 使用情况，需要等待 <span class="number">30s</span></span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/profile</span></span><br><span class="line"># wait <span class="number">120s</span></span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/profile?seconds=120     </span></span><br><span class="line"></span><br><span class="line"># 下载 heap profile</span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/heap</span></span><br><span class="line"></span><br><span class="line"># 下载 goroutine profile</span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/goroutine</span></span><br><span class="line"></span><br><span class="line"># 下载 block profile</span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/block</span></span><br><span class="line"></span><br><span class="line"># 下载 mutex profile</span><br><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//47.93.238.9:8080/debug/pprof/mutex</span></span><br></pre></td></tr></table></figure><p>进入交互式模式之后，比较常用的有 <code>top</code>、<code>list</code>、<code>web</code> 等命令。</p><p>执行 <code>top</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/68526610-ea1ba480-0318-11ea-9a13-ea49a1b849b0.png" alt="pprof top"></p><p>得到四列数据：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>flat</td><td>本函数的执行耗时</td></tr><tr><td>flat%</td><td>flat 占 CPU 总时间的比例。程序总耗时 16.22s, Eat 的 16.19s 占了 99.82%</td></tr><tr><td>sum%</td><td>前面每一行的 flat 占比总和</td></tr><tr><td>cum</td><td>累计量。指该函数加上该函数调用的函数总耗时</td></tr><tr><td>cum%</td><td>cum 占 CPU 总时间的比例</td></tr></tbody></table><p>其他类型，如 heap 的 flat, sum, cum 的意义和上面的类似，只不过计算的东西不同，一个是 CPU 耗时，一个是内存大小。</p><p>执行 <code>list</code>，使用<code>正则</code>匹配，找到相关的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list Eat</span><br></pre></td></tr></table></figure><p>直接定位到了相关长耗时的代码处：</p><p><img src="https://user-images.githubusercontent.com/7698088/68526943-34eaeb80-031c-11ea-8d3d-c3e103c5a8a0.png" alt="pprof list"></p><p>执行 <code>web</code>（需要安装 graphviz，pprof 能够借助 grapgviz 生成程序的调用图），会生成一个 svg 格式的文件，直接在浏览器里打开（可能需要设置一下 .svg 文件格式的默认打开方式）：</p><p><img src="https://user-images.githubusercontent.com/7698088/68526883-9c546b80-031b-11ea-86be-ebe59c7cccad.png" alt="pprof web"></p><p>图中的连线代表对方法的调用，连线上的标签代表指定的方法调用的采样值（例如时间、内存分配大小等），方框的大小与方法运行的采样值的大小有关。</p><p>每个方框由两个标签组成：在 cpu profile 中，一个是方法运行的时间占比，一个是它在采样的堆栈中出现的时间占比（前者是 flat 时间，后者则是 cumulate 时间占比)；框越大，代表耗时越多或是内存分配越多。</p><p>另外，<code>traces</code> 命令还可以列出函数的调用栈：</p><p><img src="https://user-images.githubusercontent.com/7698088/68537697-6b1f7e00-03a3-11ea-9d68-d7bdd12c38a4.png" alt="pprof traces"></p><p>除了上面讲到的两种方式（报告生成、命令行交互），还可以在浏览器里进行交互。先生成 profile 文件，再执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof --http=:8080 ~/Downloads/profile</span><br></pre></td></tr></table></figure><p>进入一个可视化操作界面：</p><p><img src="https://user-images.githubusercontent.com/7698088/68528770-214a7f80-0332-11ea-9ed9-b3b80a244fb5.png" alt="pprof 可视化界面"></p><p>点击菜单栏可以在：Top/Graph/Peek/Source 之间进行切换，甚至可以看到火焰图（Flame Graph）：</p><p><img src="https://user-images.githubusercontent.com/7698088/68528787-48a14c80-0332-11ea-8e9f-1cf730a02083.png" alt="pprof 火焰图"></p><p>它和一般的火焰图相比刚好倒过来了，调用关系的展现是从上到下。形状越长，表示执行时间越长。注：我这里使用的 go 版本是 1.13，更老一些的版本 pprof 工具不支持 <code>-http</code> 的参数。当然也可以下载其他的库查看火焰图，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/google/pprof</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">go get github.com/uber/go-torch</span><br></pre></td></tr></table></figure><h1 id="pprof-进阶"><a href="#pprof-进阶" class="headerlink" title="pprof 进阶"></a>pprof 进阶</h1><p>我在参考资料部分给出了一些使用 pprof 工具进行性能分析的实战文章，可以跟着动手实践一下，之后再用到自己的平时工作中。</p><h2 id="Russ-Cox-实战"><a href="#Russ-Cox-实战" class="headerlink" title="Russ Cox 实战"></a>Russ Cox 实战</h2><p>这部分主要内容来自参考资料【Ross Cox】，学习一下大牛的优化思路。</p><p>事情的起因是这样的，有人发表了一篇文章，用各种语言实现了一个算法，结果用 go 写的程序非常慢，而 C++ 则最快。然后 Russ Cox 就鸣不平了，哪受得了这个气？马上启用 pprof 大杀器进行优化。最后，程序不仅更快，而且使用的内存更少了！</p><p>首先，增加 cpu profiling 的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to file"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *cpuprofile != <span class="string">""</span> &#123;</span><br><span class="line">        f, err := os.Create(*cpuprofile)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pprof.StartCPUProfile(f)</span><br><span class="line">        <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 pprof 观察耗时 <code>top5</code> 的函数，发现一个读 map 的函数耗时最长：<code>mapaccess1_fast64</code>，而它出现在一个递归函数中。</p><p><img src="https://user-images.githubusercontent.com/7698088/68537368-47593980-039d-11ea-8c77-187b4760b866.png" alt="web"></p><p>一眼就能看到框最大的 <code>mapacess1_fast64</code> 函数。执行 <code>web mapaccess1</code> 命令，更聚焦一些：</p><p><img src="https://user-images.githubusercontent.com/7698088/68537381-88e9e480-039d-11ea-9c7b-3741f791cbc9.png" alt="web mapaccess1"></p><p>调用 <code>mapaccess1_fast64</code> 函数最多的就是 main.FindLoops 和 main.DFS，是时候定位到具体的代码了，执行命令：<code>list DFS</code>，定位到相关的代码。</p><p>优化的方法是将 map 改成 slice，能这样做的原因当然和 key 的类型是 int 而且不是太稀疏有关。</p><blockquote><p>The take away will be that for smaller data sets, you shouldn’t use maps where slices would suffice, as maps have a large overhead.</p></blockquote><p>修改完之后，再次通过 cpu profiling，发现递归函数的耗时已经不在 top5 中了。但是新增了长耗时函数：runtime.mallocgc，占比 54.2%，而这和分存分配以及垃圾回收相关。</p><p>下一步，增加采集内存数据的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">"memprofile"</span>, <span class="string">""</span>, <span class="string">"write memory profile to this file"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    </span><br><span class="line">    FindHavlakLoops(cfgraph, lsgraph)</span><br><span class="line">    <span class="keyword">if</span> *memprofile != <span class="string">""</span> &#123;</span><br><span class="line">        f, err := os.Create(*memprofile)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        pprof.WriteHeapProfile(f)</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续通过 <code>top5</code>、<code>list</code> 命令找到内存分配最多的代码位置，发现这回是向 map 里插入元素使用的内存比较多。改进方式同样是用 slice 代替 map，但 map 还有一个特点是可以重复插入元素，因此新写了一个向 slice 插入元素的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendUnique</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, y := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(a, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在程序比最初的时候快了 2.1 倍。再次查看 cpu profile 数据，发现 <code>runtime.mallocgc</code> 降了一些，但仍然占比 50.9%。</p><blockquote><p>Another way to look at why the system is garbage collecting is to look at the allocations that are causing the collections, the ones that spend most of the time in mallocgc.</p></blockquote><p>因此需要查看垃圾回收到底在回收哪些内容，这些内容就是导致频繁垃圾回收的“罪魁祸首”。</p><p>使用 <code>web mallocgc</code> 命令，将和 mallocgc 相关的函数用矢量图的方式展现出来，但是有太多样本量很少的节点影响观察，增加过滤命令：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof --nodefraction=<span class="number">0.1</span> profile</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7698088/68537420-13cadf00-039e-11ea-98d9-f215a0eaabb8.png" alt="web mallocgc"></p><p>将少于 <code>10%</code> 的采样点过滤掉，新的矢量图可以直观地看出，<code>FindLoops</code> 触发了最多的垃圾回收操作。继续使用命令 <code>list FindLoops</code> 直接找到代码的位置。</p><p>原来，每次执行 <code>FindLoops</code> 函数时，都要 <code>make</code> 一些临时变量，这会加重垃圾回收器的负担。改进方式是增加一个全局变量 cache，可以重复利用。坏处是，现在不是线程安全的了。</p><p>使用 pprof 工具进行的优化到这就结束了。最后的结果很不错，基本上能达到和 C++ 同等的速度和同等的内存分配大小。</p><p>我们能得到的启发就是先使用 cpu profile 找出耗时最多的函数，进行优化。如果发现 gc 执行比较多的时候，找出内存分配最多的代码以及引发内存分配的函数，进行优化。</p><p>原文很精彩，虽然写作时间比较久远（最初写于 2011 年）了，但仍然值得一看。另外，参考资料【wolfogre】的实战文章也非常精彩，而且用的招式和这篇文章差不多，但是你可以运行文章提供的样例程序，一步步地解决性能问题，很有意思！</p><h2 id="查找内存泄露"><a href="#查找内存泄露" class="headerlink" title="查找内存泄露"></a>查找内存泄露</h2><p>内存分配既可以发生在堆上也可以在栈上。堆上分配的内存需要垃圾回收或者手动回收（对于没有垃圾回收的语言，例如 C++），栈上的内存则通常在函数退出后自动释放。</p><p>Go 语言通过逃逸分析会将尽可能多的对象分配到栈上，以使程序可以运行地更快。</p><p>这里说明一下，有两种内存分析策略：一种是当前的（这一次采集）内存或对象的分配，称为 <code>inuse</code>；另一种是从程序运行到现在所有的内存分配，不管是否已经被 gc 过了，称为 <code>alloc</code>。</p><blockquote><p>As mentioned above, there are two main memory analysis strategies with pprof. One is around looking at the current allocations (bytes or object count), called inuse. The other is looking at all the allocated bytes or object count throughout the run-time of the program, called alloc. This means regardless if it was gc-ed, a summation of everything sampled.</p></blockquote><p>加上 <code>-sample_index</code> 参数后，可以切换内存分析的类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof -sample_index=alloc_space  http://47.93.238.9:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure><p>共有 4 种：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>inuse_space</td><td>amount of memory allocated and not released yet</td></tr><tr><td>inuse_objects</td><td>amount of objects allocated and not released yet</td></tr><tr><td>alloc_space</td><td>total amount of memory allocated (regardless of released)</td></tr><tr><td>alloc_objects</td><td>total amount of objects allocated (regardless of released)</td></tr></tbody></table><p>参考资料【大彬 实战内存泄露】讲述了如何通过类似于 diff 的方式找到前后两个时刻多出的 goroutine，进而找到 goroutine 泄露的原因，并没有直接使用 heap 或者 goroutine 的 profile 文件。同样推荐阅读！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>pprof</code> 是进行 Go 程序性能分析的有力工具，它通过采样、收集运行中的 Go 程序性能相关的数据，生成 profile 文件。之后，提供三种不同的展现形式，让我们能更直观地看到相关的性能数据。</p><p>得到性能数据后，可以使用 <code>top</code>、<code>web</code>、<code>list</code>等命令迅速定位到相应的代码处，并进行优化。</p><p>“过早的优化是万恶之源”。实际工作中，很少有人会关注性能，但当你写出的程序存在性能瓶颈，qa 压测时，qps 上不去，为了展示一下技术实力，还是要通过 pprof 观察性能瓶颈，进行相应的性能优化。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【曹大 pprof】<a href="https://xargin.com/pprof-and-flamegraph/" target="_blank" rel="noopener">https://xargin.com/pprof-and-flamegraph/</a></p><p>【Russ Cox 优化过程，并附上代码】<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></p><p>【google pprof】<a href="https://github.com/google/pprof" target="_blank" rel="noopener">https://github.com/google/pprof</a></p><p>【使用 pprof 和火焰图调试 golang 应用】<a href="https://cizixs.com/2017/09/11/profiling-golang-program/" target="_blank" rel="noopener">https://cizixs.com/2017/09/11/profiling-golang-program/</a></p><p>【资源合集】<a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/" target="_blank" rel="noopener">https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/</a></p><p>【Profiling your Golang app in 3 steps】<a href="https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/" target="_blank" rel="noopener">https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/</a></p><p>【案例，压测 Golang remote profiling and flamegraphs】<a href="https://matoski.com/article/golang-profiling-flamegraphs/" target="_blank" rel="noopener">https://matoski.com/article/golang-profiling-flamegraphs/</a></p><p>【煎鱼 pprof】<a href="https://segmentfault.com/a/1190000016412013" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016412013</a></p><p>【鸟窝 pprof】<a href="https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/" target="_blank" rel="noopener">https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/</a></p><p>【关于 Go 的 7 种性能分析方法】<a href="https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html" target="_blank" rel="noopener">https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html</a></p><p>【pprof 比较全】<a href="https://juejin.im/entry/5ac9cf3a518825556534c76e" target="_blank" rel="noopener">https://juejin.im/entry/5ac9cf3a518825556534c76e</a></p><p>【通过实例来讲解分析、优化过程】<a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/" target="_blank" rel="noopener">https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/</a></p><p>【Go 作者 Dmitry Vyukov】<a href="https://github.com/golang/go/wiki/Performance" target="_blank" rel="noopener">https://github.com/golang/go/wiki/Performance</a></p><p>【wolfogre 非常精彩的实战文章】<a href="https://blog.wolfogre.com/posts/go-ppof-practice/" target="_blank" rel="noopener">https://blog.wolfogre.com/posts/go-ppof-practice/</a></p><p>【dave.cheney】<a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html" target="_blank" rel="noopener">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html</a></p><p>【实战案例】<a href="https://www.cnblogs.com/sunsky303/p/11058808.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunsky303/p/11058808.html</a></p><p>【大彬 实战内存泄露】<a href="https://segmentfault.com/a/1190000019222661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019222661</a></p><p>【查找内存泄露】<a href="https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/" target="_blank" rel="noopener">https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/</a></p><p>【雷神 3 性能优化】<a href="https://diducoder.com/sotry-about-sqrt.html" target="_blank" rel="noopener">https://diducoder.com/sotry-about-sqrt.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信很多人都听过“雷神 3”关于性能优化的故事。在一个 3D 游戏引擎的源码里，John Carmack 将 &lt;code&gt;1/sqrt(x)&lt;/code&gt; 这个函数的执行效率优化到了极致。&lt;/p&gt;
&lt;p&gt;一般我们使用二分法，或者牛顿迭代法计算一个浮点数的平方根。但在这个函数
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang error 的突围</title>
    <link href="https://qcrao.com/2019/09/18/golang-error-break-through/"/>
    <id>https://qcrao.com/2019/09/18/golang-error-break-through/</id>
    <published>2019-09-18T04:05:21.000Z</published>
    <updated>2019-09-18T04:06:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>写过 C 的同学知道，C 语言中常常返回整数错误码（errno）来表示函数处理出错，通常用 <code>-1</code> 来表示错误，用 <code>0</code> 表示正确。</p><p>而在 Go 中，我们使用 <code>error</code> 类型来表示错误，不过它不再是一个整数类型，是一个接口类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它表示那些能用一个字符串就能说清的错误。</p><p>我们最常用的就是 <code>errors.New()</code> 函数，非常简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/errors/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 New 函数创建出来的 error 类型实际上是 errors 包里未导出的 <code>errorString</code> 类型，它包含唯一的一个字段 <code>s</code>，并且实现了唯一的方法：<code>Error() string</code>。</p><p>通常这就够了，它能反映当时“出错了”，但是有些时候我们需要更加具体的信息，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用者发现出错的时候，只知道传入了一个负数进来，并不清楚到底传的是什么值。在 Go 里：</p><blockquote><p>It is the error implementation’s responsibility to summarize the context.</p></blockquote><p>它要求返回这个错误的函数要给出具体的“上下文”信息，也就是说，在 <code>Sqrt</code> 函数里，要给出这个负数到底是什么。</p><p>所以，如果发现 <code>f</code> 小于 0，应该这样返回错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"math: square root of negative number %g"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就用到了 <code>fmt.Errorf</code> 函数，它先将字符串格式化，再调用 <code>errors.New</code> 函数来创建错误。</p><p>当我们想知道错误类型，并且打印错误的时候，直接打印 error：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err.Error)</span><br></pre></td></tr></table></figure><p><code>fmt</code> 包会自动调用 <code>err.Error()</code> 函数来打印字符串。</p><p>通常，我们将 error 放到函数返回值的最后一个，没什么好说的，大家都这样做，约定俗成。</p><p>参考资料【Tony Bai】这篇文章提到，构造 error 的时候，要求传入的字符串首字母小写，结尾不带标点符号，这是因为我们经常会这样使用返回的 error：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... err := errors.New(<span class="string">"error example"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The returned error is %s.\n"</span>, err)</span><br></pre></td></tr></table></figure><h1 id="error-的困局"><a href="#error-的困局" class="headerlink" title="error 的困局"></a>error 的困局</h1><blockquote><p>In Go, error handling is important. The language’s design and conventions encourage you to explicitly check for errors where they occur (as distinct from the convention in other languages of throwing exceptions and sometimes catching them).</p></blockquote><p>在 Go 语言中，错误处理是非常重要的。它从语言层面要求我们需要明确地处理遇到的错误。而不是像其他语言，类如 Java，使用 <code>try-catch- finally</code> 这种“把戏”。</p><p>这就造成代码里 “error” 满天飞，显得非常冗长拖沓。</p><p>而为了代码健壮性考虑，对于函数返回的每一个错误，我们都不能忽略它。因为出错的同时，很可能会返回一个 <code>nil</code> 类型的对象。如果不对错误进行判断，那下一行对 <code>nil</code> 对象的操作百分之百会引发一个 <code>panic</code>。</p><p>这样，Go 语言中诟病最多的就是它的错误处理方式似乎回到了上古 C 语言时代。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rr := doStuff1()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = doStuff2()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = doStuff3()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//handle error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go authors 之一的 Russ Cox 对于这种观点进行过驳斥：当初选择返回值这种错误处理机制而不是 try-catch，主要是考虑前者适用于大型软件，后者更适合小程序。</p></blockquote><p>在参考资料【Go FAQ】里也提到，<code>try-catch</code> 会让代码变得非常混乱，程序员会倾向将一些常见的错误，例如，<code>failing to open a file</code>，也抛到异常里，这会让错误处理更加冗长繁琐且易出错。</p><p>而 Go 语言的多返回值使得返回错误异常简单。对于真正的异常，Go 提供 <code>panic-recover</code> 机制，也使得代码看起来非常简洁。</p><blockquote><p>当然 Russ Cox 也承认 Go 的错误处理机制对于开发人员的确有一定的心智负担。</p></blockquote><p>参考资料【Go 语言的错误处理机制是一个优秀的设计吗？】是知乎上的一个回答，阐述了 Go 对待错误和异常的不同处理方式，前者使用 error，后者使用 panic，这样的处理比较 Java 那种错误异常一锅端的做法更有优势。</p><p>【如何优雅的在Golang中进行错误处理】对于在业务上如何处理 error，给出了一些很好的示例。</p><h1 id="尝试破局"><a href="#尝试破局" class="headerlink" title="尝试破局"></a>尝试破局</h1><p>这部分的内容主要来自 Dave cheney GoCon 2016 的演讲，参考资料可以直达原文。</p><p>经常听到 Go 有很多“箴言”，说得很顺口，但理解起来并不是太容易，因为它们大部分都是有故事的。例如，我们常说：</p><blockquote><p>Don’t communicating by sharing memory, share memory by communicating.</p></blockquote><p>文中还列举了很多，都很有意思：</p><p><img src="https://user-images.githubusercontent.com/7698088/64576578-d355e180-d3ab-11e9-8e99-34222a3994f1.png" alt="go proverbs"></p><p>下面我们讲三条关于 error 的“箴言”。</p><h2 id="Errors-are-just-values"><a href="#Errors-are-just-values" class="headerlink" title="Errors are just values"></a>Errors are just values</h2><p><code>Errors are just values</code> 的实际意思是只要实现了 <code>Error</code> 接口的类型都可以认为是 <code>Error</code>，重要的是要理解这些“箴言”背后的道理。</p><p>作者把处理 error 的方式分为三种：</p><blockquote><ol><li>Sentinel errors</li><li>Error Types</li><li>Opaque errors</li></ol></blockquote><p>我们来挨个说。首先 <code>Sentinel errors</code>，Sentinel 来自计算机中常用的词汇，中文意思是“哨兵”。以前在学习快排的时候，会有一个“哨兵”，其他元素都要和“哨兵”进行比较，它划出了一条界限。</p><p>这里 <code>Sentinel errors</code> 实际想说的是这里有一个错误，暗示处理流程不能再进行下去了，必须要在这里停下，这也是一条界限。而这些错误，往往是提前约定好的。</p><p>例如，<code>io</code> 包里的 <code>io.EOF</code>，表示“文件结束”错误。但是这种方式处理起来，不太灵活：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">"0123456789"</span>))</span><br><span class="line"></span><br><span class="line">_, err := r.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>))</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">log.Fatal(<span class="string">"read failed:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要判断 <code>err</code> 是否和约定好的错误 <code>io.EOF</code> 相等。</p><p>再来一个例子，当我想返回 err 并且加上一些上下文信息时，就麻烦了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := readfile(“.bashrc”)</span><br><span class="line"><span class="keyword">if</span> strings.Contains(error.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readfile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := openfile(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(“cannot open file: %v<span class="string">", err)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// ……</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>readfile</code> 函数里判断 err 不为空，则用 fmt.Errorf 在 err 前加上具体的 <code>file</code> 信息，返回给调用者。返回的 err 其实还是一个字符串。</p><p>造成的后果时，调用者不得不用字符串匹配的方式判断底层函数 <code>readfile</code> 是不是出现了某种错误。当你必须要这样才能判断某种错误时，代码的“坏味道”就出现了。</p><p>顺带说一句，<code>err.Error()</code> 方法是给程序员而非代码设计的，也就是说，当我们调用 <code>Error</code> 方法时，结果要写到文件或是打印出来，是给程序员看的。在代码里，我们不能根据 <code>err.Error()</code> 来做一些判断，就像上面的 <code>main</code> 函数里做的那样，不好。</p><p><code>Sentinel errors</code> 最大的问题在于它在定义 error 和使用 error 的包之间建立了依赖关系。比如要想判断 <code>err == io.EOF</code> 就得引入 io 包，当然这是标准库的包，还 Ok。如果很多用户自定义的包都定义了错误，那我就要引入很多包，来判断各种错误。麻烦来了，这容易引起循环引用的问题。</p><p>因此，我们应该尽量避免 <code>Sentinel errors</code>，仅管标准库中有一些包这样用，但建议还是别模仿。</p><p>第二种就是 <code>Error Types</code>，它指的是实现了 <code>error</code> 接口的那些类型。它的一个重要的好处是，类型中除了 error 外，还可以附带其他字段，从而提供额外的信息，例如出错的行数等。</p><p>标准库有一个非常好的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">Op   <span class="keyword">string</span></span><br><span class="line">Path <span class="keyword">string</span></span><br><span class="line">Err  error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PathError</code> 额外记录了出错时的文件路径和操作类型。</p><p>通常，使用这样的 error 类型，外层调用者需要使用类型断言来判断错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// underlyingError returns the underlying error for known os error types.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">underlyingError</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *PathError:</span><br><span class="line"><span class="keyword">return</span> err.Err</span><br><span class="line"><span class="keyword">case</span> *LinkError:</span><br><span class="line"><span class="keyword">return</span> err.Err</span><br><span class="line"><span class="keyword">case</span> *SyscallError:</span><br><span class="line"><span class="keyword">return</span> err.Err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这又不可避免地在定义错误和使用错误的包之间形成依赖关系，又回到了前面的问题。</p><p>即使 <code>Error types</code> 比 <code>Sentinel errors</code> 好一些，因为它能承载更多的上下文信息，但是它仍然存在引入包依赖的问题。因此，也是不推荐的。至少，不要把 <code>Error types</code> 作为一个导出类型。</p><p>最后一种，<code>Opaque errors</code>。翻译一下，就是“黑盒 errors”，因为你能知道错误发生了，但是不能看到它内部到底是什么。</p><p>譬如下面这段伪代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">x, err := bar.Foo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use x</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为调用者，调用完 <code>Foo</code> 函数后，只用知道 <code>Foo</code> 是正常工作还是出了问题。也就是说你只需要判断 err 是否为空，如果不为空，就直接返回错误。否则，继续后面的正常流程，不需要知道 err 到底是什么。</p><p>这就是处理 <code>Opaque errors</code> 这种类型错误的策略。</p><p>当然，在某些情况下，这样做并不够用。例如，在一个网络请求中，需要调用者判断返回的错误类型，以此来决定是否重试。这种情况下，作者给出了一种方法：</p><blockquote><p>In this case rather than asserting the error is a specific type or value, we can assert that the error implements a particular behaviour.</p></blockquote><p>就是说，不去判断错误的类型到底是什么，而是去判断错误是否具有某种行为，或者说实现了某个接口。</p><p>来个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">te, ok := err.(temporary)</span><br><span class="line"><span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到网络请求返回的 error 后，调用 <code>IsTemporary</code> 函数，如果返回 true，那就重试。</p><p>这么做的好处是在进行网络请求的包里，不需要 <code>import</code> 引用定义错误的包。</p><h2 id="handle-not-just-check-errors"><a href="#handle-not-just-check-errors" class="headerlink" title="handle not just check errors"></a>handle not just check errors</h2><p>这一节要说第二句箴言：“Don’t just check errors, handle them gracefully”。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     err := authenticate(r.User)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中的代码是有问题的，直接优化成一句就可以了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> authenticate(r.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他的问题，在函数调用链的最顶层，我们得到的错误可能是：<code>No such file or directory</code>。</p><p>这个错误反馈的信息太少了，不知道文件名、路径、行号等等。</p><p>尝试改进一下，增加一点上下文：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     err := authenticate(r.User)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"authenticate failed: %v"</span>, err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法实际上是先错误转换成字符串，再拼接另一个字符串，最后，再通过 <code>fmt.Errorf</code> 转换成错误。这样做破坏了相等性检测，即我们无法判断错误是否是一种预先定义好的错误了。</p><p>应对方案是使用第三方库：<code>github.com/pkg/errors</code>。提供了友好的界面：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrap annotates cause with a message.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(cause error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">// <span class="title">Cause</span> <span class="title">unwraps</span> <span class="title">an</span> <span class="title">annotated</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Cause</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>通过 <code>Wrap</code> 可以将一个错误，加上一个字符串，“包装”成一个新的错误；通过 <code>Cause</code> 则可以进行相反的操作，将里层的错误还原。</p><p>有了这两个函数，就方便很多：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"open failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">buf, err := ioutil.ReadAll(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个读文件的函数，先尝试打开文件，如果出错，则返回一个附加上了 “open failed” 的错误信息；之后，尝试读文件，如果出错，则返回一个附加上了 “read failed” 的错误。</p><p>当在外层调用 <code>ReadFile</code> 函数时：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := ReadConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">home := os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">config, err := ReadFile(filepath.Join(home, <span class="string">".settings.xml"</span>))</span><br><span class="line"><span class="keyword">return</span> config, errors.Wrap(err, <span class="string">"could not read config"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在 main 函数里就能打印出这样一个错误信息：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure><p>它是有层次的，非常清晰。而如果我们用 <code>pkg/errors</code> 库提供的打印函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := ReadConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">errors.Print(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能得到更有层次、更详细的错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfile.<span class="keyword">go</span>:<span class="number">27</span>: could not read config</span><br><span class="line">readfile.<span class="keyword">go</span>:<span class="number">14</span>: open failed</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure><p>上面讲的是 <code>Wrap</code> 函数，接下来看一下 “Cause” 函数，以前面提到的 <code>temporary</code> 接口为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">Temporary() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">te, ok := errors.Cause(err).(temporary)</span><br><span class="line"><span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断之前先使用 <code>Cause</code> 取出错误，做断言，最后，递归地调用 <code>Temporary</code> 函数。如果错误没实现 <code>temporary</code> 接口，就会断言失败，返回 <code>false</code>。</p><h2 id="Only-handle-errors-once"><a href="#Only-handle-errors-once" class="headerlink" title="Only handle errors once"></a>Only handle errors once</h2><p>什么叫“处理”错误：</p><blockquote><p>Handling an error means inspecting the error value, and making a decision.</p></blockquote><p>意思是查看了一下错误，并且做出一个决定。</p><p>例如，如果不做任何决定，相当于忽略了错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;  w.Write(buf) </span><br><span class="line">w.Write(buf) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>w.Write(buf)</code> 会返回两个结果，一个表示写成功的字节数，一个是 error，上面的例子中没有对这两个返回值做任何处理。</p><p>下面这个例子却又处理了两次错误：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;  </span><br><span class="line"> _, err := w.Write(buf) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="comment">// annotated error goes to log file</span> </span><br><span class="line">log.Println(<span class="string">"unable to write:"</span>, err)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// unannotated error returned to caller</span>  <span class="keyword">return</span> err </span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次处理是将错误写进了日志，第二次处理则是将错误返回给上层调用者。而调用者也可能将错误写进日志或是继续返回给上层。</p><p>这样一来，日志文件中会有很多重复的错误描述，并且在最上层调用者（如 main 函数）看来，它拿到的错误却还是最底层函数返回的 error，没有任何上下文信息。</p><p>使用第三方的 error 包就可以比较完美的解决问题：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Write, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123; </span><br><span class="line">_, err := w.Write(buf) </span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"write failed"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的错误，对于人和机器而言，都是友好的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一部分主要讲了处理 error 的一些原则，引入了第三方的 errors 包，使得错误处理变得更加优雅。</p><p>作者最后给出了一些结论：</p><blockquote><ol><li>errors 就像对外提供的 API 一样，需要认真对待。</li><li>将 errors 看成黑盒，判断它的行为，而不是类型。</li><li>尽量不要使用 sentinel errors。</li><li>使用第三方的错误包来包裹 error（errors.Wrap），使得它更好用。</li><li>使用 errors.Cause 来获取底层的错误。</li></ol></blockquote><h1 id="胎死腹中的-try-提案"><a href="#胎死腹中的-try-提案" class="headerlink" title="胎死腹中的 try 提案"></a>胎死腹中的 try 提案</h1><p>之前已经出现用 “check &amp; handle” 关键字和 “try 内置函数”改进错误处理流程的提案，目前 try 内置函数的提案已经被官方提前拒绝，原因是社区里一边倒地反对声音。</p><p>关于这两个提案的具体内容见参考资料【check &amp; handle】和【try 提案】。</p><h1 id="go-1-13-的改进"><a href="#go-1-13-的改进" class="headerlink" title="go 1.13 的改进"></a>go 1.13 的改进</h1><p>有一些 Go 语言失败的尝试，比如 Go 1.5 引入的 vendor 和 internal 来管理包，最后被滥用而引发了很多问题。因此 Go 1.13 直接抛弃了 <code>GOPATH</code> 和 <code>vendor</code> 特性，改用 <code>module</code> 来管理包。</p><p>柴大在《Go 语言十年而立，Go2 蓄势待发》一文中表示：</p><blockquote><p>比如最近 Go 语言之父之一 Robert Griesemer 提交的通过 try 内置函数来简化错误处理就被否决了。失败的尝试是一个好的现象，它表示 Go 语言依然在一些新兴领域的尝试 —— Go 语言依然处于活跃期。</p></blockquote><p>今年 9 月 3 号，Go 发布 1.13 版本，除了 module 特性转正之外，还改进了数字字面量。比较重要的还有 defer 性能提升 30%，将更多的对象从堆上移动到栈上以提升性能，等等。</p><blockquote><p>还有一个重大的改进发生在 errors 标准库中。errors 库增加了 Is/As/Unwrap三个函数，这将用于支持错误的再次包装和识别处理，为 Go 2 中新的错误处理改进提前做准备。</p></blockquote><p><code>1.13</code> 支持了 <code>error</code> 包裹（wrapping）：</p><blockquote><p>An error e can wrap another error w by providing an Unwrap method that returns w. Both e and w are available to programs, allowing e to provide additional context to w or to reinterpret it while still allowing programs to make decisions based on w.</p></blockquote><p>为了支持 wrapping，<code>fmt.Errorf</code> 增加了 <code>%w</code> 的格式，并且在 <code>error</code> 包增加了三个函数：<code>errors.Unwrap</code>，<code>errors.Is</code>，<code>errors.As</code>。</p><h2 id="fmt-Errorf"><a href="#fmt-Errorf" class="headerlink" title="fmt.Errorf"></a>fmt.Errorf</h2><p>使用 <code>fmt.Errorf</code> 加上 <code>%w</code> 格式符来生成一个嵌套的 error，它并没有像 <code>pkg/errors</code> 那样使用一个 Wrap 函数来嵌套 error，非常简洁。</p><h2 id="Unwrap"><a href="#Unwrap" class="headerlink" title="Unwrap"></a>Unwrap</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>将嵌套的 error 解析出来，多层嵌套需要调用 <code>Unwrap</code> 函数多次，才能获取最里层的 error。</p><p>源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否实现了 Unwrap 方法</span></span><br><span class="line">u, ok := err.(<span class="keyword">interface</span> &#123;</span><br><span class="line">Unwrap() error</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果不是，返回 nil</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 Unwrap 方法返回被嵌套的 error</span></span><br><span class="line"><span class="keyword">return</span> u.Unwrap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 err 进行断言，看它是否实现了 Unwrap 方法，如果是，调用它的 Unwrap 方法。否则，返回 nil。</p><h2 id="Is"><a href="#Is" class="headerlink" title="Is"></a>Is</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>判断 err 是否和 target 是同一类型，或者 err 嵌套的 error 有没有和 target 是同一类型的，如果是，则返回 true。</p><p>源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err == target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isComparable := reflectlite.TypeOf(target).Comparable()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环，比较 err 以及嵌套的 error</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isComparable &amp;&amp; err == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 error 的 Is 方法，这里可以自定义实现</span></span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; Is(error) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回被嵌套的下一层的 error</span></span><br><span class="line"><span class="keyword">if</span> err = Unwrap(err); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个无限循环，使用 <code>Unwrap</code> 不断地将 err 里层嵌套的 error 解开，再看被解开的 error 是否实现了 Is 方法，并且调用它的 Is 方法，当两者都返回 true 的时候，整个函数返回 true。</p><h2 id="As"><a href="#As" class="headerlink" title="As"></a>As</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>从 err 错误链里找到和 target 相等的并且设置 target 所指向的变量。</p><p>源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// target 不能为 nil</span></span><br><span class="line"><span class="keyword">if</span> target == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"errors: target cannot be nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := reflectlite.ValueOf(target)</span><br><span class="line">typ := val.Type()</span><br><span class="line"></span><br><span class="line"><span class="comment">// target 必须是一个非空指针</span></span><br><span class="line"><span class="keyword">if</span> typ.Kind() != reflectlite.Ptr || val.IsNil() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"errors: target must be a non-nil pointer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证 target 是一个接口类型或者实现了 Error 接口</span></span><br><span class="line"><span class="keyword">if</span> e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"errors: *target must be interface or implement error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">targetType := typ.Elem()</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 使用反射判断是否可被赋值，如果可以就赋值并且返回true</span></span><br><span class="line"><span class="keyword">if</span> reflectlite.TypeOf(err).AssignableTo(targetType) &#123;</span><br><span class="line">val.Elem().Set(reflectlite.ValueOf(err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 error 自定义的 As 方法，实现自己的类型断言代码</span></span><br><span class="line"><span class="keyword">if</span> x, ok := err.(<span class="keyword">interface</span>&#123; As(<span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span> &#125;); ok &amp;&amp; x.As(target) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不断地 Unwrap，一层层的获取嵌套的 error</span></span><br><span class="line">err = Unwrap(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 true 的条件是错误链里的 err 能被赋值到 target 所指向的变量；或者 err 实现的 <code>As(interface{}) bool</code> 方法返回 true。</p><p>前者，会将 err 赋给 target 所指向的变量；后者，由 As 函数提供这个功能。</p><p>如果 target 不是一个指向“实现了 error 接口的类型或者其它接口类型”的非空的指针的时候，函数会 panic。</p><p>这一部分的内容，飞雪无情大佬的文章【飞雪无情 分析 1.13 错误】写得比较好，推荐阅读。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go 语言使用 error 和 panic 处理错误和异常是一个非常好的做法，比较清晰。至于是使用 error 还是 panic，看具体的业务场景。</p><p>当然，Go 中的 error 过于简单，以至于无法记录太多的上下文信息，对于错误包裹也没有比较好的办法。当然，这些可以通过第三方库来解决。官方也在新发布的 go 1.13 中对这一块作出了改进，相信在 Go 2 里会有更进一步的优化。</p><p>本文还列举了一些处理 error 的示例，例如不要两次处理一个错误，判断错误的行为而不是类型等等。</p><p>参考资料里列举了很多错误处理相关的示例，这篇文章作为一个引子。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【Go 2 错误提案】<a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p><p>【check &amp; handle】<a href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md</a></p><p>【错误讨论的 issue】<a href="https://github.com/golang/go/issues/29934" target="_blank" rel="noopener">https://github.com/golang/go/issues/29934</a></p><p>【error value 的 FAQ】<a href="https://github.com/golang/go/wiki/ErrorValueFAQ" target="_blank" rel="noopener">https://github.com/golang/go/wiki/ErrorValueFAQ</a></p><p>【error 包】<a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">https://golang.org/pkg/errors/</a></p><p>【飞雪无情的博客 错误处理】<a href="https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html" target="_blank" rel="noopener">https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html</a></p><p>【飞雪无情 分析 1.13 错误】<a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html" target="_blank" rel="noopener">https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html</a></p><p>【Tony Bai Go语言错误处理】<a href="https://tonybai.com/2015/10/30/error-handling-in-go/" target="_blank" rel="noopener">https://tonybai.com/2015/10/30/error-handling-in-go/</a></p><p>【Go 官方 error 使用教程】<a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a></p><p>【Go FAQ】<a href="https://golang.org/doc/faq#exceptions" target="_blank" rel="noopener">https://golang.org/doc/faq#exceptions</a></p><p>【ethancai 错误处理】<a href="https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/" target="_blank" rel="noopener">https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/</a></p><p>【Dave cheney GoCon 2016 演讲】<a href="https://dave.cheney.net/paste/gocon-spring-2016.pdf" target="_blank" rel="noopener">https://dave.cheney.net/paste/gocon-spring-2016.pdf</a></p><p>【Morsing’s Blog Effective error handling in Go】<a href="http://morsmachine.dk/error-handling" target="_blank" rel="noopener">http://morsmachine.dk/error-handling</a></p><p>【如何优雅的在Golang中进行错误处理】<a href="https://www.ituring.com.cn/article/508191" target="_blank" rel="noopener">https://www.ituring.com.cn/article/508191</a></p><p>【Go 2 错误处理提案：try 还是 check？】<a href="https://toutiao.io/posts/uh9qo7/preview" target="_blank" rel="noopener">https://toutiao.io/posts/uh9qo7/preview</a></p><p>【try 提案】<a href="https://github.com/golang/go/issues/32437" target="_blank" rel="noopener">https://github.com/golang/go/issues/32437</a></p><p>【否决 try 提案】<a href="https://github.com/golang/go/issues/32437#issuecomment-512035919" target="_blank" rel="noopener">https://github.com/golang/go/issues/32437#issuecomment-512035919</a></p><p>【Go 语言的错误处理机制是一个优秀的设计吗？】<a href="https://www.zhihu.com/question/27158146/answer/44676012" target="_blank" rel="noopener">https://www.zhihu.com/question/27158146/answer/44676012</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写过 C 的同学知道，C 语言中常常返回整数错误码（errno）来表示函数处理出错，通常用 &lt;code&gt;-1&lt;/code&gt; 来表示错误，用 &lt;code&gt;0&lt;/code&gt; 表示正确。&lt;/p&gt;
&lt;p&gt;而在 Go 中，我们使用 &lt;code&gt;error&lt;/code&gt; 类型来表示错误
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密调度器源码系列</title>
    <link href="https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/"/>
    <id>https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/</id>
    <published>2019-09-06T03:47:34.000Z</published>
    <updated>2019-10-21T01:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章从全局视角讲了 Go 的调度器，其实在这个过程中，我还阅读了 Go 的源码，并作了详细的讲解。</p><p>整个系列共 10 篇文章，深度解析调度器的源码。</p><h1 id="源码阅读系列"><a href="#源码阅读系列" class="headerlink" title="源码阅读系列"></a>源码阅读系列</h1><table><thead><tr><th>题目</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s/JOjUWp15JbEu54VJHY8i_A" target="_blank" rel="noopener">三足鼎立 —— GPM 到底是什么？（一）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/3xXU_O8-ZiA1Tk1nCnkODA" target="_blank" rel="noopener">开天辟地 —— Go scheduler 初始化（二）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/ipeLbEnKJ9BkOVtJv6ft0w" target="_blank" rel="noopener">粉墨登场 —— main goroutine 的诞生（三）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/sGR_VF13Czd9VuvHb-96iA" target="_blank" rel="noopener">偷天换日 —— g0 栈和用户栈如何完成切换？（四）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/pRCWOKlI48soY0deOWoSEw" target="_blank" rel="noopener">新官上任 —— Go sheduler 开始调度循环（五）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/kwKqrT4BoeheM9MvSh-rLw" target="_blank" rel="noopener">千难万险 —— goroutine 从生到死（六）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/QFmh0wq50H9-4ZrtEknpCQ" target="_blank" rel="noopener">生生死死 —— schedule 的轮回（七）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/6sNtrdlKtwfJIvBA8UPnKg" target="_blank" rel="noopener">锲而不舍 —— M 是怎样找工作的？（八）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/msJaDVyC-9ZbOef_wNac3A" target="_blank" rel="noopener">忠于职守 —— sysmon 线程到底做了什么？（九）</a></td></tr><tr><td><a href="https://mp.weixin.qq.com/s/Npbxth4AJxwO2g4bBx9lnA" target="_blank" rel="noopener">意犹未尽 —— GPM 的状态流转（十）</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章从全局视角讲了 Go 的调度器，其实在这个过程中，我还阅读了 Go 的源码，并作了详细的讲解。&lt;/p&gt;
&lt;p&gt;整个系列共 10 篇文章，深度解析调度器的源码。&lt;/p&gt;
&lt;h1 id=&quot;源码阅读系列&quot;&gt;&lt;a href=&quot;#源码阅读系列&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之scheduler</title>
    <link href="https://qcrao.com/2019/09/02/dive-into-go-scheduler/"/>
    <id>https://qcrao.com/2019/09/02/dive-into-go-scheduler/</id>
    <published>2019-09-02T09:06:06.000Z</published>
    <updated>2019-09-02T09:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，你还好吗？距离上一篇文章已经过去了一个多月了，迟迟未更新文章，我也很着急啊。</p><p>跟大家汇报一下，这段时间我在看 <code>proc.go</code> 的源码，其实就是调度器的源码。代码有几千行之多，不像以往的 map，channel 等等。想把这些代码都看明白，是一个庞大的工程。到今天为止，我也不敢说我都看明白了。</p><p>要深挖下去的话，会无穷无尽，所以阶段性的探索就到这里。接下来就把这段时间的探索分享出来。</p><p>其实，今天这篇文章仅仅算是一个引子，接下来会连续发布十篇系列文章。目录如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/64062086-50978e80-cc15-11e9-8689-23b0989b8d7b.png" alt="系列文章目录"></p><p>而这个系列的文章主要是受公众号“go 语言核心编程技术”的启发，它有一个 Go 调度器的系列教程，写得非常赞，强烈推荐大家去看，后面会经常引用到它的文章。我忍不住在这贴上公众号的二维码，一定要去关注啊。这是我在找资料的过程中发现的一个宝藏，本来想私藏着，但是好东西还是要分享给大家，不能固步自封。</p><p><img src="https://user-images.githubusercontent.com/7698088/64062187-2c887d00-cc16-11e9-8519-00b29f05933c.png" alt="Go 语言核心编程技术"></p><p>开始我们今天的正题。</p><p>一个月前，《Go 语言高级编程》作者柴树杉老师在 CSDN 上发表了一篇《Go 语言十年而立，Go2 蓄势待发》，视角十分宏大。我们既要低头看路，有时也要抬头看天，这篇文章就属于“抬头”看天类的，推荐阅读。</p><p>文章中提到了第一本写 Go 的小说《胡文 Go》。我找来看了下，嬉笑怒骂，还挺有意思的。书中有这样一句话：</p><blockquote><p>在 Go 语言里，go func 是并发的单元，chan 是协调并发单元的机制，panic 和 recover 是出错处理的机制，而 defer 是神来之笔，大大简化了出错的管理。</p></blockquote><p>Goroutines 在同一个用户空间里同时独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。</p><p>上一篇文章里我们讲了 channel，并且提到，goroutine 和 channel 是 Go 并发编程的两大基石，那这篇文章就聚焦到 goroutine，以及调度 goroutine 的 go scheduler。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="os-scheduler"><a href="#os-scheduler" class="headerlink" title="os scheduler"></a>os scheduler</h2><p>从操作系统角度看，我们写的程序最终都会转换成一系列的机器指令，机器只要按顺序执行完所有的指令就算完成了任务。完成“按顺序执行指令”任务的实体就是线程，也就是说，线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p><p>每个程序启动的时候，都会创建一个初始进程，并且启动一个线程。而线程可以去创建更多的线程，这些线程可以独立地执行，CPU 在这一层进行调度，而非进程。</p><p>OS scheduler 保证如果有可以执行的线程时，就不会让 CPU 闲着。并且它还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>OS scheduler 调度线程的依据就是它的状态，线程有三种状态（简化模型）：<code>Waiting</code>, <code>Runnable</code> or <code>Executing</code>。</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>Waiting</td><td>等待状态。线程在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes</td></tr><tr><td>Runnable</td><td>就绪状态。只要给 CPU 资源我就能运行</td></tr><tr><td>Executing</td><td>运行状态。线程在执行指令，这是我们想要的</td></tr></tbody></table><p>线程能做的事一般分为两种：计算型、IO 型。</p><p>计算型主要是占用 CPU 资源，一直在做计算任务，例如对一个大数做质数分解。这种类型的任务不会让线程跳到 Waiting 状态。</p><p>IO 型则是要获取外界资源，例如通过网络、系统调用等方式。内存同步访问控制原语：mutexes 也可以看作这种类型。共同特点是需要等待外界资源就绪。IO 型的任务会让线程跳到 Waiting 状态。</p><p>线程切换就是操作系统用一个处于 Runnable 的线程将 CPU 上正在运行的处于 Executing 状态的线程换下来的过程。新上场的线程会变成 Executing 状态，而下场的线程则可能变成 Waiting 或 Runnable 状态。正在做计算型任务的线程，会变成 Runnable 状态；正在做 IO 型任务的线程，则会变成 Waiting 状态。</p><p>因此，计算密集型任务和 IO 密集型任务对线程切换的“态度”是不一样的。由于计算型密集型任务一直都有任务要做，或者说它一直有指令要执行，线程切换的过程会让它停掉当前的任务，损失非常大。</p><p>相反，专注于 IO 密集型的任务的线程，如果它因为某个操作而跳到 Waiting 状态，那么把它从 CPU 上换下，对它而言是没有影响的。而且，新换上来的线程可以继续利用 CPU 完成任务。从整个操作系统来看，“工作进度”是往前的。</p><p>记住，对于 OS scheduler 来说，最重要的是不要让一个 CPU 核心闲着，尽量让每个 CPU 核心都有任务可做。</p><blockquote><p>If you have a program that is focused on IO-Bound work, then context switches are going to be an advantage. Once a Thread moves into a Waiting state, another Thread in a Runnable state is there to take its place. This allows the core to always be doing work. This is one of the most important aspects of scheduling. Don’t allow a core to go idle if there is work (Threads in a Runnable state) to be done.</p></blockquote><h2 id="函数调用过程分析"><a href="#函数调用过程分析" class="headerlink" title="函数调用过程分析"></a>函数调用过程分析</h2><p>要想理解 Go scheduler 的底层原理，对于函数调用过程的理解是必不可少的。它涉及到函数参数的传递，CPU 的指令跳转，函数返回值的传递等等。这需要对汇编语言有一定的了解，因为只有汇编语言才能进行像寄存器赋值这样的底层操作。之前的一些文章里也有说明，这里再来复习一遍。</p><blockquote><p>函数栈帧的空间主要由函数参数和返回值、局部变量和被调用其它函数的参数和返回值空间组成。</p></blockquote><p>宏观看一下，Go 语言中函数调用的规范，引用曹大博客里的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/64062685-390fd400-cc1c-11e9-86e5-a2646ce3ae1f.png" alt="曹大 asmshare 函数调用规范"></p><p>Go plan9 汇编通过栈传递函数参数和返回值。</p><p>调用子函数时，先将参数在栈顶准备好，再执行 CALL 指令。CALL 指令会将 IP 寄存器的值压栈，这个值就是函数调用完成后即将执行的下一条指令。</p><p>然后，就会进入被调用者的栈帧。首先会将 caller BP 压栈，这表示栈基址，也就是栈底。栈顶和栈基址定义函数的栈帧。</p><blockquote><p>CALL 指令类似 PUSH IP 和 JMP somefunc 两个指令的组合，首先将当前的 IP 指令寄存器的值压入栈中，然后通过 JMP 指令将要调用函数的地址写入到 IP 寄存器实现跳转。</p></blockquote><blockquote><p>而 RET 指令则是和 CALL 相反的操作，基本和 POP IP 指令等价，也就是将执行 CALL 指令时保存在 SP 中的返回地址重新载入到 IP 寄存器，实现函数的返回。</p></blockquote><blockquote><p>首先是调用函数前准备的输入参数和返回值空间。然后 CALL 指令将首先触发返回地址入栈操作。在进入到被调用函数内之后，汇编器自动插入了 BP 寄存器相关的指令，因此 BP 寄存器和返回地址是紧挨着的。再下面就是当前函数的局部变量的空间，包含再次调用其它函数需要准备的调用参数空间。被调用的函数执行 RET 返回指令时，先从栈恢复 BP 和 SP 寄存器，接着取出的返回地址跳转到对应的指令执行。</p></blockquote><p>上面两段描述来自《Go 语言高级编程》一书的汇编语言章节，说得很好，再次推荐阅读。</p><h1 id="goroutine-是怎么工作的"><a href="#goroutine-是怎么工作的" class="headerlink" title="goroutine 是怎么工作的"></a>goroutine 是怎么工作的</h1><h2 id="什么是-goroutine"><a href="#什么是-goroutine" class="headerlink" title="什么是 goroutine"></a>什么是 goroutine</h2><p>Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。</p><h2 id="goroutine-和-thread-的区别"><a href="#goroutine-和-thread-的区别" class="headerlink" title="goroutine 和 thread 的区别"></a>goroutine 和 thread 的区别</h2><p>谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？</p><p>参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、切换。</p><ul><li>内存占用</li></ul><p>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。</p><p>对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。</p><ul><li>创建和销毀</li></ul><p>Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</p><ul><li>切换</li></ul><p>当 threads 切换时，需要保存各种寄存器，以便将来恢复：</p><blockquote><p>16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.</p></blockquote><p>而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。</p><p>一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。</p><p>Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。</p><p>因此，goroutines 切换成本比 threads 要小得多。</p><h2 id="M-N-模型"><a href="#M-N-模型" class="headerlink" title="M:N 模型"></a>M:N 模型</h2><p>我们都知道，Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png" alt="M:N scheduling"></p><p>在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞（例如上篇文章提到的向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着，榨干 CPU 的每一滴油水。</p><h1 id="什么是-scheduler"><a href="#什么是-scheduler" class="headerlink" title="什么是 scheduler"></a>什么是 scheduler</h1><p>Go 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutines 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。</p><p>一个展现了全景式的关系如下图：</p><p><img src="https://user-images.githubusercontent.com/7698088/62172655-9981cc00-b365-11e9-8912-b16b83930ad0.png" alt="runtime overall"></p><h1 id="为什么要-scheduler"><a href="#为什么要-scheduler" class="headerlink" title="为什么要 scheduler"></a>为什么要 scheduler</h1><p>Go scheduler 可以说是 Go 运行时的一个最重要的部分了。Runtime 维护所有的 goroutines，并通过 scheduler 来进行调度。Goroutines 和 threads 是独立的，但是 goroutines 要依赖 threads 才能执行。</p><p>Go 程序执行的高效和 scheduler 的调度是分不开的。</p><h1 id="scheduler-底层原理"><a href="#scheduler-底层原理" class="headerlink" title="scheduler 底层原理"></a>scheduler 底层原理</h1><p>实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutines 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面。</p><p>有三个基础的结构体来实现 goroutines 的调度。g，m，p。</p><p><code>g</code> 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。</p><p><code>m</code> 表示内核线程，包含正在运行的 goroutine 等字段。</p><p><code>p</code> 代表一个虚拟的 Processor，它维护一个处于 Runnable 状态的 g 队列，<code>m</code> 需要获得 <code>p</code> 才能运行 <code>g</code>。</p><p>当然还有一个核心的结构体：<code>sched</code>，它总览全局。</p><p>Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。</p><p>当然，在 Go 的早期版本，并没有 p 这个结构体，<code>m</code> 必须从一个全局的队列里获取要运行的 <code>g</code>，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来在大神 Dmitry Vyokov 的实现里，加上了 <code>p</code> 结构体。每个 <code>p</code> 自己维护一个处于 Runnable 状态的 <code>g</code> 的队列，解决了原来的全局锁问题。</p><p>Go scheduler 的目标：</p><blockquote><p>For scheduling goroutines onto kernel threads.</p></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/61874535-3f26dc80-af1b-11e9-9d9c-127edf90fff9.png" alt="Go scheduler goals"></p><p>Go scheduler 的核心思想是：</p><ol><li>reuse threads；</li><li>限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目；</li><li>线程私有的 runqueues，并且可以从其他线程 stealing goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程。</li></ol><p>为什么需要 P 这个组件，直接把 runqueues 放到 M 不行吗？</p><blockquote><p>You might wonder now, why have contexts at all? Can’t we just put the runqueues on the threads and get rid of contexts? Not really. The reason we have contexts is so that we can hand them off to other threads if the running thread needs to block for some reason.</p></blockquote><blockquote><p>An example of when we need to block, is when we call into a syscall. Since a thread cannot both be executing code and be blocked on a syscall, we need to hand off the context so it can keep scheduling.</p></blockquote><p>翻译一下，当一个线程阻塞的时候，将和它绑定的 P 上的 goroutines 转移到其他线程。</p><p>Go scheduler 会启动一个后台线程 sysmon，用来检测长时间（超过 10 ms）运行的 goroutine，将其调度到 global runqueues。这是一个全局的 runqueue，优先级比较低，以示惩罚。</p><p><img src="https://user-images.githubusercontent.com/7698088/61874781-d55b0280-af1b-11e9-9965-da4efe53d2db.png" alt="Go scheduler limitations"></p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>通常讲到 Go scheduler 都会提到 GPM 模型，我们来一个个地看。</p><p>下图是我使用的 mac 的硬件信息，只有 2 个核。</p><p><img src="https://user-images.githubusercontent.com/7698088/62016049-63680f00-b1e2-11e9-9b6f-8566fd5e3963.png" alt="mac 硬件信息"></p><p>但是配上 CPU 的超线程，1 个核可以变成 2 个，所以当我在 mac 上运行下面的程序时，会打印出 4。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// NumCPU 返回当前进程可以用到的逻辑核心数</span></span><br><span class="line">fmt.Println(runtime.NumCPU())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 NumCPU 返回的是逻辑核心数，而非物理核心数，所以最终结果是 4。</p><p>Go 程序启动后，会给每个逻辑核心分配一个 P（Logical Processor）；同时，会给每个 P 分配一个 M（Machine，表示内核线程），这些内核线程仍然由 OS scheduler 来调度。</p><p>总结一下，当我在本地启动一个 Go 程序时，会得到 4 个系统线程去执行任务，每个线程会搭配一个 P。</p><p>在初始化时，Go 程序会有一个 G（initial Goroutine），执行指令的单位。G 会在 M 上得到执行，内核线程是在 CPU 核心上调度，而 G 则是在 M 上进行调度。</p><p>G、P、M 都说完了，还有两个比较重要的组件没有提到： 全局可运行队列（GRQ）和本地可运行队列（LRQ）。 LRQ 存储本地（也就是具体的 P）的可运行 goroutine，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。</p><p><img src="https://user-images.githubusercontent.com/7698088/62016513-336e3b00-b1e5-11e9-8923-d5d1743a531b.png" alt="GPM global review"></p><p>Go scheduler 是 Go runtime 的一部分，它内嵌在 Go 程序里，和 Go 程序一起运行。因此它运行在用户空间，在 kernel 的上一层。和 Os scheduler 抢占式调度（preemptive）不一样，Go scheduler 采用协作式调度（cooperating）。</p><blockquote><p>Being a cooperating scheduler means the scheduler needs well-defined user space events that happen at safe points in the code to make scheduling decisions.</p></blockquote><p>协作式调度一般会由用户设置调度点，例如 python 中的 yield 会告诉 Os scheduler 可以将我调度出去了。 </p><p>但是由于在 Go 语言里，goroutine 调度的事情是由 Go runtime 来做，并非由用户控制，所以我们依然可以将 Go scheduler 看成是抢占式调度，因为用户无法预测调度器下一步的动作是什么。</p><p>和线程类似，goroutine 的状态也是三种（简化版的）：</p><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td>Waiting</td><td>等待状态，goroutine 在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes</td></tr><tr><td>Runnable</td><td>就绪状态，只要给 M 我就可以运行</td></tr><tr><td>Executing</td><td>运行状态。goroutine 在 M 上执行指令，这是我们想要的</td></tr></tbody></table><p>下面这张 GPM 全局的运行示意图见得比较多，可以留着，看完后面的系列文章之后再回头来看，还是很有感触的：</p><p><img src="https://user-images.githubusercontent.com/7698088/62260181-a7a61a00-b443-11e9-849b-b597addeca57.png" alt="goroutine workflow"></p><h2 id="goroutine-调度时机"><a href="#goroutine-调度时机" class="headerlink" title="goroutine 调度时机"></a>goroutine 调度时机</h2><p>在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。</p><table><thead><tr><th>情形</th><th>说明</th></tr></thead><tbody><tr><td>使用关键字 <code>go</code></td><td>go 创建一个新的 goroutine，Go scheduler 会考虑调度</td></tr><tr><td>GC</td><td>由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存</td></tr><tr><td>系统调用</td><td>当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来</td></tr><tr><td>内存同步访问</td><td>atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行</td></tr></tbody></table><h2 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h2><p>Go scheduler 的职责就是将所有处于 runnable 的 goroutines 均匀分布到在 P 上运行的 M。</p><p>当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。看看这是什么精神！自己的工作做完了，为了全局的利益，主动为别人分担。这被称为 <code>Work-stealing</code>，Go 从 1.1 开始实现。</p><p>Go scheduler 使用 M:N 模型，在任一时刻，M 个 goroutines（G） 要分配到 N 个内核线程（M），这些 M 跑在个数最多为 GOMAXPROCS 的逻辑处理器（P）上。每个 M 必须依附于一个 P，每个 P 在同一时刻只能运行一个 M。如果 P 上的 M 阻塞了，那它就需要其他的 M 来运行 P 的 LRQ 里的 goroutines。</p><p><img src="https://user-images.githubusercontent.com/7698088/62031928-02a8f880-b21b-11e9-96a9-96820452463e.png" alt="GPM relatioship"></p><p>个人感觉，上面这张图比常见的那些用三角形表示 M，圆形表示 G，矩形表示 P 的那些图更生动形象。</p><p>实际上，Go scheduler 每一轮调度要做的工作就是找到处于 runnable 的 goroutines，并执行它。找的顺序如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runtime.schedule() &#123;</span><br><span class="line">    <span class="comment">// only 1/61 of the time, check the global runnable queue for a G.</span></span><br><span class="line">    <span class="comment">// if not found, check the local queue.</span></span><br><span class="line">    <span class="comment">// if not found,</span></span><br><span class="line">    <span class="comment">//     try to steal from other Ps.</span></span><br><span class="line">    <span class="comment">//     if not, check the global runnable queue.</span></span><br><span class="line">    <span class="comment">//     if not found, poll network.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到一个可执行的 goroutine 后，就会一直执行下去，直到被阻塞。</p><p>当 P2 上的一个 G 执行结束，它就会去 LRQ 获取下一个 G 来执行。如果 LRQ 已经空了，就是说本地可运行队列已经没有 G 需要执行，并且这时 GRQ 也没有 G 了。这时，P2 会随机选择一个 P（称为 P1），P2 会从 P1 的 LRQ “偷”过来一半的 G。</p><p><img src="https://user-images.githubusercontent.com/7698088/62033338-4ea96c80-b21e-11e9-9167-98767c03d2d9.png" alt="Work Stealing"></p><p>这样做的好处是，有更多的 P 可以一起工作，加速执行完所有的 G。</p><h2 id="同步-异步系统调用"><a href="#同步-异步系统调用" class="headerlink" title="同步/异步系统调用"></a>同步/异步系统调用</h2><p>当 G 需要进行系统调用时，根据调用的类型，它所依附的 M 有两种情况：<code>同步</code>和<code>异步</code>。</p><p>对于同步的情况，M 会被阻塞，进而从 P 上调度下来，P 可不养闲人，G 仍然依附于 M。之后，一个新的 M 会被调用到 P 上，接着执行 P 的 LRQ 里嗷嗷待哺的 G 们。一旦系统调用完成，G 还会加入到 P 的 LRQ 里，M 则会被“雪藏”，待到需要时再“放”出来。</p><p><img src="https://user-images.githubusercontent.com/7698088/62091677-b904f000-b2a4-11e9-8972-60ace0807ba4.png" alt="同步系统调用"></p><p>对于异步的情况，M 不会被阻塞，G 的异步请求会被“代理人” network poller 接手，G 也会被绑定到 network poller，等到系统调用结束，G 才会重新回到 P 上。M 由于没被阻塞，它因此可以继续执行 LRQ 里的其他 G。</p><p><img src="https://user-images.githubusercontent.com/7698088/62091486-c2da2380-b2a3-11e9-8cf9-0e63d7f774d8.png" alt="异步系统调用"></p><p>可以看到，异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。</p><blockquote><p>The ability to turn IO/Blocking work into CPU-bound work at the OS level is where we get a big win in leveraging more CPU capacity over time. </p></blockquote><p>Go scheduler 像一个非常苛刻的监工一样，不会让一个 M 闲着，总是会通过各种办法让你干更多的事。</p><blockquote><p>In Go, it’s possible to get more work done, over time, because the Go scheduler attempts to use less Threads and do more on each Thread, which helps to reduce load on the OS and the hardware.</p></blockquote><h2 id="scheduler-的陷阱"><a href="#scheduler-的陷阱" class="headerlink" title="scheduler 的陷阱"></a>scheduler 的陷阱</h2><p>由于 Go 语言是协作式的调度，不会像线程那样，在时间片用完后，由 CPU 中断任务强行将其调度走。对于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的“抢占标志位”，之后调度器会处理。但是设置标志位的时机只有在函数“序言”部分，对于没有函数调用的就没有办法了。</p><blockquote><p>Golang implements a co-operative partially preemptive scheduler. </p></blockquote><p>所以在某些极端情况下，会掉进一些陷阱。下面这个例子来自参考资料【scheduler 的陷阱】。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">threads := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; x++ &#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">"x ="</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：在死循环里出不来，不会输出最后的那条打印语句。</p><p>为什么？上面的例子会启动和机器的 CPU 核心数相等的 goroutine，每个 goroutine 都会执行一个无限循环。</p><p>创建完这些 goroutines 后，main 函数里执行一条 <code>time.Sleep(time.Second)</code> 语句。Go scheduler 看到这条语句后，简直高兴坏了，要来活了。这是调度的好时机啊，于是主 goroutine 被调度走。先前创建的 <code>threads</code> 个 goroutines，刚好“一个萝卜一个坑”，把 M 和 P 都占满了。</p><p>在这些 goroutine 内部，又没有调用一些诸如 <code>channel</code>，<code>time.sleep</code> 这些会引发调度器工作的事情。麻烦了，只能任由这些无限循环执行下去了。</p><p>解决的办法也有，把 threads 减小 1：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">threads := runtime.GOMAXPROCS(<span class="number">0</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123; x++ &#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">"x ="</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 0</span><br></pre></td></tr></table></figure><p>不难理解了吧，主 goroutine 休眠一秒后，被 go schduler 重新唤醒，调度到 M 上继续执行，打印一行语句后，退出。主 goroutine 退出后，其他所有的 goroutine 都必须跟着退出。所谓“覆巢之下 焉有完卵”，一损俱损。</p><p>至于为什么最后打印出的 x 为 0，之前的文章<a href="https://qcrao.com/2019/06/17/cch-says-memory-reorder/">《曹大谈内存重排》</a>里有讲到过，这里不再深究了。</p><p>还有一种解决办法是在 for 循环里加一句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123; x++ &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>同样可以让 main goroutine 有机会调度执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章，从宏观角度来看 Go 调度器，讲到了很多方面。接下来连续的 10 篇文章，我会深入源码，层层解析。敬请期待！</p><p>参考资料里有很多篇英文博客写得很好，当你掌握了基本原理后，看这些文章会有一种熟悉的感觉，讲得真好！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【知乎回答，怎样理解阻塞非阻塞与同步异步的区别】？<a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/241673170</a></p><p>【从零开始学架构 Reactor与Proactor】<a href="https://book.douban.com/subject/30335935/" target="_blank" rel="noopener">https://book.douban.com/subject/30335935/</a></p><p>【思否上 goalng 排名第二的大佬译文】<a href="https://segmentfault.com/a/1190000016038785" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016038785</a></p><p>【ardan labs】<a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html</a></p><p>【论文 Analysis of the Go runtime scheduler】<a href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</a></p><p>【译文传播很广的】<a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">https://morsmachine.dk/go-scheduler</a></p><p>【码农翻身文章】<a href="https://mp.weixin.qq.com/s/BV25ngvWgbO3_yMK7eHhew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BV25ngvWgbO3_yMK7eHhew</a></p><p>【goroutine 资料合集】<a href="https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/goroutines" target="_blank" rel="noopener">https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/goroutines</a></p><p>【大彬调度器系列文章】<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/" target="_blank" rel="noopener">http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/</a></p><p>【Scalable scheduler design doc 2012】<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.rvfa6uqbq68u" target="_blank" rel="noopener">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.rvfa6uqbq68u</a></p><p>【Go scheduler blog post】<a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">https://morsmachine.dk/go-scheduler</a></p><p>【work stealing】<a href="https://rakyll.org/scheduler/" target="_blank" rel="noopener">https://rakyll.org/scheduler/</a></p><p>【Tony Bai 也谈goroutine调度器】<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></p><p>【Tony Bai  调试实例分析】<a href="https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/" target="_blank" rel="noopener">https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/</a></p><p>【Tony Bai goroutine 是如何工作的】<a href="https://tonybai.com/2014/11/15/how-goroutines-work/" target="_blank" rel="noopener">https://tonybai.com/2014/11/15/how-goroutines-work/</a></p><p>【How Goroutines Work】<a href="https://blog.nindalf.com/posts/how-goroutines-work/" target="_blank" rel="noopener">https://blog.nindalf.com/posts/how-goroutines-work/</a></p><p>【知乎回答 什么是阻塞，非阻塞，同步，异步？】<a href="https://www.zhihu.com/question/26393784/answer/328707302" target="_blank" rel="noopener">https://www.zhihu.com/question/26393784/answer/328707302</a></p><p>【知乎文章 完全理解同步/异步与阻塞/非阻塞】<a href="https://zhuanlan.zhihu.com/p/22707398" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22707398</a></p><p>【The Go netpoller】<a href="https://morsmachine.dk/netpoller" target="_blank" rel="noopener">https://morsmachine.dk/netpoller</a></p><p>【知乎专栏 Head First of Golang Scheduler】<a href="https://zhuanlan.zhihu.com/p/42057783" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42057783</a></p><p>【鸟窝 五种 IO 模型】<a href="https://colobu.com/2019/07/26/IO-models/" target="_blank" rel="noopener">https://colobu.com/2019/07/26/IO-models/</a></p><p>【Go Runtime Scheduler】<a href="https://speakerdeck.com/retervision/go-runtime-scheduler?slide=32" target="_blank" rel="noopener">https://speakerdeck.com/retervision/go-runtime-scheduler?slide=32</a></p><p>【go-scheduler】<a href="https://povilasv.me/go-scheduler/#" target="_blank" rel="noopener">https://povilasv.me/go-scheduler/#</a></p><p>【追踪 scheduler】<a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html</a></p><p>【go tool trace 使用】<a href="https://making.pusher.com/go-tool-trace/" target="_blank" rel="noopener">https://making.pusher.com/go-tool-trace/</a></p><p>【goroutine 之旅】<a href="https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c" target="_blank" rel="noopener">https://medium.com/@riteeksrivastava/a-complete-journey-with-goroutines-8472630c7f5c</a></p><p>【介绍 concurreny 和 parallelism 区别的视频】<a href="https://www.youtube.com/watch?v=cN_DpYBzKso&amp;t=422s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=cN_DpYBzKso&amp;t=422s</a></p><p>【scheduler 的陷阱】<a href="http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler" target="_blank" rel="noopener">http://www.sarathlakshman.com/2016/06/15/pitfall-of-golang-scheduler</a></p><p>【boya 源码阅读】<a href="https://github.com/zboya/golang_runtime_reading/blob/master/src/runtime/proc.go" target="_blank" rel="noopener">https://github.com/zboya/golang_runtime_reading/blob/master/src/runtime/proc.go</a></p><p>【阿波张调度器系列教程】<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&amp;hid=1&amp;sn=8fc2b63f53559bc0cee292ce629c4788&amp;scene=18#wechat_redirect</a></p><p>【曹大 asmshare】<a href="https://github.com/cch123/asmshare/blob/master/layout.md" target="_blank" rel="noopener">https://github.com/cch123/asmshare/blob/master/layout.md</a></p><p>【Go调度器介绍和容易忽视的问题】<a href="https://www.cnblogs.com/CodeWithTxT/p/11370215.html" target="_blank" rel="noopener">https://www.cnblogs.com/CodeWithTxT/p/11370215.html</a></p><p>【最近发现的一位大佬的源码分析】<a href="https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/TOC.md" target="_blank" rel="noopener">https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/TOC.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不见，你还好吗？距离上一篇文章已经过去了一个多月了，迟迟未更新文章，我也很着急啊。&lt;/p&gt;
&lt;p&gt;跟大家汇报一下，这段时间我在看 &lt;code&gt;proc.go&lt;/code&gt; 的源码，其实就是调度器的源码。代码有几千行之多，不像以往的 map，channel 等等。想把这些
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之channel</title>
    <link href="https://qcrao.com/2019/07/22/dive-into-go-channel/"/>
    <id>https://qcrao.com/2019/07/22/dive-into-go-channel/</id>
    <published>2019-07-22T00:40:00.000Z</published>
    <updated>2019-12-23T02:36:40.719Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。</p><p>上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客园登上了 48 小时阅读排行榜，并且受到了编辑推荐，占据首页头条位置整整一天；在开发者头条首页精选的位置霸榜一周时间……</p><p><img src="https://user-images.githubusercontent.com/7698088/61573877-801c8c80-aae8-11e9-9f3c-c364ec4d2726.png" alt="博客园头条推荐"></p><p><img src="https://user-images.githubusercontent.com/7698088/61576219-ce8e5300-ab09-11e9-9c9d-1cb244475812.png" alt="开发者头条精选"></p><p>熟悉码农桃花源的朋友们都知道，这里每篇文章都很长，要花很长时间才能读完。但长并不是目的，把每个问题都讲深、讲透才是最重要的。首先我自己得完全理解才行，所以写每篇文章时我都会看很多参考资料，看源码，请教大牛，自己还要去写样例代码跑结果……从创建文稿到真正完成写作需要很长时间。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576233-05fcff80-ab0a-11e9-92a9-eef8fbd2f812.png" alt="写作时间"></p><p>做这些事情，无非是想力求我写出来的文字，都是我目前所能理解的最深层次。如果我暂时理解不了，我会说出来，或者不写进文章里面去，留到以后有能力的时候再来写。</p><p>我自己平时有这种体会：看微信公众号的文章都是想快速地看完，快速地拉到最后，目的快点开始看下一篇，新鲜感才能不断刺激大脑。有时候碰到长文很花时间，可能就没耐心看下去了，里面说的东西也觉得很难理解，可能直接就放弃了。但是，如果我知道一篇文章价值很高，就会选一个精力比较充沛的时间段，花整块时间看完，这时候反倒很容易看进去。这种情况下，潜意识里就会知道我今天是一定要读完这篇文章的，并且要把里面有价值的东西都吸收进来。</p><p>所以，对于码农桃花源的文章，我建议你收藏之后，找个空闲时间再好好看。</p><p>上周，我把 GitHub 项目 Go-Question 的内容整合成了开源电子书，阅读体验提升 N 倍，建议关注项目，现在已经 400 star 了，年底目标是 1k star。项目地址列在了参考资料里。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576338-9ab42d00-ab0b-11e9-9ea1-9efc3c661ae1.png" alt="GitBook"></p><p>另外，公众号的文章也可以使用微信读书看，体验也非常赞，并且可以放到书架上，每个公众号就是一本书，简直酷炫。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576313-2bd6d400-ab0b-11e9-8585-35b51d0493d8.png" alt="微信读书"></p><p>闲话最后，一直“吹”了很久的曹大，新书《Go 语言高级编程》出版了！书的另一位作者是柴树杉老师，这是给 Go 语言提交 pull 的人，他在 Go 语言上面的研究不用我多说了吧。我第一时间下了单，并且到曹大工位要了签名。</p> <img src="https://user-images.githubusercontent.com/7698088/61576352-cb946200-ab0b-11e9-9324-7cee1d74cf4a.png" width="600" height="400" alt="Go 语言高级编程" align="center"><p>这本书的推荐人有很多大佬，像许世伟，郝林，雨痕等，评价非常高。重点给大家看下雨痕老师对这本书的评价（上图第二排左侧图）：</p><blockquote><p>本书阐明了官方文档某些语焉不详的部分，有助于 Gopher 了解更多内在实现，以及日常工作中需要用到的 RPC、Web、分布式应用等内容。我认识本书作者之一曹春晖，对他的学习态度和能力颇为钦佩，因此推荐大家阅读本书。</p></blockquote><p>大家可能不知道，出书一点都不赚钱，但投入的精力却很大。但是像曹大在给读者的书签名时所说的：书籍是时代的生命。多少知识都是通过书本一代代传承！</p><p>搬过几次家就知道，纸质书太多，过程会比较痛苦。所以，我现在买纸书都会考虑再三。但是，这次我还是在第一时间下单了《Go 语言高级编程》。我也强烈推荐你买一本，支持原创者。</p><p>柴老师在武汉，我接触不多。但和曹大却是经常能见面（在同一个公司工作）。他本人经常活跃在各种微信群，社区，也非常乐于解答各种疑难杂症。他的博客：xargin.com。</p><p>好了，下面开始我们的正文。</p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>大家都知道著名的摩尔定律。1965 年，仙童公司的 Gordon Moore 发表文章，预测在未来十年，半导体芯片上的晶体管和电阻数量将每年增加一倍；1975 年，Moore 再次发表论文，将“每年”修改为“每两年”。这个预测在 2012 年左右基本是正确的。</p><p>但随着晶体管电路逐渐接近性能极限，摩尔定律终将走到尽头。靠增加晶体管数量来提高计算机的性能不灵了。于是，人们开始转换思路，用其他方法来提升计算机的性能，这就是多核计算机产生的原因。</p><p>这一招看起来还不错，但是人们又遇到了一个另一个定律的限制，那就是 Amdahl’s Law，它提出了一个模型用来衡量在并行模式下程序运行效率的提升。这个定律是说，一个程序能从并行上获得性能提升的上限取决于有多少代码必须写成串行的。</p><p>举个例子，对于一个和用户打交道的界面程序，它必须和用户打交道。用户点一个按钮，然后才能继续运行下一步，这必须是串行执行的。这种程序的运行效率就取决于和用户交互的速度，你有多少核都白瞎。用户就是不按下一步，你怎么办？</p><p>2000 年左右云计算兴起，人们可以方便地获取计算云上的资源，方便地水平扩展自己的服务，可以轻而易举地就调动多台机器资源甚至将计算任务分发到分布在全球范围的机器。但是也因此带来了很多问题和挑战。例如怎样在机器间进行通信、聚合结果等。最难的一个挑战是如何找到一个模型能用来描述 concurrent。</p><p>我们都知道，要想一段并发的代码没有任何 bug，是非常困难的。有些并发 bug 是在系统上线数年后才发现的，原因常常是很诡异的，比如用户数增加到了某个界限。</p><p>并发问题一般有下面这几种：</p><p>数据竞争。简单来说就是两个或多个线程同时读写某个变量，造成了预料之外的结果。</p><p>原子性。在一个定义好的上下文里，原子性操作不可分割。上下文的定义非常重要。有些代码，你在程序里看起来是原子的，如最简单的 i++，但在机器层面看来，这条语句通常需要几条指令来完成（Load，Incr，Store），不是不可分割的，也就不是原子性的。原子性可以让我们放心地构造并发安全的程序。</p><p>内存访问同步。代码中需要控制同时只有一个线程访问的区域称为临界区。Go 语言中一般使用 sync 包里的 Mutex 来完成同步访问控制。锁一般会带来比较大的性能开销，因此一般要考虑加锁的区域是否会频繁进入、锁的粒度如何控制等问题。</p><p>死锁。在一个死锁的程序里，每个线程都在等待其他线程，形成了一个首尾相连的尴尬局面，程序无法继续运行下去。</p><p>活锁。想象一下，你走在一条小路上，一个人迎面走来。你往左边走，想避开他；他做了相反的事情，他往右边走，结果两个都过不了。之后，两个人又都想从原来自己相反的方向走，还是同样的结果。这就是活锁，看起来都像在工作，但工作进度就是无法前进。</p><p>饥饿。并发的线程不能获取它所需要的资源以进行下一步的工作。通常是有一个非常贪婪的线程，长时间占据资源不释放，导致其他线程无法获得资源。</p><p>关于并发和并行的区别，引用一个经典的描述：</p><blockquote><p>并发是同一时间应对（dealing with）多件事情的能力。<br>并行是同一时间动手（doing）做多件事情的能力。</p></blockquote><p>雨痕老师《Go 语言学习笔记》上的解释：</p><blockquote><p>并发是指逻辑上具备同时处理多个任务的能力；并行则是物理上同时执行多个任务。</p></blockquote><p>而根据《Concurrency in Go》这本书，计算机的概念都是抽象的结果，并发和并行也不例外。它这样描述并发和并行的区别：</p><blockquote><p>Concurrency is a property of the code; parallelism is a property of the running program.</p></blockquote><p>并发是代码的特性，并行是正在运行的程序的特性。先忽略我拙劣的翻译。很新奇，不是吗？我也是第一次见到这样的说法，细想一下，还是很有道理的。</p><p>我们一直说写的代码是并发的或者是并行的，但是我们能提供什么保证吗？如果在只有一个核的机器上跑并行的代码，它还能并行吗？你就是再天才，也无法写出并行的程序。充其量也就是代码上看起来“并发”的，如此而已。</p><p>当然，表面上看起来还是并行的，但那不过 CPU 的障眼法，多个线程在分时共享 CPU 的资源，在一个粗糙的时间隔里看起来就是“并行”。</p><p>所以，我们实际上只能编写“并发”的代码，而不能编写“并行”的代码，而且只是希望并发的代码能够并行地执行。并发的代码能否并行，取决于抽象的层级：代码里的并发原语、runtime，操作系统（虚拟机、容器）。层级越来越底层，要求也越来越高。因此，我们谈并发或并行实际上要指定上下文，也就是抽象的层级。</p><p>《Concurrency in Go》书里举了一个例子：假如两个人同时打开电脑上的计算器程序，这两个程序肯定不会影响彼此，这就是并行。在这个例子中，上下文就是两个人的机器，而两个计算器进程就是并行的元素。</p><p>随着抽象层次的降低，并发模型实际上变得更难也更重要，而越低层次的并发模型对我们也越重要。要想并发程序正确地执行，就要深入研究并发模型。</p><p>在 Go 语言发布前，我们写并发代码时，考虑到的最底层抽象是：系统线程。Go 发布之后，在这条抽象链上，又加一个 goroutine。而且 Go 从著名的计算机科学家 Tony Hoare 那借来一个概念：channel。Tony Hoare 就是那篇著名文章《Communicating Sequential Processes》的作者。</p><p>看起来事情变得更加复杂，因为 Go 又引入了一个更底层的抽象，但事实并不是这样。因为 goroutine 并不是看起来的那样又抽象了一层，它其实是替代了系统线程。Gopher 在写代码的时候，并不会去关心系统线程，大部分时候只需要考虑到 goroutine 和 channel。当然有时候会用到一些共享内存的概念，一般就是指 sync 包里的东西，比如 sync.Mutex。</p><h2 id="什么是-CSP"><a href="#什么是-CSP" class="headerlink" title="什么是 CSP"></a>什么是 CSP</h2><p>CSP 经常被认为是 Go 在并发编程上成功的关键因素。CSP 全称是 “Communicating Sequential Processes”，这也是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。</p><p>在那篇文章发表的时代，人们正在研究模块化编程的思想，该不该用 goto 语句在当时是最激烈的议题。彼时，面向对象编程的思想正在崛起，几乎没什么人关心并发编程。</p><p>在文章中，CSP 也是一门自定义的编程语言，作者定义了输入输出语句，用于 processes 间的通信（communicatiton）。processes 被认为是需要输入驱动，并且产生输出，供其他 processes 消费，processes 可以是进程、线程、甚至是代码块。输入命令是：!，用来向 processes 写入；输出是：?，用来从 processes 读出。这篇文章要讲的 channel 正是借鉴了这一设计。</p><p>Hoare 还提出了一个 -&gt; 命令，如果 -&gt; 左边的语句返回 false，那它右边的语句就不会执行。</p><p>通过这些输入输出命令，Hoare 证明了如果一门编程语言中把 processes 间的通信看得第一等重要，那么并发编程的问题就会变得简单。</p><p>Go 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制（原文是 memory access synchronization）在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。</p><p>Go 一开始就把 CSP 的思想融入到语言的核心里，所以并发编程成为 Go 的一个独特的优势，而且很容易理解。</p><p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p><p>Goroutine 解放了程序员，让我们更能贴近业务去思考问题。而不用考虑各种像线程库、线程开销、线程调度等等这些繁琐的底层问题，goroutine 天生替你解决好了。</p><p>Channel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。</p><p>Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p><p>说明一下，前面这两部分的内容来自英文开源书《Concurrency In Go》，强烈推荐阅读。</p><p>引入结束，我们正式开始今天的主角：channel。</p><h1 id="什么是-channel"><a href="#什么是-channel" class="headerlink" title="什么是 channel"></a>什么是 channel</h1><p>Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p><p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供“先进先出”的特性；它还能影响 goroutine 的阻塞和唤醒。</p><p>相信大家一定见过一句话：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><p>不要通过共享内存来通信，而要通过通信来实现内存共享。</p><p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p><p>简直是一头雾水，这两句话难道不是同一个意思？</p><p>通过前面两节的内容，我个人这样理解这句话：前面半句说的是通过 sync 包里的一些组件进行并发编程；而后面半句则是说 Go 推荐使用 channel 进行并发编程。两者其实都是必要且有效的。实际上看完本文后面对 channel 的源码分析，你会发现，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。</p><p>关于是选择 sync 包里的底层并发编程原语还是 channel，《Concurrency In Go》这本书的第 2 章 “Go’s Philosophy on Concurrency” 里有一张决策树和详细的论述，再次推荐你去阅读。我把图贴出来：</p><p><img src="https://user-images.githubusercontent.com/7698088/61507065-e0db9480-aa16-11e9-9fab-2ba43ee90c95.png" alt="concurrency code decision tree"></p><h2 id="channel-实现-CSP"><a href="#channel-实现-CSP" class="headerlink" title="channel 实现 CSP"></a>channel 实现 CSP</h2><p>Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p><p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p><p>Channel 字面意义是“通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 声明一个双向通道</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 声明一个只能用于发送的通道</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 声明一个只能用于接收的通道</span></span><br></pre></td></tr></table></figure><p>单向通道的声明，用 <code>&lt;-</code> 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p><p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是“发送-&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要“宽松”一些，毕竟是带了“缓冲”光环。</p><h1 id="为什么要-channel"><a href="#为什么要-channel" class="headerlink" title="为什么要 channel"></a>为什么要 channel</h1><p>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p><p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p><p>要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。</p><h1 id="channel-实现原理"><a href="#channel-实现原理" class="headerlink" title="channel 实现原理"></a>channel 实现原理</h1><p>对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p><p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作“同步模式”，带缓冲的则称为“异步模式”。</p><p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p><p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p><p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>直接上源码（版本是 1.9.2）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// chan 里元素数量</span></span><br><span class="line">qcount   <span class="keyword">uint</span></span><br><span class="line"><span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span></span><br><span class="line"><span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line"><span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line"><span class="comment">// chan 中元素大小</span></span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line"><span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line"><span class="comment">// chan 中元素类型</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line"><span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line"><span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"><span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line"><span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于字段的含义都写在注释里了，再来重点说几个字段：</p><p><code>buf</code> 指向底层循环数组，只有缓冲型的 channel 才有。</p><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><p><code>sendq</code>，<code>recvq</code> 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><p><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179068-806ee080-a62d-11e9-818c-16af42025b1b.png" alt="chan data structure"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们知道，通道有两个方向，发送和接收。理论上来说，我们可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p><p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 有缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>通过<a href="https://mp.weixin.qq.com/s/obnnVkO2EiFnuXk_AIDHWw" target="_blank" rel="noopener">汇编</a>分析，我们知道，最终创建 chan 的函数是 <code>makechan</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span></span><br></pre></td></tr></table></figure><p>从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。</p><p>具体来看下代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略了检查 channel size，align 的代码</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="comment">// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）</span></span><br><span class="line"><span class="comment">// 只进行一次内存分配</span></span><br><span class="line"><span class="keyword">if</span> elem.kind&amp;kindNoPointers != <span class="number">0</span> || size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素</span></span><br><span class="line"><span class="comment">// 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct&#123;&#125;）</span></span><br><span class="line"><span class="keyword">if</span> size &gt; <span class="number">0</span> &amp;&amp; elem.size != <span class="number">0</span> &#123;</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// race detector uses this location for synchronization</span></span><br><span class="line"><span class="comment">// Also prevents us from pointing beyond the allocation (see issue 9401).</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct&#123;&#125;，也无影响</span></span><br><span class="line"><span class="comment">// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）</span></span><br><span class="line">c.buf = unsafe.Pointer(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 进行两次内存分配操作</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = newarray(elem, <span class="keyword">int</span>(size))</span><br><span class="line">&#125;</span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line"><span class="comment">// 循环数组长度</span></span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 hchan 指针</span></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 chan 后，内存在堆上分配，大概长这样：</p><p><img src="https://user-images.githubusercontent.com/7698088/61337268-4d179600-a867-11e9-98ac-f979e3da00a6.png" alt="make chan"></p><p>说明一下，这张图来源于 Gopher Con 上的一份 PPT，地址见参考资料。这份材料非常清晰易懂，推荐你去读。</p><p>接下来，我们用一个来自参考资料【深入 channel 底层】的例子来理解创建、发送、接收的整个过程。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">val := &lt;- a</span><br><span class="line">fmt.Println(<span class="string">"G1 received data: "</span>, val)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">val := &lt;- b</span><br><span class="line">fmt.Println(<span class="string">"G2 received data: "</span>, val)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> goroutineA(ch)</span><br><span class="line"><span class="keyword">go</span> goroutineB(ch)</span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。</p><p>程序第 14 行创建了一个非缓冲型的 channel，我们只看 chan 结构体中的一些重要字段，来从整体层面看一下 chan 的状态，一开始什么都没有：</p><p><img src="https://user-images.githubusercontent.com/7698088/61338760-91a63000-a86d-11e9-9c7e-edee8a594f66.png" alt="unbuffered chan"></p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>在继续分析前面小节的例子前，我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，也就能轻松理解具体的例子了。</p><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；一种不带  “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chanrecv1</code> 函数处理不带 “ok” 的情形，<code>chanrecv2</code> 则通过返回 “received” 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 <code>elem</code> 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。</p><p>无论如何，最终转向了 <code>chanrecv</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 省略 debug 内容 …………</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则，接收一个 nil 的 channel，goroutine 挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan receive (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 不会执行到这里</span></span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回</span></span><br><span class="line"><span class="comment">// 当我们观察到 channel 没准备好接收：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待</span></span><br><span class="line"><span class="comment">// 2. 缓冲型，但 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 之后，又观察到 closed == 0，即 channel 未关闭。</span></span><br><span class="line"><span class="comment">// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，</span></span><br><span class="line"><span class="comment">// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line"><span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line"><span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(unsafe.Pointer(c))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 从一个已关闭的 channel 执行接收操作，且未忽略返回值</span></span><br><span class="line"><span class="comment">// 那么接收的值将是一个该类型的零值</span></span><br><span class="line"><span class="comment">// typedmemclr 根据类型清理相应地址的内存</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从一个已关闭的 channel 接收，selected 会返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line"><span class="comment">// 这有可能是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line"><span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line"><span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line"><span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line"><span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line"><span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲型，buf 里有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码里，没有忽略要接收的值，不是 "&lt;- ch"，而是 "val &lt;- ch"，ep 指向 val</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line"><span class="comment">// 接收游标向前移动</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="comment">// 接收游标归零</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">c.qcount--</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="comment">// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line"><span class="comment">// 构造一个 sudog</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待接收数据的地址保存下来</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 进入channel 的等待接收队列</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan receive"</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被唤醒了，接着从这里继续执行一些扫尾工作</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。</p><ul><li><p>如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。</p></li><li><p>和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们观察到 channel 没准备好接收：</p><ol><li>非缓冲型，等待发送列队里没有 goroutine 在等待</li><li>缓冲型，但 buf 里没有元素</li></ol><p>之后，又观察到 closed == 0，即 channel 未关闭。</p><p>因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。</p><ul><li><p>接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。</p></li><li><p>接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。</p></li></ul><p>于是，调用 recv 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是非缓冲型的 channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未忽略接收的数据</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接拷贝数据，从 sender goroutine -&gt; receiver goroutine</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓冲型的 channel，但 buf 已满。</span></span><br><span class="line"><span class="comment">// 将循环数组 buf 队首的元素拷贝到接收数据的地址</span></span><br><span class="line"><span class="comment">// 将发送者的数据入队。实际上这时 revx 和 sendx 值相等</span></span><br><span class="line"><span class="comment">// 找到接收游标</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// …………</span></span><br><span class="line"><span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将发送者数据拷贝到 buf</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line"><span class="comment">// 更新游标值</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx</span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒发送的 goroutine。需要等到调度器的光临</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// dst is on our stack or the heap, src is on another stack.</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="keyword">uintptr</span>(dst), <span class="keyword">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则，就是缓冲型 channel，而 buf 又满了的情形。说明发送游标和接收游标重合了，因此需要先找到接收游标：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanbuf(c, i) is pointer to the i'th slot in the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="keyword">uint</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(c.buf, <span class="keyword">uintptr</span>(i)*<span class="keyword">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该处的元素拷贝到接收地址。然后将发送者待发送的数据拷贝到接收游标处。这样就完成了接收数据和发送数据的操作。接着，分别将发送游标和接收游标向前进一，如果发生“环绕”，再从 0 开始。</p><p>最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。</p><ul><li><p>然后，如果 channel 的 buf 里还有数据，说明可以比较正常地接收。注意，这里，即使是在 channel 已经关闭的情况下，也是可以走到这里的。这一步比较简单，正常地将 buf 里接收游标处的数据拷贝到接收数据的地址。</p></li><li><p>到了最后一步，走到这里来的情形是要阻塞的。当然，如果 block 传进来的值是 false，那就不阻塞，直接返回就好了。</p></li></ul><p>先构造一个 sudog，接着就是保存各种值了。注意，这里会将接收数据的地址存储到了 <code>elem</code> 字段，当被唤醒时，接收到的数据就会保存到这个字段指向的地址。然后将 sudog 添加到 channel 的 recvq 队列里。调用 goparkunlock 函数将 goroutine 挂起。</p><p>接下来的代码就是 goroutine 被唤醒后的各种收尾工作了。</p><p>我们继续之前的例子。前面说到第 14 行，创建了一个非缓冲型的 channel，接着，第 15、16 行分别创建了一个 goroutine，各自执行了一个接收操作。通过前面的源码分析，我们知道，这两个 goroutine （后面称为 G1 和 G2 好了）都会被阻塞在接收操作。G1 和 G2 会挂在 channel 的 recq 队列中，形成一个双向循环链表。</p><p>在程序的 17 行之前，chan 的整体数据结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179141-19eac200-a62f-11e9-836d-b6b95d52f6fb.png" alt="chan struct at the runtime"></p><p><code>buf</code> 指向一个长度为 0 的数组，qcount 为 0，表示 channel 中没有元素。重点关注 <code>recvq</code> 和 <code>sendq</code>，它们是 waitq 结构体，而 waitq 实际上就是一个双向链表，链表的元素是 sudog，里面包含 <code>g</code> 字段，<code>g</code> 表示一个 goroutine，所以 sudog 可以看成一个 goroutine。recvq 存储那些尝试读取 channel 但被阻塞的 goroutine，sendq 则存储那些尝试写入 channel，但被阻塞的 goroutine。</p><p>此时，我们可以看到，recvq 里挂了两个 goroutine，也就是前面启动的 G1 和 G2。因为没有 goroutine 接收，而 channel 又是无缓冲类型，所以 G1 和 G2 被阻塞。sendq 没有被阻塞的 goroutine。</p><p><code>recvq</code> 的数据结构如下。这里直接引用文章中的一幅图，用了三维元素，画得很好：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179210-d3966280-a630-11e9-8c73-5a22340910a6.png" alt="recvq structure"></p><p>再从整体上来看一下 chan 此时的状态：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340165-bbfaec00-a873-11e9-83de-66bc63e603f1.png" alt="chan state"></p><p>G1 和 G2 被挂起了，状态是 <code>WAITING</code>。关于 goroutine 调度器这块不是今天的重点，当然后面肯定会写相关的文章。这里先简单说下，goroutine 是用户态的协程，由 Go runtime 进行管理，作为对比，内核线程由 OS 进行管理。Goroutine 更轻量，因此我们可以轻松创建数万 goroutine。</p><p>一个内核线程可以管理多个 goroutine，当其中一个 goroutine 阻塞时，内核线程可以调度其他的 goroutine 来运行，内核线程本身不会阻塞。这就是通常我们说的 <code>M:N</code> 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png" alt="M:N scheduling"></p><p><code>M:N</code> 模型通常由三部分构成：M、P、G。M 是内核线程，负责运行 goroutine；P 是 context，保存 goroutine 运行所需要的上下文，它还维护了可运行（runnable）的 goroutine 列表；G 则是待运行的 goroutine。M 和 P 是 G 运行的基础。</p><p><img src="https://user-images.githubusercontent.com/7698088/61340473-1183c880-a875-11e9-9b3e-86f376d3ae55.png" alt="MGP"></p><p>继续回到例子。假设我们只有一个 M，当 G1（<code>go goroutineA(ch)</code>） 运行到 <code>val := &lt;- a</code> 时，它由本来的 running 状态变成了 waiting 状态（调用了 gopark 之后的结果）：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340756-45abb900-a876-11e9-8ac7-4c40b4c23253.png" alt="G1 running"></p><p>G1 脱离与 M 的关系，但调度器可不会让 M 闲着，所以会接着调度另一个 goroutine 来运行：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340787-67a53b80-a876-11e9-94a4-a6c3698eb8ed.png" alt="G1 waiting"></p><p>G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>接着上面的例子，G1 和 G2 现在都在 recvq 队列里了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">3</span></span><br></pre></td></tr></table></figure><p>第 17 行向 channel 发送了一个元素 3。</p><p>发送操作最终转化为 <code>chansend</code> 函数，直接上源码，同样大部分都注释了，可以看懂主流程：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 src/runtime/chan.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果 channel 是 nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 debug 相关……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁住 channel，并发安全</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 channel 关闭了</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 直接 panic</span></span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于缓冲型的 channel，如果还有缓冲空间</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// qp 指向 buf 的 sendx 位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据从 ep 处拷贝到 qp</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line"><span class="comment">// 发送游标值加 1</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="comment">// 如果发送游标值等于容量值，游标值归 0</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓冲区的元素数量加一</span></span><br><span class="line">c.qcount++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不需要阻塞，则直接返回错误</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前 goroutine 的指针</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 goroutine 进入发送等待队列</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 goroutine 被挂起</span></span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">"chan send"</span>, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里开始被唤醒了（channel 有机会可以发送了）</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被唤醒后，channel 关闭了。坑爹啊，panic</span></span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去掉 mysg 上绑定的 channel</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码注释地比较详细了，我们来详细看看。</p><ul><li><p>如果检测到 channel 是空的，当前 goroutine 会被挂起。</p></li><li><p>对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）</p></li></ul><p>对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) || (c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释里主要讲为什么这一块可以不加锁，我详细解释一下。<code>if</code> 条件里先读了两个变量：block 和 c.closed。block 是函数的参数，不会变；c.closed 可能被其他 goroutine 改变，因为没加锁嘛，这是“与”条件前面两个表达式。</p><p>最后一项，涉及到三个变量：c.dataqsiz，c.recvq.first，c.qcount。<code>c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil</code> 指的是非缓冲型的 channel，并且 recvq 里没有等待接收的 goroutine；<code>c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz</code> 指的是缓冲型的 channel，但循环数组已经满了。这里 <code>c.dataqsiz</code> 实际上也是不会被修改的，在创建的时候就已经确定了。不加锁真正影响地是 <code>c.qcount</code> 和 <code>c.recvq.first</code>。</p><p>这一部分的条件就是两个 <code>word-sized read</code>，就是读两个 word 操作：<code>c.closed</code> 和 <code>c.recvq.first</code>（非缓冲型） 或者 <code>c.qcount</code>（缓冲型）。</p><p>当我们发现 <code>c.closed == 0</code> 为真，也就是 channel 未被关闭，再去检测第三部分的条件时，观测到 <code>c.recvq.first == nil</code> 或者 <code>c.qcount == c.dataqsiz</code> 时（这里忽略 <code>c.dataqsiz</code>），就断定要将这次发送操作作失败处理，快速返回 false。</p><p>这里涉及到两个观测项：channel 未关闭、channel not ready for sending。这两项都会因为没加锁而出现观测前后不一致的情况。例如我先观测到 channel 未被关闭，再观察到 channel not ready for sending，这时我以为能满足这个 if 条件了，但是如果这时 c.closed 变成 1，这时其实就不满足条件了，谁让你不加锁呢！</p><p>但是，因为一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’，所以当我观测到 ‘not ready for sending’ 时，channel 不是 closed。即使 <code>c.closed == 1</code>，即 channel 是在这两个观测中间被关闭的，那也说明在这两个观测中间，channel 满足两个条件：<code>not closed</code> 和 <code>not ready for sending</code>，这时，我直接返回 false 也是没有问题的。</p><p>这部分解释地比较绕，其实这样做的目的就是少获取一次锁，提升性能。</p><ul><li><p>如果检测到 channel 已经关闭，直接 panic。</p></li><li><p>如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 <code>sendDirect</code> 函数完成。</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send 函数处理向一个空的 channel 发送操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine</span></span><br><span class="line"><span class="comment">// 之后，接收的 goroutine 会被唤醒</span></span><br><span class="line"><span class="comment">// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）</span></span><br><span class="line"><span class="comment">// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁</span></span><br><span class="line"><span class="comment">// sg 必须已经从等待队列里取出来了</span></span><br><span class="line"><span class="comment">// ep 必须是非空，并且它指向堆或调用者的栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 省略一些用不到的</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接拷贝内存（从发送者到接收者）</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sudog 上绑定的 goroutine</span></span><br><span class="line">gp := sg.g</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>sendDirect</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel</span></span><br><span class="line"><span class="comment">// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈</span></span><br><span class="line"><span class="comment">// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写</span></span><br><span class="line"><span class="comment">// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接进行内存"搬迁"</span></span><br><span class="line"><span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line"><span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line"><span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="keyword">uintptr</span>(dst), <span class="keyword">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。</p><p>然后，解锁、唤醒接收者，等待调度器的光临，接收者也得以重见天日，可以继续执行接收操作之后的代码了。</p><ul><li>如果 <code>c.qcount &lt; c.dataqsiz</code>，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回循环队列里第 i 个元素的地址处</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanbuf</span><span class="params">(c *hchan, i <span class="keyword">uint</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> add(c.buf, <span class="keyword">uintptr</span>(i)*<span class="keyword">uintptr</span>(c.elemsize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c.sendx</code> 指向下一个待发送元素在循环数组中的位置，然后调用 <code>typedmemmove</code> 函数将其拷贝到循环数组中。之后 <code>c.sendx</code> 加 1，元素总量加 1 ：<code>c.qcount++</code>，最后，解锁并返回。</p><ul><li><p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。</p></li><li><p>最后就是真的需要被阻塞的情况。先构造一个 sudog，将其入队（channel 的 sendq 字段）。然后调用 <code>goparkunlock</code> 将当前 goroutine 挂起，并解锁，等待合适的时机再唤醒。</p></li></ul><p>唤醒之后，从 <code>goparkunlock</code> 下一行代码开始继续往下执行。</p><p>这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 <code>elem</code> 字段绑定待发送元素的地址，以及 <code>c</code> 字段绑定被“坑”在此处的 channel。</p><p>所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。</p><p>好了，看完源码。我们接着来分析例子，相信大家已经把例子忘得差不多了，我再贴一下代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">val := &lt;- a</span><br><span class="line">fmt.Println(<span class="string">"goroutine A received data: "</span>, val)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineB</span><span class="params">(b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">val := &lt;- b</span><br><span class="line">fmt.Println(<span class="string">"goroutine B received data: "</span>, val)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> goroutineA(ch)</span><br><span class="line"><span class="keyword">go</span> goroutineB(ch)</span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送小节里我们说到 G1 和 G2 现在被挂起来了，等待 sender 的解救。在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。</p><p>根据前面源码分析的结果，我们知道，sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。</p><p>然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。</p><p><img src="https://user-images.githubusercontent.com/7698088/61342598-4bf16380-a87d-11e9-8667-c22b02030d6b.png" alt="G1 runnable"></p><p>当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。</p><p>这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！</p><p><img src="https://user-images.githubusercontent.com/7698088/61342620-64fa1480-a87d-11e9-8cac-eacd2f4892f8.png" alt="send direct"></p><p>上图是一个示意图，<code>3</code> 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>关闭某个 channel，会执行函数 <code>closechan</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个 nil channel，panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 如果 channel 已经关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="comment">// panic</span></span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …………</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改关闭状态</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 channel 所有等待接收队列的里 sudog 释放</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 从接收队列里出队一个 sudog</span></span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="comment">// 出队完毕，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 elem 不为空，说明此 receiver 未忽略接收数据</span></span><br><span class="line"><span class="comment">// 给它赋一个相应类型的零值</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出 goroutine</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相连，形成链表</span></span><br><span class="line">gp.schedlink.set(glist)</span><br><span class="line">glist = gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 channel 等待发送队列里的 sudog 释放</span></span><br><span class="line"><span class="comment">// 如果存在，这些 goroutine 将会 panic</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 从发送队列里出队一个 sudog</span></span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送者会 panic</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, unsafe.Pointer(c))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 形成链表</span></span><br><span class="line">gp.schedlink.set(glist)</span><br><span class="line">glist = gp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 取最后一个</span></span><br><span class="line">gp := glist</span><br><span class="line"><span class="comment">// 向前走一步，下一个唤醒的 g</span></span><br><span class="line">glist = glist.schedlink.ptr()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line"><span class="comment">// 唤醒相应 goroutine</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。</p><p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p><p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p><h1 id="channel-进阶"><a href="#channel-进阶" class="headerlink" title="channel 进阶"></a>channel 进阶</h1><p>总结一下操作 channel 的结果：</p><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table><p>总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><p>读、写一个 nil channel 都会被阻塞。</p><h2 id="发送和接收元素的本质"><a href="#发送和接收元素的本质" class="headerlink" title="发送和接收元素的本质"></a>发送和接收元素的本质</h2><p>Channel 发送和接收元素的本质是什么？参考资料【深入 channel 底层】里是这样回答的：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><p>就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p><p>这里再引用文中的一个例子，我会加上更加详细地解释。顺带说一下，这是一篇英文的博客，写得很好，没有像我们这篇文章那样大段的源码分析，它是将代码里情况拆开来各自描述的，各有利弊吧。推荐去读下原文，阅读体验比较好。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">"Ankur"</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"modifyUser Received Vaule"</span>, pu)</span><br><span class="line">pu.name = <span class="string">"Anand"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"printUser goRoutine called"</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">c &lt;- g</span><br><span class="line">fmt.Println(g)</span><br><span class="line"><span class="comment">// modify g</span></span><br><span class="line">g = &amp;user&#123;name: <span class="string">"Ankur Anand"</span>, age: <span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">go</span> printUser(c)</span><br><span class="line"><span class="keyword">go</span> modifyUser(g)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;Ankur 25&#125;</span><br><span class="line">modifyUser Received Value &amp;&#123;Ankur Anand 100&#125;</span><br><span class="line">printUser goRoutine called &amp;&#123;Ankur 25&#125;</span><br><span class="line">&amp;&#123;Anand 100&#125;</span><br></pre></td></tr></table></figure><p>这里就是一个很好的 <code>share memory by communicating</code> 的例子。</p><p><img src="https://user-images.githubusercontent.com/7698088/61191276-16ad1000-a6db-11e9-9729-cdea7744f002.png" alt="output"></p><p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><p>再强调一次：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>Channel 可能会引发 goroutine 泄漏。</p><p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p><p>雨痕老师的《Go 语言学习笔记》第 8 章通道的“资源泄露”一节举了个例子，大家可以自己去看。</p><h2 id="happened-before"><a href="#happened-before" class="headerlink" title="happened before"></a>happened before</h2><p>维基百科上给的定义：</p><blockquote><p>In computer science, the happened-before relation (denoted: -&gt;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow).</p></blockquote><p>简单来说就是如果事件 a 和事件 b 存在 happened-before 关系，即 a -&gt; b，那么 a，b 完成后的结果一定要体现这种关系。由于现代编译器、CPU 会做各种优化，包括编译器重排、内存重排等等，在并发代码里，happened-before 限制就非常重要了。</p><p>根据晃岳攀老师在 Gopher China 2019 上的并发编程分享，关于 channel 的发送（send）、发送完成（send finished）、接收（receive）、接收完成（receive finished）的 happened-before 关系如下：</p><ol><li>第 n 个 <code>send</code> 一定 <code>happened before</code> 第 n 个 <code>receive finished</code>，无论是缓冲型还是非缓冲型的 channel。</li><li>对于容量为 m 的缓冲型 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</li><li>对于非缓冲型的 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n 个 <code>send finished</code>。</li><li>channel close 一定 <code>happened before</code> receiver 得到通知。</li></ol><p>我们来逐条解释一下。</p><p>第一条，我们从源码的角度看也是对的，send 不一定是 <code>happened before</code> receive，因为有时候是先 receive，然后 goroutine 被挂起，之后被 sender 唤醒，send happened after receive。但不管怎样，要想完成接收，一定是要先有发送。</p><p>第二条，缓冲型的 channel，当第 n+m 个 send 发生后，有下面两种情况：</p><p>若第 n 个 receive 没发生。这时，channel 被填满了，send 就会被阻塞。那当第 n 个 receive 发生时，sender goroutine 会被唤醒，之后再继续发送过程。这样，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</p><p>若第 n 个 receive 已经发生过了，这直接就符合了要求。</p><p>第三条，也是比较好理解的。第 n 个 send 如果被阻塞，sender goroutine 挂起，第 n 个 receive 这时到来，先于第 n 个 send finished。如果第 n 个 send 未被阻塞，说明第 n 个 receive 早就在那等着了，它不仅 happened before send finished，它还 happened before send。</p><p>第四条，回忆一下源码，先设置完 closed = 1，再唤醒等待的 receiver，并将零值拷贝给 receiver。</p><p>参考资料【鸟窝 并发编程分享】这篇博文的评论区有 PPT 的下载链接，这是晁老师在 Gopher 2019 大会上的演讲。</p><p>关于 happened before，这里再介绍一个柴大和曹大的新书《Go 语言高级编程》里面提到的一个例子。</p><p>书中 1.5 节先讲了顺序一致性的内存模型，这是并发编程的基础。</p><p>我们直接来看例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aGoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg = <span class="string">"hello, world"</span></span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> aGoroutine()</span><br><span class="line">&lt;-done</span><br><span class="line"><span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义了一个 done channel 和一个待打印的字符串。在 main 函数里，启动一个 goroutine，等待从 done 里接收到一个值后，执行打印 msg 的操作。如果 main 函数中没有 <code>&lt;-done</code> 这行代码，打印出来的 msg 为空，因为 aGoroutine 来不及被调度，还来不及给 msg 赋值，主程序就会退出。而在 Go 语言里，主协程退出时不会等待其他协程。</p><p>加了 <code>&lt;-done</code> 这行代码后，就会阻塞在此。等 aGoroutine 里向 done 发送了一个值之后，才会被唤醒，继续执行打印 msg 的操作。而这在之前，msg 已经被赋值过了，所以会打印出 <code>hello, world</code>。</p><p>这里依赖的 happened before 就是前面讲的第一条。第一个 send 一定 happened before 第一个 receive finished，即 <code>done &lt;- true</code> 先于 <code>&lt;-done</code> 发生，这意味着 main 函数里执行完 <code>&lt;-done</code> 后接着执行 <code>println(msg)</code> 这一行代码时，msg 已经被赋过值了，所以会打印出想要的结果。</p><p>书中，又进一步利用前面提到的第 3 条 happened before 规则，修改了一下代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aGoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg = <span class="string">"hello, world"</span></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> aGoroutine()</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line"><span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以得到相同的结果，为什么？根据第三条规则，对于非缓冲型的 channel，第一个 receive 一定 happened before 第一个 send finished。也就是说，<br>在 <code>done &lt;- true</code> 完成之前，<code>&lt;-done</code> 就已经发生了，也就意味着 msg 已经被赋上值了，最终也会打印出 <code>hello, world</code>。</p><h2 id="如何优雅地关闭-channel"><a href="#如何优雅地关闭-channel" class="headerlink" title="如何优雅地关闭 channel"></a>如何优雅地关闭 channel</h2><p>这部分内容主要来自 Go 101 上的一篇英文文章，参考资料【如何优雅地关闭 channel】可以直达原文。</p><p>文章先“吐槽”了下 Go channel 在设计上的一些问题，接着给出了几种不同情况下如何优雅地关闭 channel 的例子。按照惯例，我会在原作者内容的基础上给出自己的解读，看完这一节你可以再回头看一下英文原文，会觉得很有意思。</p><p>关于 channel 的使用，有几点不方便的地方：</p><ol><li>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。</li><li>关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。</li><li>向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。</li></ol><p>文中还真的就给出了一个检查 channel 是否关闭的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line">fmt.Println(IsClosed(c)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">fmt.Println(IsClosed(c)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下代码，其实存在很多问题。首先，IsClosed 函数是一个有副作用的函数。每调用一次，都会读出 channel 里的一个元素，改变了 channel 的状态。这不是一个好的函数，干活就干活，还顺手牵羊！</p><p>其次，IsClosed 函数返回的结果仅代表调用那个瞬间，并不能保证调用之后会不会有其他 goroutine 对它进行了一些操作，改变了它的这种状态。例如，IsClosed 函数返回 true，但这时有另一个 goroutine 关闭了 channel，而你还拿着这个过时的 “channel 未关闭”的信息，向其发送数据，就会导致 panic 的发生。当然，一个 channel 不会被重复关闭两次，如果 IsClosed 函数返回的结果是 true，说明 channel 是真的关闭了。</p><p>有一条广泛流传的关闭 channel 的原则：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</p><p>比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。</p><p>但是上面所说的并不是最本质的，最本质的原则就只有一条：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><p>有两个不那么优雅地关闭 channel 的方法：</p><ol><li><p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</p></li><li><p>使用 sync.Once 来保证只关闭一次。</p></li></ol><p>代码我就不贴上来了，直接去看原文。</p><p>这一节的重头戏来了，那应该如何优雅地关闭 channel？</p><p>根据 sender 和 receiver 的个数，分下面几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><p>第 3 种情形下，优雅关闭 channel 的方法是：the only receiver says “please stop sending more” by closing an additional signal channel。</p><p>解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。我把代码修改地更简洁了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// senders</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- rand.Intn(Max):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the receiver</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"send stop signal to senders."</span>)</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 stopCh 就是信号 channel，它本身只有一个 sender，因此可以直接关闭它。senders 收到了关闭信号后，select 分支 “case &lt;- stopCh” 被选中，退出函数，不再发送数据。</p><p>需要说明的是，上面的代码并没有明确关闭 dataCh。在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭 channel，让 gc 代劳。</p><p>最后一种情况，优雅关闭 channel 的方法是：any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel。</p><p>和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// It must be a buffered channel.</span></span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// moderator</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stoppedBy = &lt;-toStop</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// senders</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">value := rand.Intn(Max)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"sender#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// receivers</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"receiver#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里 toStop 就是中间人的角色，使用它来接收 senders 和 receivers 发送过来的关闭 dataCh 请求。</p><p>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><p>如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, NumReceivers + NumSenders)</span><br><span class="line">...</span><br><span class="line">value := rand.Intn(Max)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">toStop &lt;- <span class="string">"sender#"</span> + id</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">toStop &lt;- <span class="string">"receiver#"</span> + id</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。</p><p>可以看到，这里同样没有真正关闭 dataCh，原样同第 3 种情况。</p><p>以上，就是最基本的一些情形，但已经能覆盖几乎所有的情况及其变种了。只要记住：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>以及更本质的原则：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><h2 id="关闭的-channel-仍能读出数据"><a href="#关闭的-channel-仍能读出数据" class="headerlink" title="关闭的 channel 仍能读出数据"></a>关闭的 channel 仍能读出数据</h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">ch &lt;- <span class="number">18</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"received: "</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"channel closed, data invalid."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">received:  <span class="number">18</span></span><br><span class="line">channel closed, data invalid.</span><br></pre></td></tr></table></figure><p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><h1 id="channel-应用"><a href="#channel-应用" class="headerlink" title="channel 应用"></a>channel 应用</h1><p>Channel 和 goroutine 的结合是 Go 并发编程的大杀器。而 Channel 的实际应用也经常让人眼前一亮，通过与 select，cancel，timer 等结合，它能实现各种各样的功能。接下来，我们就要梳理一下 channel 的应用。</p><h2 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h2><p>前面一节如何优雅关闭 channel 那一节已经讲得很多了，这块就略过了。</p><p>channel 用于停止信号的场景还是挺多的，经常是关闭某个 channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作。</p><h2 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h2><p>与 timer 结合，一般有两种玩法：实现超时控制，实现定期执行某个任务。</p><p>有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line"><span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><p>定时执行某个任务，也比较简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ticker:</span><br><span class="line"><span class="comment">// 执行定时任务</span></span><br><span class="line">fmt.Println(<span class="string">"执行 1s 定时任务"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔 1 秒种，执行一次定时任务。</p><h2 id="解耦生产方和消费方"><a href="#解耦生产方和消费方" class="headerlink" title="解耦生产方和消费方"></a>解耦生产方和消费方</h2><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for {}</code> 无限循环里，从某个 channel 消费工作任务并执行：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 塞任务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">taskCh &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 小时 </span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line"><span class="comment">// 启动 5 个工作协程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := &lt;- taskCh</span><br><span class="line">fmt.Printf(<span class="string">"finish task: %d by worker %d\n"</span>, task, id)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><p>程序输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">finish task: 1 by worker 4</span><br><span class="line">finish task: 2 by worker 2</span><br><span class="line">finish task: 4 by worker 3</span><br><span class="line">finish task: 3 by worker 1</span><br><span class="line">finish task: 0 by worker 0</span><br><span class="line">finish task: 6 by worker 0</span><br><span class="line">finish task: 8 by worker 3</span><br><span class="line">finish task: 9 by worker 1</span><br><span class="line">finish task: 7 by worker 4</span><br><span class="line">finish task: 5 by worker 2</span><br></pre></td></tr></table></figure><h2 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h2><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><p>下面的例子来自《Go 语言高级编程》：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><p>这里，<code>limit &lt;- 1</code> 放在 func 内部而不是外部，书籍作者柴大在读者群里的解释是：</p><blockquote><p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。</p></blockquote><blockquote><p>limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p></blockquote><p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，你也终于看完了，恭喜！</p><p>回顾一下，这篇文章先从并发和并行讲起，又讲到了 CSP，Go 语言用 channel 实现 CSP。接着讲了什么是 channel，为什么需要 channel，然后详细分析了 channel 的实现原理，这也是全文最重要的部分。之后，又讲了几个进阶的例子，最后，列举了几个 channel 应用的场景。</p><p>希望大家能借助本文去读一下 Go 源码，这部分源码也不长，和 context 包一样，短小精悍，值得一读。</p><p>我在参考资料里列举了很多文章、书籍，很多都值得去细看，我在文中也有提及。</p><p>当你理解这 channel 的底层原理后，再去看这些英文文章，会觉得很有意思。以前对他有一种“畏难”心理，理解了之后再读，就会觉得很有意思，因为你确实都能看懂。</p><p>最后，阅读愉快！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【Concurrency In Go】<a href="https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf" target="_blank" rel="noopener">https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf</a></p><p>【Go 语言高级编程开源书】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【简洁清晰明了】<a href="http://litang.me/post/golang-channel/" target="_blank" rel="noopener">http://litang.me/post/golang-channel/</a></p><p>【柴大 &amp;&amp; 曹大 《Go语言高级编程》】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【Go 并发编程实战】<a href="https://book.douban.com/subject/26244729/" target="_blank" rel="noopener">https://book.douban.com/subject/26244729/</a></p><p>【曹大 golang notes】<a href="https://github.com/cch123/golang-notes/blob/master/channel.md" target="_blank" rel="noopener">https://github.com/cch123/golang-notes/blob/master/channel.md</a></p><p>【互联网技术窝 图解 channel 实现 动画】<a href="https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg</a></p><p>【一起学 Golang，推荐的资料非常有用】<a href="https://segmentfault.com/a/1190000018385779" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018385779</a></p><p>【如何优雅地关闭 channel】<a href="https://go101.org/article/channel-closing.html" target="_blank" rel="noopener">https://go101.org/article/channel-closing.html</a></p><p>【深入 channel 底层】<a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="noopener">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></p><p>【Kavya在Gopher Con 上关于 channel 的设计，非常好】<a href="https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf" target="_blank" rel="noopener">https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf</a></p><p>【channel 应用】<a href="https://www.s0nnet.com/archives/go-channels-practice" target="_blank" rel="noopener">https://www.s0nnet.com/archives/go-channels-practice</a></p><p>【应用举例】<a href="https://zhuyasen.com/post/go_queue.html" target="_blank" rel="noopener">https://zhuyasen.com/post/go_queue.html</a></p><p>【应用】<a href="https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/" target="_blank" rel="noopener">https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/</a></p><p>【鸟窝 并发编程分享】<a href="https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/" target="_blank" rel="noopener">https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/</a></p><p>【Go-Questions，码农桃花源项目】<a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">https://github.com/qcrao/Go-Questions</a></p><p>【GitBook 码农桃花源开源书】<a href="https://qcrao91.gitbook.io/go/" target="_blank" rel="noopener">https://qcrao91.gitbook.io/go/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。&lt;/p&gt;
&lt;p&gt;上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>如何打造一份优雅的简历</title>
    <link href="https://qcrao.com/2019/07/08/how-to-write-resume-gracefully/"/>
    <id>https://qcrao.com/2019/07/08/how-to-write-resume-gracefully/</id>
    <published>2019-07-08T01:00:00.000Z</published>
    <updated>2019-07-31T08:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。</p><p>为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。</p><p>虽然现在不是求职的高峰期，但是社招、实习还是随时都可以进行的。我也不是一个追热点的人，只求对你有所帮助。另外，简历的制作其实并不是一蹴而就的事，当你知道了写简历的套路，平时就会有意识的积累素材，所以什么时候都可以学习如何打造一份优雅的简历。</p><p>简历是什么？在我看来，在面试之前，直接代表你这个人。虽然简历不会说话，但是简历的内容会让面试官直接在脑海里勾勒出你的形象。如果简历排版非常精致，你就会被塑造成一位细心、得体的形象；反之，如果简历里出现了错别字，那粗心这个标签就会打到你身上了。</p><p>所以，对待简历一定要重视！它是找工作过程中的第一道关卡，过了这一关，才有在面试中展示自我的机会。当然，平时的积累，个人的真实水平，临场发挥、人脉、运气也都很重要。这篇文章假设那些因素大家都一样，只比拼简历，就看谁简历写得好。</p><p>好的简历就是你的名片，不好的简历可能就是你的黑历史。接下来我们进入正题，说说简历该怎么写。</p><p>先贴一份完成了的简历。为了不暴露隐私，简历中的信息都是虚构的，但是写法都是按照模板来的，所以仍然不失一份精彩的样例，可以细看研究的。</p><p><img src="https://user-images.githubusercontent.com/7698088/60750234-2d1ae380-9fd8-11e9-8071-8aee3887d960.png" alt="整体"></p><p>顺便说一句，这张图片，可以自由传播。如果你仔细研究一下简历中的三个项目，你肯定会被我的才华折服的。</p><p>接下来就按简历模板里各个板块的顺序，详细解释每个部分该怎么写。</p><h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>直接写名字，电话号码，邮箱，其他信息不用填写。</p><p>我找工作那会，实验室的信号不是太好，所以在手机号码后面还留了个座机号码，防止联系不上，这是细节。</p><p>关于电子邮箱，校招的同学可以留学校的邮箱；对于社招，gmail.com，163.com，foxmail.com 都不错，qq.com 也是可以的，只是需要把邮箱前缀改成一些有意义的，例如姓名的缩写之类的，这在邮箱设置里直接设置就好了，一定不要出现一些“中二”的邮箱名，例如“今夜无眠”之类的绝对不要出现。</p><p>有些同学问，需不需要挂个相片上去？其实，在抬头右侧空白部分，是可以挂上的。但是，我建议男生一率不要挂照片（当然如果你有吴彦祖的风彩当我没说），女生可以适当挂上证件照，前提是颜值是你的一大优势。</p><p>当然，一些国企事业单位会强制要求你贴上照片，那就贴好了。但也不要随便找一个白拍照就放上去了，找一家正规的照相馆，化好妆，照片精修后的效果肯定可以提高你在面试官那里的第一印象，这是好的开始。</p><h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><p>这块直接从最高学历写起，写到本科即可。包括时间，学位，学校，专业，排名这些信息。有些可以体现你实力的东西是可以备注上的，例如优秀毕业生，免试推荐研究生，这些是可以在挂号里备注上的。</p><p>有些人说，这样是不是太高调了？借用 caoz 的一句话：你矜持，你活该。</p><p>最后，关于排名，如果你是专业第一名，就直接写上；否则，就计算一下你的排名大概占比百分之多少。如果班级排名高，就按班级的排名来，如果学校排名高，就写学校的排名。总之，按最高的来写。研究生一般没有排名这个说法，那你就估个数好了，填上 Top 5%，一般没有问题。</p><p>这里教大家一个小技巧，你看前面贴出来的简历是不是排列得很整齐？让你自己动手做，你不一定排得这么整齐。教你一招：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749990-b6301b80-9fd4-11e9-9002-b0c09a0061b3.png" alt="表格"></p><p>通过表格，能自动地让文字对齐。写完之后，只需要将表格的边框设置为不可见就行了！深藏功与名！隐藏表格边框后的效果是这样的：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750002-ea0b4100-9fd4-11e9-9eca-b286b61894fc.png" alt="表格去边框"></p><p>有没有被惊艳到？如果你早就知道了这个技巧，当我没说。</p><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>如实写就好了，校招同学这一项可以写下实习经历，如果没有实习，这一项整体就不要了。社招同学不要在这上面弄虚作假，因为社招入职都会做尽调，被查出不诚信就尴尬了。</p><p>同样，可以用到上面提到的用表格排版的小技巧。</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><p>找互联网工作的同学，一定刷过《剑指 offer》这本书，书里面的题在面试过程中出场率还是挺高的。但是，很多同学都只看了其中的题目部分，对于前两章可能就略读了，甚至直接跳过去了。其实，书的前两章是讲如何面试的，同样写得很精彩，值得细细研究。</p><p>咱们这篇文章不说面试，只说简历。但书里面有一个非常好的点 —— 描述项目的 STAR 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749073-7b73b680-9fc7-11e9-8cd2-4ca103a827b4.png" alt="STAR模型"></p><p>项目经历这一项按照这个模型来写就 OK 了。</p><p>先简述项目背景，为什么要做它，要简短、清晰，也就是 <code>Situation</code>；</p><p>再来说你负责哪一块，做了哪些有价值的工作，这一块要学会提炼，不能是简单的工作罗列，尽量让人觉得这是有技术含量的，包含 <code>Task &amp; Action</code>；</p><p>最后，就是这件事完成的效果如何，是性能提升了 100 倍还是从零到一完成了某个复杂的系统，关键在于你要用数字来表达。例如，我经过一系列的优化过程，使得系统响应时间缩短为原来的 50%，或者说响应时间提升 1 倍，平均响应时间达到 1 ms 等等。</p><p>举个例子来说：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750894-59872d80-9fe1-11e9-9fe3-9c6b48aade9e.png" alt="project"></p><p>最开始一行，项目的简要信息。首先<code>项目的起止时间</code>，这个要斟酌一下，太长显得效率太低，太短可能又显得不深入。不是要教大家不诚信，这块适当“优化”下没太大问题；然后是<code>地点</code>，可以是学校，也可以是公司，照实写；接着是<code>项目名</code>，简短、清晰；最后是你的<code>角色</code>，一般可以写项目总负责人，核心参与者，项目主导者等等，不要太浮夸，也不要太低下。</p><p>接着，项目介绍。主要是讲清楚你做这个事的背景是什么。注意，不能说“这是实验室项目要求”或者“老师指定我做的”，要写这个项目的背景，业界是个什么进展，本项目它能解决什么问题，价值在哪，这是应该写的。有些项目确实垃圾，但编也得编一个高大上的介绍，毕竟它代表了你的水平不是嘛？</p><p>接着，个人职责。先是概要的一句话，例如负责系统的整体架构，打上一个句号，这是总起，后面用更细致的话来解释。例如，充分调研市面上的相关系统，反复设计修改，设计出一套高可用、高性能、可扩展的系统架构。一般要列三点，多了太长，少了显得工作量少。所以，要挑选最重要的点来说，例如，设计并实现了某个算法，性能是之前的多少倍。</p><p>最后，项目成果。这块一定要挑最亮点的来说，而且一定要能用数字量化。常见的就是性能提升了多少倍，支持了多少并发，支持了多少用户，不可用时长为 0，发表文章专利多少篇……</p><p>重要词语、数字用加粗来突出显示。这些加粗就是你最擅长的点，也是面试官可能会问你。所以你想让他问你什么，就加粗吧！</p><h1 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h1><p>这一项比较好搞定，把你的技能罗列出来，注意是和工作相关的。你找互联网的工作，写上一句“熟悉 office 的操作”就不太合适了吧。可以写：熟练掌握常见的数据结构和算法，熟悉 C/C++，熟悉 mysql/codis/etcd/zookper……</p><p>英语听说读写能力也可以写上，例如“能熟练进行英文的听说读写”。</p><p>唯一需要注意的是，不要也不能写“精通”。“精通”是一个非常强的词，很少人能做到。这里并不是谦虚的问题，还涉及到一个预期管理的问题，也就是面对“精通”和“熟悉”，面试官对你的期待是不一样的。</p><p>如果你写上“熟悉 Golang”，那么当面试官问你一个比较深入的问题时（例如 Golang 的 map 是怎么进行扩容的），你答上来了，他会觉得你水平比较高，而且还很谦虚。相反，你写的是“精通 Golang”，面试过程中，只要有一个问题没答上，那是不是一下子印象就下去了？</p><p>还写人写“精通 C/C++”，要知道，就是 C++ 的作者，他也不能完全掌握 C++ 的特性啊，即使 C++ 编译器，也不是所有的特性它都支持。换句话说，即使是编译器，也不能说它精通 C++。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>这一栏，可以展示你在工作技能之外的特性。例如，我看到有师兄这样写：</p><blockquote><p>高中班主任这样评价我：你是一个严于律己的人，一个精诚团结的人，一个志向远大的人。</p></blockquote><p>面试官可能会问：班主任为什么要这么评价？这时，他就掉入你提前挖好的“坑”，因为一个可以展示你优秀品质的故事正在等着他，这是你提前准备的已经演练了无数遍了。而且，面试进程也在你的掌握之中了。</p><p>注意，不要太多，也不要太浮夸，着重展示你是一个可以合作，善于沟通，工作积极的人。</p><h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><p>这块说一下其他未尽事项。</p><p>校招简历一般只要一页，就算你有再多内容要写，也只能压缩到一页，把那些最重要的，最能展示你能力的那部分内容保留下来，其他的干掉。</p><p>社招简历也不要超过两页，这样显得简练，展示的也都是高质量的项目，不能是简单的罗列，要总结升华。这样也可以打印到一页纸上，方便面试官，也就是方便你自己。</p><p>工作中，有一项非常重要的能力就是总结、提炼、升华。可能实验室的项目是一些企业的横向项目，就是 1+1=2 的事，非常简单，可能你觉得没啥可写的。这就是你发挥能力的时候了，从这些日常操作中，总结出一些高大上的东西来。如果不会，多参考一下优秀学长学姐的简历。</p><p>总之，你写到简历上的项目一定是经过总结升华的，这需要经过你无数次的修改。</p><p>还有一点要注意的是，发给别人的简历一定要是 pdf 格式，有些同学直接把 word 版 丟给别人，不同软件版本的电脑上可能会有兼容性问题啊，可能会有乱码，而且 word 版可能会被篡改。另外，打印简历的时候，也是要用 pdf 版本，不会出问题。</p><p>简历文件命名也是一个要注意的点。一般用 “码农桃花源-桃花源工作室-18888888888”，也就是“姓名-学校/公司-手机”这样的格式。这样，方便 HR 或者面试官联系你，因为只看文件名就能知道你的联系方式，和一些最重要的信息。再说一次，方便面试官就是方便你自己。</p><p>还有一个点，针对不同职位的简历应该是不一样的。这时，你可以把你的项目进行组合，不同职位的简历对应不同的项目组合，有的放矢。有些人会用 git 的不同分支维护不同的简历版本。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简历是你的代表，无声代表你这个人；它也是一个面试索引，能引导面试官的提问。所以如果你特别擅长某个方面，一定要在简历上突出。这相当于给面试官“挖坑”，如果他进坑了，那问的问题一定要你早就烂熟于心的，因为那是你准备无数遍的精彩故事、优化案例。</p><p>这样，面试官整个过程都是受你的引导，在你的框框里，不知不觉，在你讲述你擅长内容的过程中，面试进程被你掌握了。面试官接下来的问题，也会是围绕你的回答、故事展开。</p><p>要知道，如果你让面试官自己想问题，那你多半是招架不住的，因为真正的高手可能不会看这篇文章，哈哈，开个玩笑。</p><p>这篇文章里的简历是用我真实的简历进行修改的，当然主要是修改的内容。而且，为了展示我的幽默，我还编了三个项目，非常精彩，值得一看。我也真的是够了，哈哈。</p><p>这份简历模板是我在学校的时候，从师兄师组那学习过来的，包括用表格排版的技巧。他们去的都是像微软、谷歌、FB、BAT 这些高大上的互联网公司。所以这绝对是一份久经考验的简历模板。而且，初看起来，似乎平淡无奇，但细细琢磨，真的是低调奢华有内涵，你值得拥有。</p><p>我把 word 版本放到网盘上了，公众号回复“简历模板”或者 “jlmb”，我会回复你下载地址。</p><p>仅仅是把你简历上的内容 copy 到这个模板上，你也会觉得“瞬间高大上起来了”。加油~~</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。&lt;/p&gt;
&lt;p&gt;为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。&lt;/
      
    
    </summary>
    
      <category term="求职" scheme="https://qcrao.com/categories/%E6%B1%82%E8%81%8C/"/>
    
    
      <category term="简历" scheme="https://qcrao.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Go 程序是怎样跑起来的</title>
    <link href="https://qcrao.com/2019/07/03/how-go-runs/"/>
    <id>https://qcrao.com/2019/07/03/how-go-runs/</id>
    <published>2019-07-03T01:42:00.000Z</published>
    <updated>2019-11-28T07:31:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。</p><p>在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，我第一次看到这本书的书名，就非常喜欢。因为它模仿了周星驰喜剧之王里出现的一本书 ——《演员的自我修养》。心向往之！</p><p>在开始本文之前，先推荐一位头条大佬的博客——《面向信仰编程》，他的 Go 编译系列文章，非常有深度，直接深入编译器源代码，我是看了很多遍了。博客链接可以从参考资料里获取。</p><p>理想很大，实现的难度也是非常大。为了避免砸了“深度解密”这个牌子，这次起了个更温和的名字，嘿嘿。</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从一个 <code>Hello World</code> 的例子开始：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我用我那价值 1800 元的 cherry 键盘潇洒地敲完上面的 hello world 代码时，保存在硬盘上的 <code>hello.go</code> 文件就是一个字节序列了，每个字节代表一个字符。</p><p>用 vim 打开 hello.go 文件，在命令行模式下，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd</span><br></pre></td></tr></table></figure><p>就能在 vim 里以十六进制查看文件内容：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696461-9d76e600-921e-11e9-9253-533d55e2c8f5.png" alt="hex .go"></p><p>最左边的一列代表地址值，中间一列代表文本对应的 ASCII 字符，最右边的列就是我们的代码。再在终端里执行 <code>man ascii</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696702-15dda700-921f-11e9-838f-897a5d3f21fb.png" alt="ASCII"></p><p>和 ASCII 字符表一对比，就能发现，中间的列和最右边的列是一一对应的。也就是说，刚刚写完的 hello.go 文件都是由 ASCII 字符表示的，它被称为<code>文本文件</code>，其他文件被称为<code>二进制文件</code>。</p><p>当然，更深入地看，计算机中的所有数据，像磁盘文件、网络中的数据其实都是一串比特位组成，取决于如何看待它。在不同的情景下，一个相同的字节序列可能表示成一个整数、浮点数、字符串或者是机器指令。</p><p>而像 hello.go 这个文件，8 个 bit，也就是一个字节看成一个单位（假定源程序的字符都是 ASCII 码），最终解释成人类能读懂的 Go 源码。</p><p>Go 程序并不能直接运行，每条 Go 语句必须转化为一系列的低级机器语言指令，将这些指令打包到一起，并以二进制磁盘文件的形式存储起来，也就是可执行目标文件。</p><p>从源文件到可执行目标文件的转化过程：</p><p><img src="https://user-images.githubusercontent.com/7698088/60523966-44c74300-9d1e-11e9-9ba9-d1f594607edc.png" alt="compile"></p><p>完成以上各个阶段的就是 Go 编译系统。你肯定知道大名鼎鼎的 GCC（GNU Compile Collection），中文名为 GNU 编译器套装，它支持像 C，C++，Java，Python，Objective-C，Ada，Fortran，Pascal，能够为很多不同的机器生成机器码。</p><p>可执行目标文件可以直接在机器上执行。一般而言，先执行一些初始化的工作；找到 main 函数的入口，执行用户写的代码；执行完成后，main 函数退出；再执行一些收尾的工作，整个过程完毕。</p><p>在接下来的文章里，我们将探索<code>编译</code>和<code>运行</code>的过程。</p><h1 id="编译链接概述"><a href="#编译链接概述" class="headerlink" title="编译链接概述"></a>编译链接概述</h1><p>Go 源码里的编译器源码位于 <code>src/cmd/compile</code> 路径下，链接器源码位于 <code>src/cmd/link</code> 路径下。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>我比较喜欢用 IDE（集成开发环境）来写代码， Go 源码用的 Goland，有时候直接点击 IDE 菜单栏里的“运行”按钮，程序就跑起来了。这实际上隐含了编译和链接的过程，我们通常将编译和链接合并到一起的过程称为构建（Build）。</p><p>编译过程就是对源文件进行词法分析、语法分析、语义分析、优化，最后生成汇编代码文件，以 <code>.s</code> 作为文件后缀。</p><p>之后，汇编器会将汇编代码转变成机器可以执行的指令。由于每一条汇编语句几乎都与一条机器指令相对应，所以只是一个简单的一一对应，比较简单，没有语法、语义分析，也没有优化这些步骤。</p><p>编译器是将高级语言翻译成机器语言的一个工具，编译过程一般分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。下图来自《程序员的自我修养》：</p><p><img src="https://user-images.githubusercontent.com/7698088/59910602-d4c6dc00-9444-11e9-8155-fbe59eec4e89.png" alt="编译过程总览"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通过前面的例子，我们知道，Go 程序文件在机器看来不过是一堆二进制位。我们能读懂，是因为 Goland 按照 ASCII 码（实际上是 UTF-8）把这堆二进制位进行了编码。例如，把 8个 bit 位分成一组，对应一个字符，通过对照 ASCII 码表就可以查出来。</p><p>当把所有的二进制位都对应成了 ASCII 码字符后，我们就能看到有意义的字符串。它可能是关键字，例如：package；可能是字符串，例如：“Hello World”。</p><p>词法分析其实干的就是这个。输入是原始的 Go 程序文件，在词法分析器看来，就是一堆二进制位，根本不知道是什么东西，经过它的分析后，变成有意义的记号。简单来说，词法分析是计算机科学中将字符序列转换为标记（token）序列的过程。</p><p>我们来看一下维基百科上给出的定义：</p><blockquote><p>词法分析（lexical analysis）是计算机科学中将字符序列转换为标记（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。</p></blockquote><p><code>.go</code> 文件被输入到扫描器（Scanner），它使用一种类似于<code>有限状态机</code>的算法，将源代码的字符系列分割成一系列的记号（Token）。</p><p>记号一般分为这几类：关键字、标识符、字面量（包含数字、字符串）、特殊符号（如加号、等号）。</p><p>例如，对于如下的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice[i] = i * (<span class="number">2</span> + <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>总共包含 16 个非空字符，经过扫描后，</p><table><thead><tr><th>记号</th><th>类型</th></tr></thead><tbody><tr><td>slice</td><td>标识符</td></tr><tr><td>[</td><td>左方括号</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>]</td><td>右方括号</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>(</td><td>左圆括号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>6</td><td>数字</td></tr><tr><td>)</td><td>右圆括号</td></tr></tbody></table><p>上面的例子源自《程序员的自我修养》，主要讲解编译、链接相关的内容，很精彩，推荐研读。</p><p>Go 语言（本文的 Go 版本是 1.9.2）扫描器支持的 Token 在源码中的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/cmd/compile/internal/syntax/token.go</span><br></pre></td></tr></table></figure><p>感受一下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokstrings = [...]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="comment">// source control</span></span><br><span class="line">_EOF: <span class="string">"EOF"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// names and literals</span></span><br><span class="line">_Name:    <span class="string">"name"</span>,</span><br><span class="line">_Literal: <span class="string">"literal"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// operators and operations</span></span><br><span class="line">_Operator: <span class="string">"op"</span>,</span><br><span class="line">_AssignOp: <span class="string">"op="</span>,</span><br><span class="line">_IncOp:    <span class="string">"opop"</span>,</span><br><span class="line">_Assign:   <span class="string">"="</span>,</span><br><span class="line">_Define:   <span class="string">":="</span>,</span><br><span class="line">_Arrow:    <span class="string">"&lt;-"</span>,</span><br><span class="line">_Star:     <span class="string">"*"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// delimitors</span></span><br><span class="line">_Lparen:    <span class="string">"("</span>,</span><br><span class="line">_Lbrack:    <span class="string">"["</span>,</span><br><span class="line">_Lbrace:    <span class="string">"&#123;"</span>,</span><br><span class="line">_Rparen:    <span class="string">")"</span>,</span><br><span class="line">_Rbrack:    <span class="string">"]"</span>,</span><br><span class="line">_Rbrace:    <span class="string">"&#125;"</span>,</span><br><span class="line">_Comma:     <span class="string">","</span>,</span><br><span class="line">_Semi:      <span class="string">";"</span>,</span><br><span class="line">_Colon:     <span class="string">":"</span>,</span><br><span class="line">_Dot:       <span class="string">"."</span>,</span><br><span class="line">_DotDotDot: <span class="string">"..."</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// keywords</span></span><br><span class="line">_Break:       <span class="string">"break"</span>,</span><br><span class="line">_Case:        <span class="string">"case"</span>,</span><br><span class="line">_Chan:        <span class="string">"chan"</span>,</span><br><span class="line">_Const:       <span class="string">"const"</span>,</span><br><span class="line">_Continue:    <span class="string">"continue"</span>,</span><br><span class="line">_Default:     <span class="string">"default"</span>,</span><br><span class="line">_Defer:       <span class="string">"defer"</span>,</span><br><span class="line">_Else:        <span class="string">"else"</span>,</span><br><span class="line">_Fallthrough: <span class="string">"fallthrough"</span>,</span><br><span class="line">_For:         <span class="string">"for"</span>,</span><br><span class="line">_Func:        <span class="string">"func"</span>,</span><br><span class="line">_Go:          <span class="string">"go"</span>,</span><br><span class="line">_Goto:        <span class="string">"goto"</span>,</span><br><span class="line">_If:          <span class="string">"if"</span>,</span><br><span class="line">_Import:      <span class="string">"import"</span>,</span><br><span class="line">_Interface:   <span class="string">"interface"</span>,</span><br><span class="line">_Map:         <span class="string">"map"</span>,</span><br><span class="line">_Package:     <span class="string">"package"</span>,</span><br><span class="line">_Range:       <span class="string">"range"</span>,</span><br><span class="line">_Return:      <span class="string">"return"</span>,</span><br><span class="line">_Select:      <span class="string">"select"</span>,</span><br><span class="line">_Struct:      <span class="string">"struct"</span>,</span><br><span class="line">_Switch:      <span class="string">"switch"</span>,</span><br><span class="line">_Type:        <span class="string">"type"</span>,</span><br><span class="line">_Var:         <span class="string">"var"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是比较熟悉的，包括名称和字面量、操作符、分隔符和关键字。</p><p>而扫描器的路径是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/cmd/compile/internal/syntax/scanner.go</span><br></pre></td></tr></table></figure><p>其中最关键的函数就是 next 函数，它不断地读取下一个字符（不是下一个字节，因为 Go 语言支持 Unicode 编码，并不是像我们前面举得 ASCII 码的例子，一个字符只有一个字节），直到这些字符可以构成一个 Token。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scanner)</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"><span class="comment">// skip white space</span></span><br><span class="line">c := s.getr()</span><br><span class="line"><span class="keyword">for</span> c == <span class="string">' '</span> || c == <span class="string">'\t'</span> || c == <span class="string">'\n'</span> &amp;&amp; !nlsemi || c == <span class="string">'\r'</span> &#123;</span><br><span class="line">c = s.getr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// token start</span></span><br><span class="line">s.line, s.col = s.source.line0, s.source.col0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isLetter(c) || c &gt;= utf8.RuneSelf &amp;&amp; s.isIdentRune(c, <span class="literal">true</span>) &#123;</span><br><span class="line">s.ident()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">s.lit = <span class="string">"newline"</span></span><br><span class="line">s.tok = _Semi</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>:</span><br><span class="line">s.number(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">s.tok = <span class="number">0</span></span><br><span class="line">s.error(fmt.Sprintf(<span class="string">"invalid character %#U"</span>, c))</span><br><span class="line"><span class="keyword">goto</span> redo</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">assignop:</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'='</span> &#123;</span><br><span class="line">s.tok = _AssignOp</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s.ungetr()</span><br><span class="line">s.tok = _Operator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的主要逻辑就是通过 <code>c := s.getr()</code>  获取下一个未被解析的字符，并且会跳过之后的空格、回车、换行、tab 字符，然后进入一个大的 <code>switch-case</code> 语句，匹配各种不同的情形，最终可以解析出一个 Token，并且把相关的行、列数字记录下来，这样就完成一次解析过程。</p><blockquote><p>当前包中的词法分析器 scanner 也只是为上层提供了 next 方法，词法解析的过程都是惰性的，只有在上层的解析器需要时才会调用 next 获取最新的 Token。</p></blockquote><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步生成的 Token 序列，需要经过进一步处理，生成一棵以<code>表达式</code>为结点的<code>语法树</code>。</p><p>比如最开始的那个例子，<code>slice[i] = i * (2 + 6)</code>，得到的一棵语法树如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962830-3490b600-951d-11e9-8ae6-53d6375f0246.png" alt="语法树"></p><p>整个语句被看作是一个赋值表达式，左子树是一个数组表达式，右子树是一个乘法表达式；数组表达式由 2 个符号表达式组成；乘号表达式则是由一个符号表达式和一个加号表达式组成；加号表达式则是由两个数字组成。符号和数字是最小的表达式，它们不能再被分解，通常作为树的叶子节点。</p><p>语法分析的过程可以检测一些形式上的错误，例如：括号是否缺少一半，<code>+</code> 号表达式缺少一个操作数等。</p><blockquote><p>语法分析是根据某种特定的形式文法（Grammar）对 Token 序列构成的输入文本进行分析并确定其语法结构的一种过程。</p></blockquote><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语法分析完成后，我们并不知道语句的具体意义是什么。像上面的 <code>*</code> 号的两棵子树如果是两个指针，这是不合法的，但语法分析检测不出来，语义分析就是干这个事。</p><p>编译期所能检查的是静态语义，可以认为这是在“代码”阶段，包括变量类型的匹配、转换等。例如，将一个浮点值赋给一个指针变量的时候，明显的类型不匹配，就会报编译错误。而对于运行期间才会出现的错误：不小心除了一个 0 ，语义分析是没办法检测的。</p><p>语义分析阶段完成之后，会在每个节点上标注上类型：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962838-512cee00-951d-11e9-8581-18e12ffde230.png" alt="语义分析完成"></p><p>Go 语言编译器在这一阶段检查常量、类型、函数声明以及变量赋值语句的类型，然后检查哈希中键的类型。实现类型检查的函数通常都是几千行的巨型 switch/case 语句。</p><blockquote><p>类型检查是 Go 语言编译的第二个阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误。</p></blockquote><blockquote><p>在这个过程中也可能会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码对编译进行优化提高执行效率，而且也会修改 make、new 等关键字对应节点的操作类型。</p></blockquote><p>例如比较常用的 make 关键字，用它可以创建各种类型，如 slice，map，channel 等等。到这一步的时候，对于 make 关键字，也就是 OMAKE 节点，会先检查它的参数类型，根据类型的不同，进入相应的分支。如果参数类型是 slice，就会进入 TSLICE case 分支，检查 len 和 cap 是否满足要求，如 len &lt;= cap。最后节点类型会从 OMAKE 改成 OMAKESLICE。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>我们知道，编译过程一般可以分为前端和后端，前端生成和平台无关的中间代码，后端会针对不同的平台，生成不同的机器码。</p><p>前面词法分析、语法分析、语义分析等都属于编译器前端，之后的阶段属于编译器后端。</p><p>编译过程有很多优化的环节，在这个环节是指源代码级别的优化。它将语法树转换成中间代码，它是语法树的顺序表示。</p><p>中间代码一般和目标机器以及运行时环境无关，它有几种常见的形式：三地址码、P-代码。例如，最基本的<code>三地址码</code>是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br></pre></td></tr></table></figure><p>表示变量 y 和 变量 z 进行 op 操作后，赋值给 x。op 可以是数学运算，例如加减乘除。</p><p>前面我们举的例子可以写成如下的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = i * t1</span><br><span class="line">slice[i] = t2</span><br></pre></td></tr></table></figure><p>这里 2 + 6 是可以直接计算出来的，这样就把 t1 这个临时变量“优化”掉了，而且 t1 变量可以重复利用，因此 t2 也可以“优化”掉。优化之后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 = i * 8</span><br><span class="line">slice[i] = t1</span><br></pre></td></tr></table></figure><p>Go 语言的中间代码表示形式为 SSA（Static Single-Assignment，静态单赋值），之所以称之为单赋值，是因为每个名字在 SSA 中仅被赋值一次。。</p><p>这一阶段会根据 CPU 的架构设置相应的用于生成中间代码的变量，例如编译器使用的指针和寄存器的大小、可用寄存器列表等。中间代码生成和机器码生成这两部分会共享相同的设置。</p><p>在生成中间代码之前，会对抽象语法树中节点的一些元素进行替换。这里引用《面向信仰编程》编译原理相关博客里的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/60553849-a364df00-9d67-11e9-832a-450f4d8ee6ba.png" alt="builtin mapping"></p><p>例如对于 map 的操作 m[i]，在这里会被转换成 mapacess 或 mapassign。</p><blockquote><p>Go 语言的主程序在执行时会调用 runtime 中的函数，也就是说关键字和内置函数的功能其实是由语言的编译器和运行时共同完成的。</p></blockquote><blockquote><p>中间代码的生成过程其实就是从 AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字在进行一次更新，更新后的语法树会经过多轮处理转变最后的 SSA 中间代码。</p></blockquote><h3 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h3><p>不同机器的机器字长、寄存器等等都不一样，意味着在不同机器上跑的机器码是不一样的。最后一步的目的就是要生成能在不同 CPU 架构上运行的代码。</p><p>为了榨干机器的每一滴油水，目标代码优化器会对一些指令进行优化，例如使用移位指令代替乘法指令等。</p><p>这块实在没能力深入，幸好也不需要深入。对于应用层的软件开发工程师来说，了解一下就可以了。</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>编译过程是针对单个文件进行的，文件与文件之间不可避免地要引用定义在其他模块的全局变量或者函数，这些变量或函数的地址只有在此阶段才能确定。</p><p>链接过程就是要把编译器生成的一个个目标文件链接成可执行文件。最终得到的文件是分成各种段的，比如数据段、代码段、BSS段等等，运行时会被装载到内存中。各个段具有不同的读写、执行属性，保护了程序的安全运行。</p><p>这部分内容，推荐看《程序员的自我修养》和《深入理解计算机系统》。</p><h1 id="Go-程序启动"><a href="#Go-程序启动" class="headerlink" title="Go 程序启动"></a>Go 程序启动</h1><p>仍然使用 hello-world 项目的例子。在项目根目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags "-N -l" -o hello src/main.go</span><br></pre></td></tr></table></figure><p><code>-gcflags &quot;-N -l&quot;</code> 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。</p><p>得到了可执行文件 hello，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[qcrao@qcrao hello-world]$ gdb hello</span><br></pre></td></tr></table></figure><p>进入 gdb 调试模式，执行 <code>info files</code>，得到可执行文件的文件头，列出了各种段：</p><p><img src="https://user-images.githubusercontent.com/7698088/60392813-db88d980-9b3d-11e9-8b0f-7c1d845a8191.png" alt="gdb info"></p><p>同时，我们也得到了入口地址：0x450e20。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x450e20</span><br><span class="line">Breakpoint 1 at 0x450e20: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.</span><br></pre></td></tr></table></figure><p>这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 <code>src/runtime/rt0_linux_amd64.s</code>，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8</span><br><span class="line">LEAQ8(SP), SI // argv</span><br><span class="line">MOVQ0(SP), DI // argc</span><br><span class="line">MOVQ$main(SB), AX</span><br><span class="line">JMPAX</span><br></pre></td></tr></table></figure><p>主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEXT main(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">MOVQ$runtime·rt0_go(SB), AX</span><br><span class="line">JMPAX</span><br></pre></td></tr></table></figure><p>继续跳转到 <code>runtime·rt0_go(SB)</code>，位置：<code>/usr/local/go/src/runtime/asm_amd64.s</code>，代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0</span><br><span class="line">    // 省略很多 CPU 相关的特性标志位检查的代码</span><br><span class="line">    // 主要是看不懂，^_^</span><br><span class="line">    </span><br><span class="line">    // ………………………………</span><br><span class="line">    </span><br><span class="line">    // 下面是最后调用的一些函数，比较重要</span><br><span class="line">    // 初始化执行文件的绝对路径</span><br><span class="line">    CALLruntime·args(SB)</span><br><span class="line">    // 初始化 CPU 个数和内存页大小</span><br><span class="line">CALLruntime·osinit(SB)</span><br><span class="line">// 初始化命令行参数、环境变量、gc、栈空间、内存管理、所有 P 实例、HASH算法等</span><br><span class="line">CALLruntime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">// 要在 main goroutine 上运行的函数</span><br><span class="line">MOVQ$runtime·mainPC(SB), AX// entry</span><br><span class="line">PUSHQAX</span><br><span class="line">PUSHQ$0// arg size</span><br><span class="line"></span><br><span class="line">// 新建一个 goroutine，该 goroutine 绑定 runtime.main，放在 P 的本地队列，等待调度</span><br><span class="line">CALLruntime·newproc(SB)</span><br><span class="line">POPQAX</span><br><span class="line">POPQAX</span><br><span class="line"></span><br><span class="line">    // 启动M，开始调度goroutine</span><br><span class="line">CALLruntime·mstart(SB)</span><br><span class="line"></span><br><span class="line">MOVL$0xf1, 0xf1  // crash</span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATAruntime·mainPC+0(SB)/8,$runtime·main(SB)</span><br><span class="line">GLOBLruntime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure><p>参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：</p><blockquote><ol><li>检查运行平台的CPU，设置好程序运行需要相关标志。</li><li>TLS的初始化。</li><li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li><li>runtime.newproc创建新的goroutine用于绑定用户写的main方法。</li><li>runtime.mstart开始goroutine的调度。</li></ol></blockquote><p>最后用一张图来总结 go bootstrap 过程吧：</p><p><img src="https://user-images.githubusercontent.com/7698088/60493589-b2a04a00-9cdf-11e9-9c9e-a4b275973f60.png" alt="golang bootstrap"></p><p>main 函数里执行的一些重要的操作包括：新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占；启动 gc；执行所有的 init 函数等等。</p><p>上面是启动过程，看一下退出过程：</p><blockquote><p>当 main 函数执行结束之后，会执行 exit(0) 来退出进程。若执行 exit(0) 后，进程没有退出，main 函数最后的代码会一直访问非法地址：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">*x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正常情况下，一旦出现非法地址访问，系统会把进程杀死，用这样的方法确保进程退出。</p></blockquote><p>关于程序退出这一段的阐述来自群聊《golang runtime 阅读》，又是一个高阶的读源码的组织，github 主页见参考资料。</p><p>当然 Go 程序启动这一部分其实还会涉及到 fork 一个新进程、装载可执行文件，控制权转移等问题。还是推荐看前面的两本书，我觉得我不会写得更好，就不叙述了。</p><h1 id="GoRoot-和-GoPath"><a href="#GoRoot-和-GoPath" class="headerlink" title="GoRoot 和 GoPath"></a>GoRoot 和 GoPath</h1><p>GoRoot 是  Go 的安装路径。mac 或 unix 是在 <code>/usr/local/go</code> 路径上，来看下这里都装了些什么：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344492-41178180-99e9-11e9-98b0-b1f8d64ce97d.png" alt="/usr/local/go"></p><p>bin 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/69785843-13cb3b80-11f4-11ea-8b71-e7dee5efc8fb.png" alt="bin"></p><p>pkg 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344731-c7cc5e80-99e9-11e9-8002-83f3debc09a6.png" alt="pkg"></p><p>Go 工具目录如下，其中比较重要的有编译器 <code>compile</code>，链接器 <code>link</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/60379164-888d2480-9a60-11e9-9322-920c0e1b2b3d.png" alt="pkg/tool"></p><p>GoPath 的作用在于提供一个可以寻找 <code>.go</code> 源码的路径，它是一个工作空间的概念，可以设置多个目录。Go 官方要求，GoPath 下面需要包含三个文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">pkg</span><br><span class="line">bin</span><br></pre></td></tr></table></figure><p>src 存放源文件，pkg 存放源文件编译后的库文件，后缀为 <code>.a</code>；bin 则存放可执行文件。</p><h1 id="Go-命令详解"><a href="#Go-命令详解" class="headerlink" title="Go 命令详解"></a>Go 命令详解</h1><p>直接在终端执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go</span><br></pre></td></tr></table></figure><p>就能得到和 go 相关的命令简介：</p><p><img src="https://user-images.githubusercontent.com/7698088/60248752-e2bda680-98f5-11e9-8b3b-7deaf70a919c.png" alt="go commands"></p><p>和编译相关的命令主要是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">go install</span><br><span class="line">go run</span><br></pre></td></tr></table></figure><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p><code>go build</code> 用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code>$GoPath/src/package</code> 路径下寻找源码文件。<code>go build</code> 还可以直接编译指定的源码文件，并且可以同时指定多个。</p><p>通过执行 <code>go help build</code> 命令得到 <code>go build</code> 的使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: go build [-o output] [-i] [build flags] [packages]</span><br></pre></td></tr></table></figure><p><code>-o</code> 只能在编译单个包的时候出现，它指定输出的可执行文件的名字。</p><p><code>-i</code> 会安装编译目标所依赖的包，安装是指生成与代码包相对应的 <code>.a</code> 文件，即静态库文件（后面要参与链接），并且放置到当前工作区的 pkg 目录下，且库文件的目录层级和源码层级一致。</p><p>至于 build flags 参数，<code>build, clean, get, install, list, run, test</code> 这些命令会共用一套：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>强制重新编译所有涉及到的包，包括标准库中的代码包，这会重写 /usr/local/go 目录下的 <code>.a</code> 文件</td></tr><tr><td>-n</td><td>打印命令执行过程，不真正执行</td></tr><tr><td>-p n</td><td>指定编译过程中命令执行的并行数，n 默认为 CPU 核数</td></tr><tr><td>-race</td><td>检测并报告程序中的数据竞争问题</td></tr><tr><td>-v</td><td>打印命令执行过程中所涉及到的代码包名称</td></tr><tr><td>-x</td><td>打印命令执行过程中所涉及到的命令，并执行</td></tr><tr><td>-work</td><td>打印编译过程中的临时文件夹。通常情况下，编译完成后会被删除</td></tr></tbody></table><p>我们知道，Go 语言的源码文件分为三类：命令源码、库源码、测试源码。</p><blockquote><p>命令源码文件：是 Go 程序的入口，包含 <code>func main()</code> 函数，且第一行用 <code>package main</code> 声明属于 main 包。</p></blockquote><blockquote><p>库源码文件：主要是各种函数、接口等，例如工具类的函数。</p></blockquote><blockquote><p>测试源码文件：以 <code>_test.go</code> 为后缀的文件，用于测试程序的功能和性能。</p></blockquote><p>注意，<code>go build</code> 会忽略 <code>*_test.go</code> 文件。</p><p>我们通过一个很简单的例子来演示 <code>go build</code> 命令。我用 Goland 新建了一个 <code>hello-world</code> 项目（为了展示引用自定义的包，和之前的 hello-world 程序不同），项目的结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/60383032-5b5f6700-9a9e-11e9-9613-03d9ba13b889.png" alt="example structure"></p><p>最左边可以看到项目的结构，包含三个文件夹：bin，pkg，src。其中 src 目录下有一个 main.go，里面定义了 main 函数，是整个项目的入口，也就是前面提过的所谓的命令源码文件；src 目录下还有一个 util 目录，里面有 util.go 文件，定义了一个可以获取本机 IP 地址的函数，也就是所谓的库源码文件。</p><p>中间是 main.go 的源码，引用了两个包，一个是标准库的 fmt；一个是 util 包，util 的导入路径是 <code>util</code>。所谓的导入路径是指相对于 Go 的源码目录 <code>$GoRoot/src</code> 或者 <code>$GoPath/src</code> 的下的子路径。例如 main 包里引用的 fmt 的源码路径是 <code>/usr/local/go/src/fmt</code>，而 util 的源码路径是 <code>/Users/qcrao/hello-world/src/util</code>，正好我们设置的 GoPath = /Users/qcrao/hello-world。</p><p>最右边是库函数的源码，实现了获取本机 IP 的函数。</p><p>在 src 目录下，直接执行 <code>go build</code> 命令，在同级目录生成了一个可执行文件，文件名为 <code>src</code>，使用 <code>./src</code> 命令直接执行，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br><span class="line">Local IP: 192.168.1.3</span><br></pre></td></tr></table></figure><p>我们也可以指定生成的可执行文件的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o bin/hello</span><br></pre></td></tr></table></figure><p>这样，在 bin 目录下会生成一个可执行文件，运行结果和上面的 <code>src</code> 一样。</p><p>其实，util 包可以单独被编译。我们可以在项目根目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build util</span><br></pre></td></tr></table></figure><p>编译程序会去 $GoPath/src 路径找 util 包（其实是找文件夹）。还可以在 <code>./src/util</code> 目录下直接执行 <code>go build</code> 编译。</p><p>当然，直接编译库源码文件不会生成 .a 文件，因为：</p><blockquote><p>go build 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件。</p></blockquote><p>为了展示整个编译链接的运行过程，我们在项目根目录执行如下的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -v -x -work -o bin/hello src/main.go</span><br></pre></td></tr></table></figure><p><code>-v</code> 会打印所编译过的包名字，<code>-x</code> 打印编译期间所执行的命令，<code>-work</code> 打印编译期间生成的临时文件路径，并且编译完成之后不会被删除。</p><p>执行结果：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386219-e3586780-9ac4-11e9-871f-5acfa83372d0.png" alt="编译过程"></p><p>从结果来看，图中用箭头标注了本次编译过程涉及 2 个包：util，command-line-arguments。第二个包比较诡异，源码里根本就没有这个名字好吗？其实这是 <code>go build</code> 命令检测到 [packages] 处填的是一个 <code>.go</code> 文件，因此创建了一个虚拟的包：command-line-arguments。</p><p>同时，用红框圈出了 compile, link，也就是先编译了 util 包和 <code>main.go</code> 文件，分别得到 <code>.a</code> 文件，之后将两者进行链接，最终生成可执行文件，并且移动到 bin 目录下，改名为 hello。</p><p>另外，第一行显示了编译过程中的工作目录，此目录的文件结构是：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386682-06861580-9acb-11e9-8367-d37ce03a46cc.png" alt="临时工作目录"></p><p>可以看到，和 hello-world 目录的层级基本一致。command-line-arguments 就是虚拟的 main.go 文件所处的包。exe 目录下的可执行文件在最后一步被移动到了 bin 目录下，所以这里是空的。</p><p>整体来看，<code>go build</code> 在执行时，会先递归寻找 main.go 所依赖的包，以及依赖的依赖，直至最底层的包。这里可以是深度优先遍历也可以是宽度优先遍历。如果发现有循环依赖，就会直接退出，这也是经常会发生的循环引用编译错误。</p><p>正常情况下，这些依赖关系会形成一棵倒着生长的树，树根在最上面，就是 main.go 文件，最下面是没有任何其他依赖的包。编译器会从最左的节点所代表的包开始挨个编译，完成之后，再去编译上一层的包。</p><p>这里，引用郝林老师几年前在 github 上发表的 go 命令教程，可以从参考资料找到原文地址。</p><blockquote><p>从代码包编译的角度来说，如果代码包 A 依赖代码包 B，则称代码包 B 是代码包 A 的依赖代码包（以下简称依赖包），代码包 A 是代码包 B 的触发代码包（以下简称触发包）。</p></blockquote><blockquote><p>执行 <code>go build</code> 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包。</p></blockquote><p>顺便推荐一个浏览器插件 Octotree，在看 github 项目的时候，此插件可以在浏览器里直接展示整个项目的文件结构，非常方便：</p><p><img src="https://user-images.githubusercontent.com/7698088/60390988-d9f7eb00-9b16-11e9-83ec-64c3c0beb6ad.png" alt="github 插件"></p><p>到这里，你一定会发现，对于 hello-wrold 文件夹下的 pkg 目录好像一直没有涉及到。</p><p>其实，pkg 目录下面应该存放的是涉及到的库文件编译后的包，也就是一些 <code>.a</code> 文件。但是 go build 执行过程中，这些 <code>.a</code> 文件放在临时文件夹中，编译完成后会被直接删掉，因此一般不会用到。</p><p>前面我们提到过，在 go build 命令里加上 <code>-i</code> 参数会安装这些库文件编译的包，也就是这些 <code>.a</code> 文件会放到 pkg 目录下。</p><p>在项目根目录执行 <code>go build -i src/main.go</code> 后，pkg 目录里增加了 util.a 文件：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386864-84e3b700-9acd-11e9-9513-68a52ff460bb.png" alt="pkg"></p><p><code>darwin_amd64</code> 表示的是：</p><blockquote><p>GOOS 和 GOARCH。这两个环境变量不用我们设置，系统默认的。</p></blockquote><blockquote><p>GOOS 是 Go 所在的操作系统类型，GOARCH 是 Go 所在的计算架构。</p></blockquote><blockquote><p>Mac 平台上这个目录名就是 darwin_amd64。</p></blockquote><p>生成了 util.a 文件后，再次编译的时候，就不会再重新编译 util.go 文件，加快了编译速度。</p><p>同时，在根目录下生成了名称为 main 的可执行文件，这是以 main.go 的文件名命令的。</p><p>hello-world 这个项目的代码已经上传到了 github 项目 <code>Go-Questions</code>，这个项目由问题导入，企图串连 Go 的所有知识点，正在完善，期待你的 star。 地址见参考资料【Go-Questions hello-world项目】。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p><code>go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code>go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。</p><p>还是使用之前 hello-world 项目的例子，我们先将 pkg 目录删掉，在项目根目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install src/main.go</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">go install util</span><br></pre></td></tr></table></figure><p>两者都会在根目录下新建一个 <code>pkg</code> 目录，并且生成一个 <code>util.a</code> 文件。</p><p>并且，在执行前者的时候，会在 GOBIN 目录下生成名为 main 的可执行文件。</p><p>所以，运行 <code>go install</code> 命令，库源码包对应的 <code>.a</code> 文件会被放置到 <code>pkg</code> 目录下，命令源码包生成的可执行文件会被放到 GOBIN 目录。</p><p><code>go install</code> 在 GoPath 有多个目录的时候，会产生一些问题，具体可以去看郝林老师的 <code>Go 命令教程</code>，这里不展开了。</p><h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h2><p><code>go run</code> 用于编译并运行命令源码文件。</p><p>在 hello-world 项目的根目录，执行 go run 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -x -work src/main.go</span><br></pre></td></tr></table></figure><p>-x 可以打印整个过程涉及到的命令，-work 可以看到临时的工作目录：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391387-ae2d3300-9b1f-11e9-9355-a8f59c2eac9b.png" alt="go run 过程"></p><p>从上图中可以看到，仍然是先编译，再连接，最后直接执行，并打印出了执行结果。</p><p>第一行打印的就是工作目录，最终生成的可执行文件就是放置于此：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391357-30692780-9b1f-11e9-8be4-48041779e293.png" alt="go run 结果"></p><p>main 就是最终生成的可执行文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的话题太大了，困难重重。从编译原理到 go 启动时的流程，到 go 命令原理，每个话题单独抽出来都可以写很多。</p><p>幸好有一些很不错的书和博客文章可以去参考。这篇文章就作为一个引子，你可以跟随参考资料里推荐的一些内容去发散。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【《程序员的自我修养》全书】<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">https://book.douban.com/subject/3652388/</a></p><p>【面向信仰编程 编译过程概述】<a href="https://draveness.me/golang-compile-intro" target="_blank" rel="noopener">https://draveness.me/golang-compile-intro</a></p><p>【golang runtime 阅读】<a href="https://github.com/zboya/golang_runtime_reading" target="_blank" rel="noopener">https://github.com/zboya/golang_runtime_reading</a></p><p>【hello-world 项目】<a href="https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world" target="_blank" rel="noopener">https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world</a></p><p>【雨痕大佬的 Go 语言学习笔记】<a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">https://github.com/qyuhen/book</a></p><p>【vim 以 16 进制文本】<a href="https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html" target="_blank" rel="noopener">https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html</a></p><p>【Go 编译命令执行过程】<a href="https://halfrost.com/go_command/" target="_blank" rel="noopener">https://halfrost.com/go_command/</a></p><p>【Go 命令执行过程】<a href="https://github.com/hyper0x/go_command_tutorial" target="_blank" rel="noopener">https://github.com/hyper0x/go_command_tutorial</a></p><p>【Go 词法分析】<a href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</a></p><p>【曹大博客 golang 与 ast】<a href="http://xargin.com/ast/" target="_blank" rel="noopener">http://xargin.com/ast/</a></p><p>【Golang 词法解析器，scanner 源码分析】<a href="https://blog.csdn.net/zhaoruixiang1111/article/details/89892435" target="_blank" rel="noopener">https://blog.csdn.net/zhaoruixiang1111/article/details/89892435</a></p><p>【Gopath Explained】<a href="https://flaviocopes.com/go-gopath/" target="_blank" rel="noopener">https://flaviocopes.com/go-gopath/</a></p><p>【Understanding the GOPATH】<a href="https://www.digitalocean.com/community/tutorials/understanding-the-gopath" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-the-gopath</a></p><p>【讨论】<a href="https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot" target="_blank" rel="noopener">https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot</a></p><p>【Go 官方 Gopath】<a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable" target="_blank" rel="noopener">https://golang.org/cmd/go/#hdr-GOPATH_environment_variable</a></p><p>【Go package 的探索】<a href="https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA</a></p><p>【Go 官方 关于 Go 项目的组织结构】<a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></p><p>【Go modules】<a href="https://www.melvinvivas.com/go-version-1-11-modules/" target="_blank" rel="noopener">https://www.melvinvivas.com/go-version-1-11-modules/</a></p><p>【Golang Installation, Setup, GOPATH, and Go Workspace】<a href="https://www.callicoder.com/golang-installation-setup-gopath-workspace/" target="_blank" rel="noopener">https://www.callicoder.com/golang-installation-setup-gopath-workspace/</a></p><p>【编译、链接过程链接】<a href="https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/" target="_blank" rel="noopener">https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</a></p><p>【1.5 编译器由 go 语言完成】<a href="https://www.infoq.cn/article/2015/08/go-1-5" target="_blank" rel="noopener">https://www.infoq.cn/article/2015/08/go-1-5</a></p><p>【Go 编译过程系列文章】<a href="https://www.ctolib.com/topics-3724.html" target="_blank" rel="noopener">https://www.ctolib.com/topics-3724.html</a></p><p>【曹大 go bootstrap】<a href="https://github.com/cch123/golang-notes/blob/master/bootstrap.md" target="_blank" rel="noopener">https://github.com/cch123/golang-notes/blob/master/bootstrap.md</a></p><p>【golang 启动流程】<a href="https://blog.iceinto.com/posts/go/start/" target="_blank" rel="noopener">https://blog.iceinto.com/posts/go/start/</a></p><p>【探索 golang 程序启动过程】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></p><p>【探索 goroutine 的创建】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/</a><br><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。&lt;/p&gt;
&lt;p&gt;在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
      <category term="编译原理" scheme="https://qcrao.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>曹大谈内存重排</title>
    <link href="https://qcrao.com/2019/06/17/cch-says-memory-reorder/"/>
    <id>https://qcrao.com/2019/06/17/cch-says-memory-reorder/</id>
    <published>2019-06-17T01:00:00.000Z</published>
    <updated>2019-07-31T08:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的参考资料都在文章最后一部分，欢迎自行探索。</p><p>在我读曹大给我的中英文参考资料时，我发现英文的我能读懂，读中文却很费劲。经过对比，我发现，英文文章是由一个例子引入，循序渐进，逐步深入。跟着作者的脚步探索，非常有意思。而中文的博客上来就直奔主题，对于第一次接触的人非常不友好。</p><p>两者就像演绎法和归纳法区别。国内的教材通常是演绎法，也就是上来先讲各种概念、原理，再推出另一些定理，比较枯燥；国外的教材更喜欢由例子引入，步步深入，引人入胜。这里，不去评判孰孰劣。多看看一些英文原版材料，总是有益的。据我所知，曹大经常从亚马逊上购买英文书籍，这个侧面也可以反映曹大的水平高啊。据说英文书一般都很贵，可见曹大也是很有钱的。</p><p>所以啊，技术文章写好不容易，我也自省一下。</p><h1 id="什么是内存重排"><a href="#什么是内存重排" class="headerlink" title="什么是内存重排"></a>什么是内存重排</h1><p>分两种，硬件和软件层面的，包括 CPU 重排、编译器重排。</p><h2 id="CPU-重排"><a href="#CPU-重排" class="headerlink" title="CPU 重排"></a>CPU 重排</h2><p>引用参考资料 <code>【内存一致模型】</code> 里的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>在两个线程里同时执行上面的代码，A 和 B 初始化值都是 0，那最终的输出是什么？</p><p>先说几种显而易见的结果：</p><table><thead><tr><th>执行顺序</th><th>输出结果</th></tr></thead><tbody><tr><td>1-2-3-4</td><td>01</td></tr><tr><td>3-4-1-2</td><td>01</td></tr><tr><td>1-3-2-4</td><td>11</td></tr><tr><td>1-3-4-2</td><td>11</td></tr></tbody></table><p>当然，还有一些对称的情形，和上面表格中列出的输出是一样的。例如，执行为顺序为 3-1-4-2 的输出为 11。</p><p>从 01 的排列组合来看，总共有4种：00、01、10、11。表格中还差两种：10、00。我们来重点分析下这两种结果究竟会不会出现。</p><p>首先是 <code>10</code>，假设 (2) 输出 1，(4) 输出 0。那么首先给 2，3 排个序：(3) -&gt; (2)，因为先要将 B 赋值为 1，(2) 才能打印出 1；同理，(4) -&gt; (1)。另外，因为先打印 1，所以 (2) 要在 (4) 前面，合起来：(3) -&gt; (2) -&gt; (4) -&gt; (1)。(2) 竟然在 (1) 前面执行了，不可能的！</p><p>那我们再分析下 <code>00</code>，要想打印 00，打印语句必须在相应变量赋值前执行：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549674-b455d800-8f93-11e9-83bb-074f2ab4c490.png" alt="00"></p><p>图中箭头表示先后顺序。这就尴尬了，形成了一个环。如果先从 (1) 开始，那顺序就是 (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (1)。(1) 要被执行了 2 次，怎么可能？所以 <code>00</code> 这种情形也是不可能出现的。</p><p>但是，上面说的两种情况在真实世界是有可能发生的。曹大的讲义里有验证的方法，感兴起的同学自己去尝试。总共测试了 100 百万次，测试结果如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59570902-5d561d00-90d1-11e9-842d-cf30babbc0a4.png" alt="test result"></p><p>非常反直觉，但是在多线程的世界，各种诡异的问题，只有你想不到，没有计算机做不到的。</p><p>我们知道，用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。</p><p>其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 <code>内存重排</code>，英文为 <code>Memory Reordering</code>。</p><p>这一部分说的是 CPU 重排，其实还有编译器重排。</p><h2 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h2><p>来看一个代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    X = <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> X</span><br></pre></td></tr></table></figure><p>这段代码执行的结果是打印 100 个 1。一个聪明的编译器会分析到循环里对 X 的赋值 <code>X = 1</code> 是多余的，每次都要给它赋上 1，完全没必要。因此会把代码优化一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">print</span> X</span><br></pre></td></tr></table></figure><p>优化后的运行结果完全和之前的一样，完美！</p><p>但是，如果这时有另外一个线程同时干了这么一件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>由于这两个线程并行执行，优化前的代码运行的结果可能是这样的：<code>11101111...</code>。出现了 1 个 0，但在下次循环中，又会被重新赋值为 1，而且之后一直都是 1。</p><p>但是优化后的代码呢：<code>11100000...</code>。由于把 <code>X = 1</code> 这一条赋值语句给优化掉了，某个时刻 X 变成 <code>0</code> 之后，再也没机会变回原来的 <code>1</code> 了。</p><blockquote><p>在多核心场景下,没有办法轻易地判断两段程序是“等价”的。</p></blockquote><p>可见编译器的重排也是基于运行效率考虑的，但以多线程运行时，就会出各种问题。</p><h1 id="为什么要内存重排"><a href="#为什么要内存重排" class="headerlink" title="为什么要内存重排"></a>为什么要内存重排</h1><p>引用曹大的一句话：</p><blockquote><p>软件或硬件系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的。</p></blockquote><p>软件指的是编译器，硬件是 CPU。不可告人的目的就是：</p><blockquote><p>减少程序指令数<br>最大化提高 CPU 利用率</p></blockquote><p>曹大又皮了！</p><h1 id="内存重排的底层原理"><a href="#内存重排的底层原理" class="headerlink" title="内存重排的底层原理"></a>内存重排的底层原理</h1><p>CPU 重排的例子里提到的两种不可能出现的情况，并不是那么显而易见，甚至是难以理解。原因何在？</p><p>因为我们相信在多线程的程序里，虽然是并行执行，但是访问的是同一块内存，所以没有语句，准确说是指令，能“真正”同时执行的。对同一个内存地址的写，一定是有先有后，先写的结果一定会被后来的操作看到。</p><p>当我们写的代码以单线程运行的时候，语句会按我们的本来意图 <code>顺序</code> 地去执行。一旦单线程变成多线程，情况就变了。</p><p>想像一个场景，有两个线程在运行，操作系统会在它们之间进行调度。每个线程在运行的时候，都会顺序地执行它的代码。由于对同一个变量的读写，会访问内存的同一地址，所以同一时刻只能有一个线程在运行，即使 CPU 有多个核心：前一个指令操作的结果要让后一个指令看到。</p><p>这样带来的后果就是效率低下。两个线程没法做到并行，因为一个线程所做的修改会影响到另一个线程，那后者只能在前者的修改所造成的影响“可见”了之后，才能运行，变成了串行。</p><p>重新来思考前面的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>考虑一个问题，为什么 (2) 要等待 (1) 执行完之后才能执行呢？它们之间又没有什么联系，影响不到彼此，完全可以并行去做啊！</p><p>由于 (1) 是写语句，所以比 (2) 更耗时，从 <code>a single view of memory</code> 这个视角来看，(2) 应该等 (1) 的“效果”对其他所有线程可见了之后才可以执行。但是，在一个现代 CPU 里，这需要花费上百个 CPU 周期。</p><p>现代 CPU 为了“抚平” 内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。</p><p><img src="https://user-images.githubusercontent.com/7698088/59557419-223de600-900c-11e9-8c08-a1ba4b0bbbff.png" alt="cpu cache"></p><p>为了让 (2) 不必等待 (1) 的执行“效果”可见之后才能执行，我们可以把 (1) 的效果保存到 <code>store buffer</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557443-e3f4f680-900c-11e9-975e-82d9b7da74c7.png" alt="store buffer"></p><p>当 (1) 的“效果”写到了 <code>store buffer</code> 后，(2) 就可以开始执行了，不必等到 <code>A = 1</code> 到达 L3 cache。因为 <code>store buffer</code> 是在内核里完成的，所以速度非常快。在这之后的某个时刻，<code>A = 1</code> 会被逐级写到 L3 cache，从而被其他所有线程看到。<code>store buffer</code> 相当于把写的耗时隐藏了起来。</p><p><code>store buffer</code> 对单线程是完美的，例如：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557508-e99f0c00-900d-11e9-81d5-5c7a22faecfc.png" alt="store buffer 1 thread"></p><p>将 (1) 存入 <code>store buffer</code> 后，(2) 开始执行。注意，由于是同一个线程，所以语句的执行顺序还是要保持的。</p><p>(2) 直接从 <code>store buffer</code> 里读出了 <code>A = 1</code>，不必从 L3 Cache 或者内存读取，简直完美！</p><p>有了 <code>store buffer</code> 的概念，我们再来研究前面的那个例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557535-bf9a1980-900e-11e9-9d19-f84a0f3196db.png" alt="store buffer 2 threads"></p><p>先执行 (1) 和 (3)，将他们直接写入 <code>store buffer</code>，接着执行 (2) 和 (4)。“奇迹”要发生了：(2) 看了下  <code>store buffer</code>，并没有发现有 B 的值，于是从 Memory 读出了 0，(4) 同样从 Memory 读出了 0。最后，打印出了 <code>00</code>。</p><p>所有的现代 CPU 都支持 <code>store buffer</code>，这导致了很多对程序员来说是难以理解的现象。从某种角度来说，不等 <code>A = 1</code> 扩散到 Memory，就去执行 <code>print(B)</code> 语句，可以看成<code>读写指令重排</code>。有些 CPU 甚至优化得更多，几乎所有的操作都可以重排，简直是噩梦。</p><p>因此，对于多线程的程序，所有的 CPU 都会提供“锁”支持，称之为 <code>barrier</code>，或者 <code>fence</code>。它要求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A barrier instruction forces all memory operations before it to complete before any memory operation after it can begin.</span><br></pre></td></tr></table></figure><p>barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。</p><p>barrier 指令要耗费几百个 CPU 周期，而且容易出错。因此，我们可以用高级点的 <code>atomic compare-and-swap</code>，或者直接用更高级的锁，通常是标准库提供。</p><blockquote><p>正是 CPU 提供的 barrier 指令，我们才能实现应用层的各种同步原语，如 atomic，而 atomic 又是各种更上层的 lock 的基础。</p></blockquote><p>以上说的是 CPU 重排的原理。编译器重排主要是依据语言自己的“内存模型”，不深入了。</p><p>出现前面描述的诡异现象的根源在于程序存在 <code>data race</code>，也就是说多个线程会同时访问内存的同一个地方，并且至少有一个是写，而且导致了内存重排。所以，最重要的是当我们在写并发程序的时候，要使用一些“同步”的标准库，简单理解就是各种锁，来避免由于内存重排而带来的一些不可预知的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内存重排是指程序在实际运行时对内存的访问顺序和代码编写时的顺序不一致，主要是为了提高运行效率。分别是硬件层面的 <code>CPU 重排</code> 和软件层面的 <code>编译器重排</code>。</p><p>单线程的程序一般不会有太大问题；多线程情况下，有时会出现诡异的现象，解决办法就是使用标准库里的锁。锁会带来性能问题，为了降低影响，锁应该尽量减小粒度，并且不要在互斥区（锁住的代码）放入耗时长的操作。</p><blockquote><p>lock contention 的本质问题是需要进入互斥区的 goroutine 需要等待独占 goroutine 退出后才能进入互斥区，并行 → 串行。</p></blockquote><p>本文讲的是曹大讲座的一部分，我没有深入研究其他内容，例如 MESI协议、cache contention 等，讲清这些又要牵扯到很多，我还是聚集到深度解密 Go 语言系列吧。有兴趣的话，去曹大博客，给我们提供了很多参考链接，可以自行探索。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【曹大 github】<a href="https://github.com/cch123/golang-notes/blob/master/memory_barrier.md" target="_blank" rel="noopener">https://github.com/cch123/golang-notes/blob/master/memory_barrier.md</a></p><p>【曹大讲义】<a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a></p><p>【内存一致模型】<a href="https://homes.cs.washington.edu/~bornholt/post/memory-models.html" target="_blank" rel="noopener">https://homes.cs.washington.edu/~bornholt/post/memory-models.html</a></p><p>【掘金咔叽咔叽，译】<a href="https://juejin.im/post/5d0519e05188257a78764d5d#comment" target="_blank" rel="noopener">https://juejin.im/post/5d0519e05188257a78764d5d#comment</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的
      
    
    </summary>
    
      <category term="操作系统" scheme="https://qcrao.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存重排" scheme="https://qcrao.com/tags/%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之context</title>
    <link href="https://qcrao.com/2019/06/12/dive-into-go-context/"/>
    <id>https://qcrao.com/2019/06/12/dive-into-go-context/</id>
    <published>2019-06-12T01:26:00.000Z</published>
    <updated>2019-07-31T08:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言的 context 包短小精悍，非常适合新手学习。不论是它的源码还是实际使用，都值得投入时间去学习。</p><p>这篇文章依然想尝试全面、深入地去研究。文章相比往期而言，整体不长，希望你看完可以有所收获！</p><h1 id="什么是-context"><a href="#什么是-context" class="headerlink" title="什么是 context"></a>什么是 context</h1><p>Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。</p><p>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</p><p>随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context 几乎成为了并发控制和超时控制的标准做法。</p><blockquote><p>context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。</p></blockquote><blockquote><p>与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行。</p></blockquote><p>没看懂？没关系，先往后看。</p><h1 id="为什么有-context"><a href="#为什么有-context" class="headerlink" title="为什么有 context"></a>为什么有 context</h1><p>Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。</p><p>在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数据，有些调用下游接口获取相关数据……</p><p><img src="https://user-images.githubusercontent.com/7698088/59235934-643ee480-8c26-11e9-8931-456333900657.png" alt="request"></p><p>这些 goroutine 需要共享这个请求的基本数据，例如登陆的 token，处理请求的最大超时时间（如果超过此值再返回数据，请求方因为超时接收不到）等等。当请求被取消或是处理时间太长，这有可能是使用者关闭了浏览器或是已经超过了请求方规定的超时时间，请求方直接放弃了这次请求结果。这时，所有正在为这个请求工作的 goroutine 需要快速退出，因为它们的“工作成果”不再被需要了。在相关联的 goroutine 都退出后，系统就可以回收相关的资源。</p><p>再多说一点，Go 语言中的 server 实际上是一个“协程模型”，也就是说一个协程处理一个请求。例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。这时，肯定有人要背锅了。</p><p>其实前面描述的 P0 级别事故，通过设置“允许下游最长处理时间”就可以避免。例如，给下游设置的 timeout 是 50 ms，如果超过这个值还没有接收到返回数据，就直接向客户端返回一个默认值或者错误。例如，返回商品的一个默认库存数量。注意，这里设置的超时时间和创建一个 http client 设置的读写超时时间不一样，这里不详细展开。可以去看看参考资料<code>【Go 在今日头条的实践】</code>一文，有很精彩的论述。</p><p>context 包就是为了解决上面所说的这些问题而开发的：在 一组 goroutine 之间传递共享的值、取消信号、deadline……</p><p><img src="https://user-images.githubusercontent.com/7698088/59235969-a405cc00-8c26-11e9-9448-2c6c86e8263b.png" alt="request with context"></p><p>用简练一些的话来说，在Go 里，我们不能直接杀死协程，协程的关闭一般会用 <code>channel+select</code> 方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。</p><h1 id="context-底层实现原理"><a href="#context-底层实现原理" class="headerlink" title="context 底层实现原理"></a>context 底层实现原理</h1><p>我们分析的 Go 版本依然是 <code>1.9.2</code>。</p><h2 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h2><p>context 包的代码并不长，<code>context.go</code> 文件总共不到 500 行，其中还有很多大段的注释，代码可能也就 200 行左右的样子，是一个非常值得研究的代码库。</p><p>先给大家看一张整体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/59145775-173af280-8a1b-11e9-8867-c99ce02edb09.png" alt="structure"></p><table><thead><tr><th>类型</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Context</td><td>接口</td><td>定义了 Context 接口的四个方法</td></tr><tr><td>emptyCtx</td><td>结构体</td><td>实现了 Context 接口，它其实是个空的 context</td></tr><tr><td>CancelFunc</td><td>函数</td><td>取消函数</td></tr><tr><td>canceler</td><td>接口</td><td>context 取消接口，定义了两个方法</td></tr><tr><td>cancelCtx</td><td>结构体</td><td>可以被取消</td></tr><tr><td>timerCtx</td><td>结构体</td><td>超时会被取消</td></tr><tr><td>valueCtx</td><td>结构体</td><td>可以存储 k-v 对</td></tr><tr><td>Background</td><td>函数</td><td>返回一个空的 context，常作为根 context</td></tr><tr><td>TODO</td><td>函数</td><td>返回一个空的 context，常用于重构时期，没有合适的 context 可用</td></tr><tr><td>WithCancel</td><td>函数</td><td>基于父 context，生成一个可以取消的 context</td></tr><tr><td>newCancelCtx</td><td>函数</td><td>创建一个可取消的 context</td></tr><tr><td>propagateCancel</td><td>函数</td><td>向下传递 context 节点间的取消关系</td></tr><tr><td>parentCancelCtx</td><td>函数</td><td>找到第一个可取消的父节点</td></tr><tr><td>removeChild</td><td>函数</td><td>去掉父节点的孩子节点</td></tr><tr><td>init</td><td>函数</td><td>包初始化</td></tr><tr><td>WithDeadline</td><td>函数</td><td>创建一个有 deadline 的 context</td></tr><tr><td>WithTimeout</td><td>函数</td><td>创建一个有 timeout 的 context</td></tr><tr><td>WithValue</td><td>函数</td><td>创建一个存储 k-v 对的 context</td></tr></tbody></table><p>上面这张表展示了 context 的所有函数、接口、结构体，可以纵览全局，可以在读完文章后，再回头细看。</p><p>整体类图如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59153629-c1a12d00-8a90-11e9-89a4-eaf3e34f190e.png" alt="classes"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>现在可以直接看源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 当 context 被取消或者到了 deadline，返回一个被关闭的 channel</span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 channel Done 关闭后，返回 context 取消原因</span></span><br><span class="line">Err() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 context 是否会被取消以及自动取消时间（即 deadline）</span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 key 对应的 value</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Context</code> 是一个接口，定义了 4 个方法，它们都是<code>幂等</code>的。也就是说连续多次调用同一个方法，得到的结果都是相同的。</p><p><code>Done()</code> 返回一个 channel，可以表示 context 被取消的信号：当这个 channel 被关闭时，说明 context 被取消了。注意，这是一个只读的channel。 我们又知道，读一个关闭的 channel 会读出相应类型的零值。并且源码里没有地方会向这个 channel 里面塞入值。换句话说，这是一个 <code>receive-only</code> 的 channel。因此在子协程里读这个 channel，除非被关闭，否则读不出来任何东西。也正是利用了这一点，子协程从 channel 里读出了值（零值）后，就可以做一些收尾工作，尽快退出。</p><p><code>Err()</code> 返回一个错误，表示 channel 被关闭的原因。例如是被取消，还是超时。</p><p><code>Deadline()</code> 返回 context 的截止时间，通过此时间，函数就可以决定是否进行接下来的操作，如果时间太短，就可以不往下做了，否则浪费系统资源。当然，也可以用这个 deadline 来设置一个 I/O 操作的超时时间。</p><p><code>Value()</code> 获取之前设置的 key 对应的 value。</p><h3 id="canceler"><a href="#canceler" class="headerlink" title="canceler"></a>canceler</h3><p>再来看另外一个接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了上面定义的两个方法的 Context，就表明该 Context 是可取消的。源码中有两个类型实现了 canceler 接口：<code>*cancelCtx</code> 和 <code>*timerCtx</code>。注意是加了 <code>*</code> 号的，是这两个结构体的指针实现了 canceler 接口。</p><p>Context 接口设计成这个样子的原因：</p><ul><li>“取消”操作应该是建议性，而非强制性</li></ul><p>caller 不应该去关心、干涉 callee 的情况，决定如何以及何时 return 是 callee 的责任。caller 只需发送“取消”信息，callee 根据收到的信息来做进一步的决策，因此接口并没有定义 cancel 方法。</p><ul><li>“取消”操作应该可传递</li></ul><p>“取消”某个函数时，和它相关联的其他函数也应该“取消”。因此，<code>Done()</code> 方法返回一个只读的 channel，所有相关函数监听此 channel。一旦 channel 关闭，通过 channel 的“广播机制”，所有监听者都能收到。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><p>源码中定义了 <code>Context</code> 接口后，并且给出了一个实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这段源码，非常 happy。因为每个函数都实现的异常简单，要么是直接返回，要么是返回 nil。</p><p>所以，这实际上是一个空的 context，永远不会被 cancel，没有存储值，也没有 deadline。</p><p>它被包装成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过下面两个导出的函数（首字母大写）对外公开：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>background 通常用在 main 函数中，作为所有 context 的根节点。</p><p>todo 通常用在并不知道传递什么 context的情形。例如，调用一个需要传递 context 参数的函数，你手头并没有其他 context 可以传递，这时就可以传递 todo。这常常发生在重构进行中，给一些函数添加了一个 Context 参数，但不知道要传什么，就用 todo “占个位子”，最终要换成其他 context。</p><h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><p>再来看一个重要的 context：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护之后的字段</span></span><br><span class="line">mu       sync.Mutex</span><br><span class="line">done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">err      error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个可以取消的 Context，实现了 canceler 接口。它直接将接口 Context 作为它的一个匿名字段，这样，它就可以被看成一个 Context。</p><p>先来看 <code>Done()</code> 方法的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">d := c.done</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c.done 是“懒汉式”创建，只有调用了 Done() 方法的时候才会被创建。再次说明，函数返回的是一个只读的 channel，而且没有地方向这个 channel 里面写数据。所以，直接调用读这个 channel，协程会被 block 住。一般通过搭配 select 来使用。一旦关闭，就会立即读出零值。</p><p><code>Err()</code> 和 <code>String()</code> 方法比较简单，不多说。推荐看源码，非常简单。</p><p>接下来，我们重点关注 <code>cancel()</code> 方法的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 必须要传 err</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 已经被其他协程取消</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给 err 字段赋值</span></span><br><span class="line">c.err = err</span><br><span class="line"><span class="comment">// 关闭 channel，通知其他协程</span></span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = closedchan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c.done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历它的所有子节点</span></span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">    <span class="comment">// 递归地取消所有子节点</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子节点置空</span></span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">    <span class="comment">// 从父节点中移除自己 </span></span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来看，<code>cancel()</code> 方法的功能就是关闭 channel：c.done；递归地取消它的所有子节点；从父节点从删除自己。达到的效果是通过关闭 channel，将取消信号传递给了它的所有子节点。goroutine 接收到取消信号的方式就是 select 语句中的<code>读 c.done</code> 被选中。</p><p>我们再来看创建一个可取消的 Context 的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个暴露给用户的方法，传入一个父 Context（这通常是一个 <code>background</code>，作为根节点），返回新建的 context，新 context 的 done channel 是新建的（前文讲过）。</p><p>当 WithCancel 函数返回的 CancelFunc 被调用或者是父节点的 done channel 被关闭（父节点的 CancelFunc 被调用），此 context（子节点） 的 done channel 也会被关闭。</p><p>注意传给 WithCancel 方法的参数，前者是 true，也就是说取消的时候，需要将自己从父节点里删除。第二个参数则是一个固定的取消错误类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">"context canceled"</span>)</span><br></pre></td></tr></table></figure><p>还注意到一点，调用子节点 cancel 方法的时候，传入的第一个参数 <code>removeFromParent</code> 是 false。</p><p>两个问题需要回答：1. 什么时候会传 true？2. 为什么有时传 true，有时传 false？</p><p>当 <code>removeFromParent</code> 为 true 时，会将当前节点的 context 从父节点 context 中删除：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">p, ok := parentCancelCtx(parent)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的一行：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br></pre></td></tr></table></figure><p>什么时候会传 true 呢？答案是调用 <code>WithCancel()</code> 方法的时候，也就是新创建一个可取消的 context 节点时，返回的 cancelFunc 函数会传入 true。这样做的结果是：当调用返回的 cancelFunc 时，会将这个 context 从它的父节点里“除名”，因为父节点可能有很多子节点，你自己取消了，所以我要和你断绝关系，对其他人没影响。</p><p>在取消函数内部，我知道，我所有的子节点都会因为我的一：<code>c.children = nil</code> 而化为灰烬。我自然就没有必要再多做这一步，最后我所有的子节点都会和我断绝关系，没必要一个个做。另外，如果遍历子节点的时候，调用 child.cancel 函数传了 true，还会造成同时遍历和删除一个 map 的境地，会有问题的。</p><p><img src="https://user-images.githubusercontent.com/7698088/59315867-37ee9b00-8cee-11e9-8c19-9a4cf7606d14.png" alt="context cancel"></p><p>如上左图，代表一棵 context 树。当调用左图中标红 context 的 cancel 方法后，该 context 从它的父 context 中去除掉了：实线箭头变成了虚线。且虚线圈框出来的 context 都被取消了，圈内的 context 间的父子关系都荡然无存了。</p><p>重点看 <code>propagateCancel()</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="comment">// 父节点是个空节点</span></span><br><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到可以取消的父 context</span></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 父节点已经被取消了，本节点（子节点）也要取消</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 父节点未取消</span></span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "挂到"父节点上</span></span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用就是向上寻找可以“挂靠”的“可取消”的 context，并且“挂靠”上去。这样，调用上层 cancel 方法的时候，就可以层层传递，将那些挂靠的子 context 同时“取消”。</p><p>这里着重解释下为什么会有 else 描述的情况发生。<code>else</code> 是指当前节点 context 没有向上找到可以取消的父节点，那么就要再启动一个协程监控父节点或者子节点的取消动作。</p><p>这里就有疑问了，既然没找到可以取消的父节点，那 <code>case &lt;-parent.Done()</code> 这个 case 就永远不会发生，所以可以忽略这个 case；而 <code>case &lt;-child.Done()</code> 这个 case 又啥事不干。那这个 <code>else</code> 不就多余了吗？</p><p>其实不然。我们来看 <code>parentCancelCtx</code> 的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *cancelCtx:</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> *timerCtx:</span><br><span class="line"><span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> *valueCtx:</span><br><span class="line">parent = c.Context</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只会识别三种 Context 类型：<em>cancelCtx，</em>timerCtx，*valueCtx。若是把 Context 内嵌到一个类型里，就识别不出来了。</p><p>由于 context 包的代码并不多，所以我直接把它 copy 出来了，然后在 else 语句里加上了几条打印语句，来验证上面的说法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyContext <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 Context 是我 copy 出来的，所以前面不用加 context.</span></span><br><span class="line">Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">childCancel := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">parentCtx, parentFunc := WithCancel(Background())</span><br><span class="line">mctx := MyContext&#123;parentCtx&#125;</span><br><span class="line"></span><br><span class="line">childCtx, childFun := WithCancel(mctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> childCancel &#123;</span><br><span class="line">childFun()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parentFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(parentCtx)</span><br><span class="line">fmt.Println(mctx)</span><br><span class="line">fmt.Println(childCtx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止主协程退出太快，子协程来不及打印 </span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自已在 else 里添加的打印语句我就不贴出来了，感兴趣的可以自己动手实验下。我们看下三个 context 的打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.Background.WithCancel</span><br><span class="line">&#123;context.Background.WithCancel&#125;</span><br><span class="line">&#123;context.Background.WithCancel&#125;.WithCancel</span><br></pre></td></tr></table></figure><p>果然，mctx，childCtx 和正常的 parentCtx 不一样，因为它是一个自定义的结构体类型。</p><p><code>else</code> 这段代码说明，如果把 ctx 强行塞进一个结构体，并用它作为父节点，调用 WithCancel 函数构建子节点 context 的时候，Go 会新启动一个协程来监控取消信号，明显有点浪费嘛。</p><p>再来说一下，select 语句里的两个 case 其实都不能删。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 case 说明当父节点取消，则取消子节点。如果去掉这个 case，那么父节点取消的信号就不能传递到子节点。</p><p>第二个 case 是说如果子节点自己取消了，那就退出这个 select，父节点的取消信号就不用管了。如果去掉这个 case，那么很可能父节点一直不取消，这个 goroutine 就泄漏了。当然，如果父节点取消了，就会重复让子节点取消，不过，这也没什么影响嘛。</p><h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><p>timerCtx 基于 cancelCtx，只是多了一个 time.Timer 和一个 deadline。Timer 会在 deadline 到来时，自动取消 context。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timerCtx 首先是一个 cancelCtx，所以它能取消。看下 cancel() 方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接调用 cancelCtx 的取消方法</span></span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line"><span class="comment">// 从父节点中删除子节点</span></span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 关掉定时器，这样，在deadline 到来时，不会再次取消</span></span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 timerCtx 的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WithTimeout</code> 函数直接调用了 <code>WithDeadline</code>，传入的 deadline 是当前时间加上 timeout 的时间，也就是从现在开始再经过 timeout 时间就算超时。也就是说，<code>WithDeadline</code> 需要用的是绝对时间。重点来看它：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) &#123;</span><br><span class="line"><span class="comment">// 如果父节点 context 的 deadline 早于指定时间。直接构建一个可取消的 context。</span></span><br><span class="line"><span class="comment">// 原因是一旦父节点超时，自动调用 cancel 函数，子节点也会随之取消。</span></span><br><span class="line"><span class="comment">// 所以不用单独处理子节点的计时器时间到了之后，自动调用 cancel 函数</span></span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 timerCtx</span></span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  deadline,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 挂靠到父节点上</span></span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前距离 deadline 的时间</span></span><br><span class="line">d := time.Until(deadline)</span><br><span class="line"><span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接取消</span></span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// d 时间后，timer 会自动调用 cancel 函数。自动取消</span></span><br><span class="line">c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说仍然要把子节点挂靠到父节点，一旦父节点取消了，会把取消信号向下传递到子节点，子节点随之取消。</p><p>有一个特殊情况是，如果要创建的这个子节点的 deadline 比父节点要晚，也就是说如果父节点是时间到自动取消，那么一定会取消这个子节点，导致子节点的 deadline 根本不起作用，因为子节点在 deadline 到来之前就已经被父节点取消了。</p><p>这个函数的最核心的一句是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.timer = time.AfterFunc(d, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>c.timer 会在 d 时间间隔后，自动调用 cancel 函数，并且传入的错误就是 <code>DeadlineExceeded</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DeadlineExceeded error = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>   &#123; <span class="keyword">return</span> <span class="string">"context deadline exceeded"</span> &#125;</span><br></pre></td></tr></table></figure><p>也就是超时错误。</p><h3 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实现了两个方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithValue(%#v, %#v)"</span>, c.Context, c.key, c.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于它直接将 Context 作为匿名字段，因此仅管它只实现了 2 个方法，其他方法继承自父 context。但它仍然是一个 Context，这是 Go 语言的一个特点。</p><p>创建 valueCtx 的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 key 的要求是可比较，因为之后需要通过 key 取出 context 中的值，可比较是必须的。</p><p>通过层层传递 context，最终形成这样一棵树：</p><p><img src="https://user-images.githubusercontent.com/7698088/59154893-5e72c300-8aaf-11e9-9b78-3c34b5e73a45.png" alt="valueCtx"></p><p>和链表有点像，只是它的方向相反：Context 指向它的父节点，链表则指向下一个节点。通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。</p><p>取值的过程，实际上是一个递归查找的过程：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会顺着链路一直往上找，比较当前节点的 key<br>是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</p><p>因为查找方向是往上走的，所以，父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><p><code>WithValue</code> 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 <code>WithValue</code> 构造的其实是一个低效率的链表。</p><p>如果你接手过项目，肯定经历过这样的窘境：在一个处理过程中，有若干子函数、子协程。各种不同的地方会向 context 里塞入各种不同的 k-v 对，最后在某个地方使用。</p><p>你根本就不知道什么时候什么地方传了什么值？这些值会不会被“覆盖”（底层是两个不同的 context 节点，查找的时候，只会返回一个结果）？你肯定会崩溃的。</p><p>而这也是 <code>context.Value</code> 最受争议的地方。很多人建议尽量不要通过 context 传值。</p><h1 id="如何使用-context"><a href="#如何使用-context" class="headerlink" title="如何使用 context"></a>如何使用 context</h1><p>context 使用起来非常方便。源码里对外提供了一个创建根节点 context 的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>background 是一个空的 context， 它不能被取消，没有值，也没有超时时间。</p><p>有了根节点 context，又提供了四个函数创建子节点 context：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>context 会在函数传递间传递。只需要在适当的时间调用 cancel 函数向 goroutines 发出取消信号或者调用 Value 函数取出 context 中的值。</p><p>在官方博客里，对于使用 context 提出了几点建议：</p><ol><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx.</li><li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</li><li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li></ol><p>我翻译一下：</p><ol><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li><li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li></ol><h2 id="传递共享的数据"><a href="#传递共享的数据" class="headerlink" title="传递共享的数据"></a>传递共享的数据</h2><p>对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有） 的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">process(ctx)</span><br><span class="line"></span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">"traceId"</span>, <span class="string">"qcrao-2019"</span>)</span><br><span class="line">process(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">traceId, ok := ctx.Value(<span class="string">"traceId"</span>).(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"process over. trace_id=%s\n"</span>, traceId)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"process over. no trace_id\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process over. no trace_id</span><br><span class="line">process over. trace_id=qcrao-2019</span><br></pre></td></tr></table></figure><p>第一次调用 process 函数时，ctx 是一个空的 context，自然取不出来 traceId。第二次，通过 <code>WithValue</code> 函数创建了一个 context，并赋上了 <code>traceId</code> 这个 key，自然就能取出来传入的 value 值。</p><p>当然，现实场景中可能是从一个 HTTP 请求中获取到的 Request-ID。所以，下面这个样例可能更适合：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestIDKey <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRequestID</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 从 header 中提取 request-id</span></span><br><span class="line">reqID := req.Header.Get(<span class="string">"X-Request-ID"</span>)</span><br><span class="line"><span class="comment">// 创建 valueCtx。使用自定义的类型，不容易冲突</span></span><br><span class="line">ctx := context.WithValue(</span><br><span class="line">req.Context(), requestIDKey, reqID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的请求</span></span><br><span class="line">req = req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 HTTP 处理函数</span></span><br><span class="line">next.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 request-id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRequestID</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ctx.Value(requestIDKey).(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(rw http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 拿到 reqId，后面可以记录日志等等</span></span><br><span class="line">reqID := GetRequestID(req.Context())</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := WithRequestID(http.HandlerFunc(Handle))</span><br><span class="line">http.ListenAndServe(<span class="string">"/"</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消-goroutine"><a href="#取消-goroutine" class="headerlink" title="取消 goroutine"></a>取消 goroutine</h2><p>我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要“取消”此过程，退出 goroutine，系统回收资源。</p><p>后端可能的实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perform</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        calculatePos()</span><br><span class="line">        sendResult()</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要实现“取消”功能，并且在不了解 context 功能的前提下，可能会这样做：给函数增加一个指针型的 bool 变量，在 for 语句的开始处判断 bool 变量是发由 true 变为 false，如果改变，则退出循环。</p><p>上面给出的简单做法，可以实现想要的效果，没有问题，但是并不优雅，并且一旦协程数量多了之后，并且各种嵌套，就会很麻烦。优雅的做法，自然就要用到 context。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perform</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        calculatePos()</span><br><span class="line">        sendResult()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 被取消，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            <span class="comment">// block 1 秒钟 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流程可能是这样的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)</span><br><span class="line"><span class="keyword">go</span> Perform(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">// app 端返回页面，调用cancel 函数</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure><p>注意一个细节，WithTimeOut 函数返回的 context 和 cancelFun 是分开的。context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context。</p><h2 id="防止-goroutine-泄漏"><a href="#防止-goroutine-泄漏" class="headerlink" title="防止 goroutine 泄漏"></a>防止 goroutine 泄漏</h2><p>前面那个例子里，goroutine 还是会自己执行完，最后返回，只不过会多浪费一些系统资源。这里改编一个“如果不用 context 取消，goroutine 就会泄漏的例子”，来自参考资料：<code>【避免协程泄漏】</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ch &lt;- n</span><br><span class="line">n++</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个可以生成无限整数的协程，但如果我只需要它产生的前 5 个数，那么就会发生 goroutine 泄漏：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen() &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 n == 5 的时候，直接 break 掉。那么 gen 函数的协程就会执行无限循环，永远不会停下来。发生了 goroutine 泄漏。</p><p>用 context 改进这个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">n++</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 避免其他地方忘记 cancel，且重复调用不影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加一个 context，在 break 前调用 cancel 函数，取消 goroutine。gen 函数在接收到取消信号后，直接退出，系统回收资源。</p><h1 id="context-真的这么好吗"><a href="#context-真的这么好吗" class="headerlink" title="context 真的这么好吗"></a>context 真的这么好吗</h1><p>读完全文，你一定有这种感觉：context 就是为 server 而设计的。说什么处理一个请求，需要启动多个 goroutine 并行地去处理，并且在这些 goroutine 之间还要传递一些共享的数据等等，这些都是写一个 server 要做的事。</p><p>没错，Go 很适合写 server，但它终归是一门通用的语言。你在用 Go 做 Leetcode 上面的题目的时候，肯定不会认为它和一般的语言有什么差别。所以，很多特性好不好，应该从 <code>Go 只是一门普通的语言，很擅长写 server</code> 的角度来看。</p><p>从这个角度来看，context 并没有那么美好。Go 官方建议我们把 Context 作为函数的第一个参数，甚至连名字都准备好了。这造成一个后果：因为我们想控制所有的协程的取消动作，所以需要在几乎所有的函数里加上一个 Context 参数。很快，我们的代码里，context 将像病毒一样扩散的到处都是。</p><p>在参考资料<code>【Go2 应该去掉 context】</code>这篇英文博客里，作者甚至调侃说：如果要把 Go 标准库的大部分函数都加上 context 参数的话，例如下面这样：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, err := r.Read(context.TODO(), p)</span><br></pre></td></tr></table></figure><p>就给我来一枪吧！</p><p>原文是这样说的：<code>put a bullet in my head, please.</code>我当时看到这句话的时候，会心一笑。这可能就是陶渊明说的：每有会意，便欣然忘食。当然，我是在晚饭会看到这句话的。</p><p>为了表达自己对 context 并没有什么好感，作者接着又说了一句：If you use ctx.Value in my (non-existent) company, you’re fired. 简直太幽默了，哈哈。</p><p>另外，像 <code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithValue</code> 这些创建函数，实际上是创建了一个个的链表结点而已。我们知道，对链表的操作，通常都是 <code>O(n)</code> 复杂度的，效率不高。</p><p>那么，context 包到底解决了什么问题呢？答案是：<code>cancelation</code>。仅管它并不完美，但它确实很简洁地解决了问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个 context 包的内容就全部讲完了。源码非常短，很适合学习，一定要去读一下。</p><p>context 包是 Go 1.7 引入的标准库，主要用于在 goroutine 之间传递取消信号、超时时间、截止时间以及一些共享的值等。它并不是太完美，但几乎成了并发控制和超时控制的标准做法。</p><p>使用上，先创建一个根节点的 context，之后根据库提供的四个函数创建相应功能的子节点 context。由于它是并发安全的，所以可以放心地传递。</p><p>当使用 context 作为函数参数时，直接把它放在第一个参数的位置，并且命名为 ctx。另外，不要把 context 嵌套在自定义的类型里。</p><p>最后，大家下次在看到代码里有用到 context 的，观察下是怎么使用的，肯定逃不出我们讲的几种类型。熟悉之后会发现：context 可能并不完美，但它确实简洁高效地解决了问题。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【context 官方博客】<a href="https://blog.golang.org/context" target="_blank" rel="noopener">https://blog.golang.org/context</a></p><p>【今日头条构建Go的实践】<a href="https://zhuanlan.zhihu.com/p/26695984" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26695984</a></p><p>【飞雪无情的博客】<a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></p><p>【context 源码】<a href="https://juejin.im/post/5a6873fef265da3e317e55b6" target="_blank" rel="noopener">https://juejin.im/post/5a6873fef265da3e317e55b6</a></p><p>【腾讯云源码阅读】<a href="https://cloud.tencent.com/developer/section/1140703" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1140703</a></p><p>【更宏观地一些思考，english】<a href="https://siadat.github.io/post/context" target="_blank" rel="noopener">https://siadat.github.io/post/context</a></p><p>【避免协程泄漏】<a href="https://rakyll.org/leakingctx/" target="_blank" rel="noopener">https://rakyll.org/leakingctx/</a></p><p>【应用分类】<a href="https://dreamerjonson.com/2019/05/09/golang-73-context/index.html" target="_blank" rel="noopener">https://dreamerjonson.com/2019/05/09/golang-73-context/index.html</a></p><p>【官方文档示例翻译版】<a href="https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/" target="_blank" rel="noopener">https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/</a></p><p>【例子，english】<a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/" target="_blank" rel="noopener">http://p.agnihotry.com/post/understanding_the_context_package_in_golang/</a></p><p>【Go2 应该去掉 context】<a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">https://faiface.github.io/post/context-should-go-away-go2/</a></p><p>【源码，比较详细】<a href="https://juejin.im/post/5c1514c86fb9a049b82a5acb" target="_blank" rel="noopener">https://juejin.im/post/5c1514c86fb9a049b82a5acb</a></p><p>【Golang Context 是好的设计吗？】<a href="https://segmentfault.com/a/1190000017394302" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017394302</a></p><p>【今日头条的 Go 实践】<a href="https://36kr.com/p/5073181" target="_blank" rel="noopener">https://36kr.com/p/5073181</a></p><p>【实例】<a href="https://zhuanlan.zhihu.com/p/60180409" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60180409</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言的 context 包短小精悍，非常适合新手学习。不论是它的源码还是实际使用，都值得投入时间去学习。&lt;/p&gt;
&lt;p&gt;这篇文章依然想尝试全面、深入地去研究。文章相比往期而言，整体不长，希望你看完可以有所收获！&lt;/p&gt;
&lt;h1 id=&quot;什么是-context&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之unsafe</title>
    <link href="https://qcrao.com/2019/06/03/dive-into-go-unsafe/"/>
    <id>https://qcrao.com/2019/06/03/dive-into-go-unsafe/</id>
    <published>2019-06-03T00:25:00.000Z</published>
    <updated>2020-04-23T15:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA" target="_blank" rel="noopener">文章</a>我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 <code>unsafe.Pointer</code> 不陌生，map 对 key 进行定位的时候，大量使用。</p><p><code>unsafe.Pointer</code> 位于 <code>unsafe 包</code>，这篇文章，我们来深入研究 unsafe 包。先说明一下，本文没有之前那么长了，你可以比较轻松地读完，这样的时候不是太多。</p><p>上次发布文章的时候，包括代码超过 5w 字，后台编辑器的体验非常差，一度让我怀疑人生。我之前说过，像 map 那样的长文，估计能读完的不超过 <code>1 %</code>。像下面这几位同学的评价，并不多见。</p><p><img src="https://user-images.githubusercontent.com/7698088/58759953-7eacfa00-8564-11e9-9d92-9974ffe7f8d7.png" alt="wechat"></p><p>个人认为，学习本身并不是一件轻松愉快的事情，寓教于乐是个美好的愿望。想要深刻地领悟，就得付出别人看不见的努力。学习从来都不会是一件轻松的事情，枯燥是正常的。耐住性子，深入研究某个问题，读书、看文章、写博客都可以，浮躁时代做个专注的人！</p><h1 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h1><p>在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。</p><p>我本科开始学编程的时候，第一门语言就是 C。之后又陆续学过 C++，Java，Python，这些语言都挺强大的，但是没了 C 语言那么“单纯”。直到我开始接触 Go 语言，又找到了那种感觉。Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。</p><p>然而，Go 语言的指针相比 C 的指针有很多限制。这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？更别说像 C/C++ 还需要程序员自己清理“垃圾”。所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。</p><p>为什么需要指针类型呢？参考文献 go101.org 里举了这样一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x += x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">double(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是<code>值传递</code>。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。</p><p>如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*x += *x</span><br><span class="line">x = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">double(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">p := &amp;a</span><br><span class="line">double(p)</span><br><span class="line">fmt.Println(a, p == <span class="literal">nil</span>) <span class="comment">// 12 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 &amp;a 的一个拷贝。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*x += *x</span><br></pre></td></tr></table></figure><p>这一句把 x 指向的值（也就是 &amp;a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 <code>x = nil</code> 掀不起任何大风大浪。</p><p>下面的这张图可以“自证清白”：</p><p><img src="https://user-images.githubusercontent.com/7698088/58675362-96c72280-8386-11e9-89a6-f37204648b03.png" alt="pointer copy"></p><p>然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。</p><p>限制一：<code>Go 的指针不能进行数学运算</code>。</p><p>来看一个简单的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">5</span></span><br><span class="line">p := &amp;a</span><br><span class="line"></span><br><span class="line">p++</span><br><span class="line">p = &amp;a + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面的代码将不能通过编译，会报编译错误：<code>invalid operation</code>，也就是说不能对指针做数学运算。</p><p>限制二：<code>不同类型的指针不能相互转换</code>。</p><p>例如下面这个简短的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">int</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> f *<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">f = &amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也会报编译错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use &amp;a (type *int) as type *float64 in assignment</span><br></pre></td></tr></table></figure><p>关于两个指针能否相互转换，参考资料中 go 101 相关文章里写得非常细，这里我不想展开。个人认为记住这些没有什么意义，有完美主义的同学可以去阅读原文。当然我也有完美主义，但我有时会克制，嘿嘿。</p><p>限制三：<code>不同类型的指针不能使用 == 或 != 比较</code>。</p><p>只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较。</p><p>限制四：<code>不同类型的指针变量不能相互赋值</code>。</p><p>这一点同限制三。</p><h1 id="什么是-unsafe"><a href="#什么是-unsafe" class="headerlink" title="什么是 unsafe"></a>什么是 unsafe</h1><p>前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。</p><p>unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。</p><p>但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。</p><h1 id="为什么有-unsafe"><a href="#为什么有-unsafe" class="headerlink" title="为什么有 unsafe"></a>为什么有 unsafe</h1><p>Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。</p><h1 id="unsafe-实现原理"><a href="#unsafe-实现原理" class="headerlink" title="unsafe 实现原理"></a>unsafe 实现原理</h1><p>我们来看源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure><p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p><p>unsafe 包还有其他三个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p><code>Sizeof</code> 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。</p><p><code>Offsetof</code> 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。</p><p><code>Alignof</code> 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。</p><p>注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 <code>const 型变量</code>。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。</p><p>综上所述，unsafe 包提供了 2 点重要的能力：</p><blockquote><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/58747453-1dbaee80-849e-11e9-8c75-2459f76792d2.png" alt="type pointer uintptr"></p><p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uintptr 是一个整数类型，它足够大，可以存储</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">uintptr</span> <span class="keyword">uintptr</span></span><br></pre></td></tr></table></figure><p>还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><p>unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 <code>/usr/local/go/src/cmd/compile/internal/gc/unsafe.go</code> 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。</p><p>更深层的原理需要去研究编译器的源码，这里就不去深究了。我们重点关注它的用法，接着往下看。</p><h1 id="unsafe-如何使用"><a href="#unsafe-如何使用" class="headerlink" title="unsafe 如何使用"></a>unsafe 如何使用</h1><h2 id="获取-slice-长度"><a href="#获取-slice-长度" class="headerlink" title="获取 slice 长度"></a>获取 slice 长度</h2><p>通过前面关于 slice 的<a href="https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA" target="_blank" rel="noopener">文章</a>，我们知道了 slice header 的结构体定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span></span><br></pre></td></tr></table></figure><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> Len = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line">fmt.Println(Len, <span class="built_in">len</span>(s)) <span class="comment">// 9 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cap = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span><br><span class="line">fmt.Println(Cap, <span class="built_in">cap</span>(s)) <span class="comment">// 20 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Len，cap 的转换流程如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Len: &amp;s =&gt; pointer =&gt; <span class="keyword">uintptr</span> =&gt; pointer =&gt; *<span class="keyword">int</span> =&gt; <span class="keyword">int</span></span><br><span class="line">Cap: &amp;s =&gt; pointer =&gt; <span class="keyword">uintptr</span> =&gt; pointer =&gt; *<span class="keyword">int</span> =&gt; <span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="获取-map-长度"><a href="#获取-map-长度" class="headerlink" title="获取 map 长度"></a>获取 map 长度</h2><p>再来看一下上篇文章我们讲到的 map：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count     <span class="keyword">int</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span></span><br><span class="line">noverflow <span class="keyword">uint16</span></span><br><span class="line">hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line">nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span></span><br></pre></td></tr></table></figure><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">mp[<span class="string">"qcrao"</span>] = <span class="number">100</span></span><br><span class="line">mp[<span class="string">"stefno"</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">count := **(**<span class="keyword">int</span>)(unsafe.Pointer(&amp;mp))</span><br><span class="line">fmt.Println(count, <span class="built_in">len</span>(mp)) <span class="comment">// 2 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count 的转换过程：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;mp =&gt; pointer =&gt; **<span class="keyword">int</span> =&gt; <span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="map-源码中的应用"><a href="#map-源码中的应用" class="headerlink" title="map 源码中的应用"></a>map 源码中的应用</h2><p>在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。</p><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure><p><code>h.buckets</code> 是一个 <code>unsafe.Pointer</code>，将它转换成 <code>uintptr</code>，然后加上 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，二者相加的结果再次转换成 <code>unsafe.Pointer</code>，最后，转换成 <code>bmap 指针</code>，得到 key 所落入的 bucket 位置。如果不熟悉这个公式，可以看看上一篇文章，浅显易懂。</p><p>上面举的例子相对简单，来看一个关于赋值的更难一点的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store new key/value at insert position</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">kmem := newobject(t.key)</span><br><span class="line">*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">insertk = kmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">vmem := newobject(t.elem)</span><br><span class="line">*(*unsafe.Pointer)(val) = vmem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedmemmove(t.key, insertk, key)</span><br></pre></td></tr></table></figure><p>这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成<code>指针的指针</code>，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。</p><p>下面这张图展示了设置 key 的全部操作：</p><p><img src="https://user-images.githubusercontent.com/7698088/58756044-c1e67900-8522-11e9-9dda-72ba2a731acf.png" alt="map assign"></p><p>obj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 <code>typedmemmove</code> 函数后，被成功赋值。</p><h2 id="Offsetof-获取成员偏移量"><a href="#Offsetof-获取成员偏移量" class="headerlink" title="Offsetof 获取成员偏移量"></a>Offsetof 获取成员偏移量</h2><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p><p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p><p>我们来看一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := Programmer&#123;<span class="string">"stefno"</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">fmt.Println(p)</span><br><span class="line"></span><br><span class="line">name := (*<span class="keyword">string</span>)(unsafe.Pointer(&amp;p))</span><br><span class="line">*name = <span class="string">"qcrao"</span></span><br><span class="line"></span><br><span class="line">lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.language)))</span><br><span class="line">*lang = <span class="string">"Golang"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno go&#125;</span><br><span class="line">&#123;qcrao Golang&#125;</span><br></pre></td></tr></table></figure><p>name 是结构体的第一个成员，因此可以直接将 &amp;p 解析成 *string。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。</p><p>对于结构体的私有成员，现在有办法可以通过 unsafe.Pointer 改变它的值了。</p><p>我把 Programmer 结构体升级，多加一个字段：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := Programmer&#123;<span class="string">"stefno"</span>, <span class="number">18</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">fmt.Println(p)</span><br><span class="line"></span><br><span class="line">lang := (*<span class="keyword">string</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">0</span>)) + unsafe.Sizeof(<span class="keyword">string</span>(<span class="string">""</span>))))</span><br><span class="line">*lang = <span class="string">"Golang"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;stefno 18 go&#125;</span><br><span class="line">&#123;stefno 18 Golang&#125;</span><br></pre></td></tr></table></figure><h2 id="string-和-slice-的相互转换"><a href="#string-和-slice-的相互转换" class="headerlink" title="string 和 slice 的相互转换"></a>string 和 slice 的相互转换</h2><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是反射包下的结构体，路径：src/reflect/value.go。只需要共享底层 []byte 数组就可以实现 <code>zero-copy</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line"></span><br><span class="line">bh := reflect.SliceHeader&#123;</span><br><span class="line">Data: stringHeader.Data,</span><br><span class="line">Len:  stringHeader.Len,</span><br><span class="line">Cap:  stringHeader.Len,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;bh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func bytes2string(b []byte) string&#123;</span></span><br><span class="line"><span class="comment">// sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sh := reflect.StringHeader&#123;</span></span><br><span class="line"><span class="comment">// Data: sliceHeader.Data,</span></span><br><span class="line"><span class="comment">// Len:  sliceHeader.Len,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return *(*string)(unsafe.Pointer(&amp;sh))</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/qcrao/Go-Questions/issues/7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，不作详细解释。通过构造 slice header 和 string header，来完成 string 和 byte slice 之间的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p><p>unsafe 包定义了 Pointer 和三个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p>通过三个函数可以获取变量的大小、偏移、对齐等信息。</p><p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。</p><p>通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。关于 unsafe 包，我们更多关注它的用法。</p><p>顺便说一句，unsafe 包用多了之后，也不觉得它的名字有多么地不“美观”了。相反，因为使用了官方并不提倡的东西，反而觉得有点酷炫。这就是叛逆的感觉吧。</p><p>最后，点击<a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">阅读原文</a>，你将参与见证一个千星项目的成长，你值得拥有！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【飞雪无情的博客】<a href="https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html</a></p><p>【译文 unsafe包详解】<a href="https://gocn.vip/question/371" target="_blank" rel="noopener">https://gocn.vip/question/371</a></p><p>【官方文档】<a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">https://golang.org/pkg/unsafe/</a></p><p>【例子】<a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">http://www.opscoder.info/golang_unsafe.html</a></p><p>【煎鱼大佬的博客】<a href="https://segmentfault.com/a/1190000017389782" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017389782</a></p><p>【go语言圣经】<a href="https://www.kancloud.cn/wizardforcel/gopl-zh/106477" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/gopl-zh/106477</a></p><p>【pointer and system calls】<a href="https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/</a></p><p>【pointer and uintptr】<a href="https://my.oschina.net/xinxingegeya/blog/729673" target="_blank" rel="noopener">https://my.oschina.net/xinxingegeya/blog/729673</a></p><p>【unsafe.pointer】<a href="https://go101.org/article/unsafe.html" target="_blank" rel="noopener">https://go101.org/article/unsafe.html</a></p><p>【go 指针类型】<a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">https://go101.org/article/pointer.html</a></p><p>【码洞 快学Go语言 unsafe】<a href="https://juejin.im/post/5c189dce5188256b2e71e79b" target="_blank" rel="noopener">https://juejin.im/post/5c189dce5188256b2e71e79b</a></p><p>【官方文档】<a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">https://golang.org/pkg/unsafe/</a></p><p>【jasper 的小窝】<a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">http://www.opscoder.info/golang_unsafe.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 &lt;c
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之map</title>
    <link href="https://qcrao.com/2019/05/22/dive-into-go-map/"/>
    <id>https://qcrao.com/2019/05/22/dive-into-go-map/</id>
    <published>2019-05-22T01:57:00.000Z</published>
    <updated>2019-11-15T07:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。</p><p>我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。</p><h1 id="什么是-map"><a href="#什么是-map" class="headerlink" title="什么是 map"></a>什么是 map</h1><p>维基百科里这样定义 map：</p><blockquote><p>In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.</p></blockquote><p>简单说明一下：在计算机科学里，被称为相关数组、map、符号表或者字典，是由一组 <code>&lt;key, value&gt;</code> 对组成的抽象数据结构，并且同一个 key 只会出现一次。</p><p>有两个关键点：map 是由 <code>key-value</code> 对组成的；<code>key</code> 只会出现一次。</p><p>和 map 相关的操作主要是：</p><ol><li>增加一个 k-v 对 —— Add or insert；</li><li>删除一个 k-v 对 —— Remove or delete；</li><li>修改某个 k 对应的 v —— Reassign；</li><li>查询某个 k 对应的 v —— Lookup；</li></ol><p>简单说就是最基本的 <code>增删查改</code>。</p><p>map 的设计也被称为 “The dictionary problem”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。最主要的数据结构有两种：<code>哈希查找表（Hash table）</code>、<code>搜索树（Search tree）</code>。</p><p>哈希查找表用一个哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index）。这样，开销主要在哈希函数的计算以及数组的常数访问时间。在很多场景下，哈希查找表的性能很高。</p><p>哈希查找表一般会存在“碰撞”的问题，就是说不同的 key 被哈希到了同一个 bucket。一般有两种应对方法：<code>链表法</code>和<code>开放地址法</code>。<code>链表法</code>将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。<code>开放地址法</code>则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。</p><p>搜索树法一般采用自平衡搜索树，包括：AVL 树，红黑树。面试时经常会被问到，甚至被要求手写红黑树代码，很多时候，面试官自己都写不上来，非常过分。</p><p>自平衡搜索树法的最差搜索效率是 O(logN)，而哈希查找表最差是 O(N)。当然，哈希查找表的平均查找效率是 O(1)，如果哈希函数设计的很好，最坏的情况基本不会出现。还有一点，遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p><h1 id="为什么要用-map"><a href="#为什么要用-map" class="headerlink" title="为什么要用 map"></a>为什么要用 map</h1><p>从 Go 语言官方博客摘录一段话：</p><blockquote><p>One of the most useful data structures in computer science is the hash table. Many hash table implementations exist with varying properties, but in general they offer fast lookups, adds, and deletes. Go provides a built-in map type that implements a hash table.</p></blockquote><p>hash table 是计算机数据结构中一个最重要的设计。大部分 hash table 都实现了快速查找、添加、删除的功能。Go 语言内置的 map 实现了上述所有功能。</p><p>很难想象写一个程序不使用 map，以至于在回答为什么要用 map 这个问题上犯了难。</p><p>所以，到底为什么要用 map 呢？因为它太强大了，各种增删查改的操作效率非常高。</p><h1 id="map-的底层如何实现"><a href="#map-的底层如何实现" class="headerlink" title="map 的底层如何实现"></a>map 的底层如何实现</h1><p>首先声明我用的 Go 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.9.2 darwin/amd64</span><br></pre></td></tr></table></figure><p>前面说了 map 实现的几种方案，Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</p><p>接下来我们要探索 map 的核心原理，一窥它的内部结构。</p><h2 id="map-内存模型"><a href="#map-内存模型" class="headerlink" title="map 内存模型"></a>map 内存模型</h2><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">count     <span class="keyword">int</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">B         <span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">noverflow <span class="keyword">uint16</span></span><br><span class="line"><span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">hash0     <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line"><span class="comment">// 扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line"><span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">nevacuate  <span class="keyword">uintptr</span></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下，<code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value，后面会再讲。</p><p>buckets 是一个指针，最终它指向的是一个结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p>来一个整体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png" alt="hashmap bmap"></p><p>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// overflow[0] contains overflow buckets for hmap.buckets.</span></span><br><span class="line"><span class="comment">// overflow[1] contains overflow buckets for hmap.oldbuckets.</span></span><br><span class="line">overflow [<span class="number">2</span>]*[]*bmap</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket</span></span><br><span class="line">nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><p><img src="https://user-images.githubusercontent.com/7698088/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e.png" alt="bmap struct"></p><p>上图就是 bucket 的内存模型，<code>HOB Hash</code> 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><p>例如，有这样一个类型的 map：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int8</span></span><br></pre></td></tr></table></figure><p>如果按照 <code>key/value/key/value/...</code> 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 padding。</p><p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 <code>overflow</code> 指针连接起来。</p><h2 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h2><p>从语法层面上来说，创建 map 很简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ageMp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 指定 map 长度</span></span><br><span class="line">ageMp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ageMp 为 nil，不能向其添加元素，会直接panic</span></span><br><span class="line"><span class="keyword">var</span> ageMp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line"><span class="comment">// 省略各种条件检查...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个 B，使得 map 的装载因子在正常范围内</span></span><br><span class="line">B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> ; overLoadFactor(hint, B); B++ &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 hash table</span></span><br><span class="line"><span class="comment">// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配</span></span><br><span class="line"><span class="comment">// 如果长度比较大，分配内存会花费长一点</span></span><br><span class="line">buckets := bucket</span><br><span class="line"><span class="keyword">var</span> extra *mapextra</span><br><span class="line"><span class="keyword">if</span> B != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">buckets, nextOverflow = makeBucketArray(t, B)</span><br><span class="line"><span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 hamp</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h = (*hmap)(newobject(t.hmap))</span><br><span class="line">&#125;</span><br><span class="line">h.count = <span class="number">0</span></span><br><span class="line">h.B = B</span><br><span class="line">h.extra = extra</span><br><span class="line">h.flags = <span class="number">0</span></span><br><span class="line">h.hash0 = fastrand()</span><br><span class="line">h.buckets = buckets</span><br><span class="line">h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">h.nevacuate = <span class="number">0</span></span><br><span class="line">h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个函数返回的结果：<code>*hmap</code>，它是一个指针，而我们之前讲过的 <code>makeslice</code> 函数返回的是 <code>Slice</code> 结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span></span><br></pre></td></tr></table></figure><p>回顾一下 slice 的结构体定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体内部包含底层的数据指针。</p><p>makemap 和 makeslice 的区别，带来一个不同点：当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会（之前讲 slice 的文章里有讲过）。</p><p>主要原因：一个是指针（<code>*hmap</code>），一个是结构体（<code>slice</code>）。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。<code>*hmap</code>指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 <code>alginit()</code> 中完成，位于路径：<code>src/runtime/alg.go</code> 下。</p><blockquote><p>hash 函数，有加密型和非加密型。<br>加密型的一般用于加密数据、数字摘要等，典型代表就是 md5、sha1、sha256、aes256 这种；<br>非加密型的一般就是查找。在 map 的应用场景中，用的是查找。<br>选择 hash 函数主要考察的是两点：性能、碰撞概率。</p></blockquote><p>之前我们讲过，表示类型的结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="keyword">uintptr</span></span><br><span class="line">ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">hash       <span class="keyword">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="keyword">uint8</span></span><br><span class="line">fieldalign <span class="keyword">uint8</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">alg        *typeAlg</span><br><span class="line">gcdata    *<span class="keyword">byte</span></span><br><span class="line">str       nameOff</span><br><span class="line">ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>alg</code> 字段就和哈希相关，它是指向如下结构体的指针：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/alg.go</span></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// (ptr to object, seed) -&gt; hash</span></span><br><span class="line">hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">// <span class="params">(ptr to object A, ptr to object B)</span> -&gt; ==?</span></span><br><span class="line"><span class="function"><span class="title">equal</span> <span class="title">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>typeAlg 包含两个函数，hash 函数计算类型的哈希值，而 equal 函数则计算两个类型是否“哈希相等”。</p><p>对于 string 类型，它的 hash、equal 函数如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strhash</span><span class="params">(a unsafe.Pointer, h <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">x := (*stringStruct)(a)</span><br><span class="line"><span class="keyword">return</span> memhash(x.str, h, <span class="keyword">uintptr</span>(x.<span class="built_in">len</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strequal</span><span class="params">(p, q unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(p) == *(*<span class="keyword">string</span>)(q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 key 的类型，_type 结构体的 alg 字段会被设置对应类型的 hash 和 equal 函数。</p><h2 id="key-定位过程"><a href="#key-定位过程" class="headerlink" title="key 定位过程"></a>key 定位过程</h2><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</span><br></pre></td></tr></table></figure><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p><p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><p>这里参考曹大 github 博客里的一张图，原图是 ascii 图，geek 味十足，可以从参考资料找到曹大的博客，推荐大家去看看。</p><p><img src="https://user-images.githubusercontent.com/7698088/57577721-faf57580-74af-11e9-8826-aacdb34a1d2b.png" alt="mapacess"></p><p>上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 <code>00110</code>，找到对应的 6 号 bucket，使用高 8 位 <code>10010111</code>，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><p>我们来看下源码吧，哈哈！通过汇编语言可以看到，查找某个 key 的底层函数是 <code>mapacess</code> 系列函数，函数的作用类似，区别在下一节会讲到。这里我们直接看 <code>mapacess1</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 h 什么都没有，返回零值</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写和读冲突</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"concurrent map read and map write"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型 key 使用的 hash 算法在编译期确定</span></span><br><span class="line">alg := t.key.alg</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希值，并且加入 hash0 引入随机性</span></span><br><span class="line">hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line"><span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line"><span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">m := <span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b 就是 bucket 的地址</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldbuckets 不为 nil，说明发生了扩容</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是同 size 扩容（看后面扩容的内容）</span></span><br><span class="line">    <span class="comment">// 对应条件 1 的解决方案</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 oldb 没有搬迁到新的 bucket</span></span><br><span class="line"><span class="comment">// 那就在老的 bucket 中寻找</span></span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出高 8 位的 hash</span></span><br><span class="line"><span class="comment">// 相当于右移 56 位，只取高8位</span></span><br><span class="line">top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个 minTopHash</span></span><br><span class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">top += minTopHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 8 个 bucket</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">    <span class="comment">// tophash 不匹配，继续</span></span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tophash 匹配，定位到 key 的位置</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"><span class="comment">// key 是指针</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">    <span class="comment">// 解引用</span></span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 key 相等</span></span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">    <span class="comment">// 定位到 value 的位置</span></span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="comment">// value 解引用</span></span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket 找完（还没找到），继续到 overflow bucket 里找</span></span><br><span class="line">b = b.overflow(t)</span><br><span class="line"><span class="comment">// overflow bucket 也找完了，说明没有目标 key</span></span><br><span class="line"><span class="comment">// 返回零值</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回 h[key] 的指针，如果 h 中没有此 key，那就会返回一个 key 相应类型的零值，不会返回 nil。</p><p>代码整体比较直接，没什么难懂的地方。跟着上面的注释一步步理解就好了。</p><p>这里，说一下定位 key 和 value 的方法以及整个循环的写法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 定位公式</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 定位公式</span></span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br></pre></td></tr></table></figure><p>b 是 bmap 的地址，这里 bmap 还是源码里定义的结构体，只包含一个 tophash 数组，经编译器扩充之后的结构体才包含 key，value，overflow 这些字段。dataOffset 是 key 相对于 bmap 起始地址的偏移：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span> &#123;</span><br><span class="line">b bmap</span><br><span class="line">v <span class="keyword">int64</span></span><br><span class="line">&#125;&#123;&#125;.v)</span><br></pre></td></tr></table></figure><p>因此 bucket 里 key 的起始地址就是 unsafe.Pointer(b)+dataOffset。第 i 个 key 的地址就要在此基础上跨过 i 个 key 的大小；而我们又知道，value 的地址是在所有 key 之后，因此第 i 个 value 的地址还需要加上所有 key 的偏移。理解了这些，上面 key 和 value 的定位公式就很好理解了。</p><p>再说整个大循环的写法，最外层是一个无限循环，通过 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = b.overflow(t)</span><br></pre></td></tr></table></figure><p>遍历所有的 bucket，这相当于是一个 bucket 链表。</p><p>当定位到一个具体的 bucket 时，里层循环就是遍历这个 bucket 里所有的 cell，或者说所有的槽位，也就是 bucketCnt=8 个槽位。整个循环过程：</p><p><img src="https://user-images.githubusercontent.com/7698088/57581783-fe5c2180-74ee-11e9-99c9-5a226216e1af.png" alt="mapacess loop"></p><p>再说一下 minTopHash，当一个 cell 的 tophash 值小于 minTopHash 时，标志这个 cell 的迁移状态。因为这个状态值是放在 tophash 数组里，为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。</p><p>下面的这几种状态就表征了 bucket 的情况：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空的 cell，也是初始时 bucket 的状态</span></span><br><span class="line">empty          = <span class="number">0</span></span><br><span class="line"><span class="comment">// 空的 cell，表示 cell 已经被迁移到新的 bucket</span></span><br><span class="line">evacuatedEmpty = <span class="number">1</span></span><br><span class="line"><span class="comment">// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，</span></span><br><span class="line"><span class="comment">// 后面扩容部分会再讲到。</span></span><br><span class="line">evacuatedX     = <span class="number">2</span></span><br><span class="line"><span class="comment">// 同上，key 在后半部分</span></span><br><span class="line">evacuatedY     = <span class="number">3</span></span><br><span class="line"><span class="comment">// tophash 的最小正常值</span></span><br><span class="line">minTopHash     = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>源码里判断这个 bucket 是否已经搬迁完毕，用到的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">h := b.tophash[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> h &gt; empty &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只取了 tophash 数组的第一个值，判断它是否在 0-4 之间。对比上面的常量，当 top hash 是 <code>evacuatedEmpty</code>、<code>evacuatedX</code>、<code>evacuatedY</code> 这三个值之一，说明此 bucket 中的 key 全部被搬迁到了新 bucket。</p><h2 id="map-的两种-get-操作"><a href="#map-的两种-get-操作" class="headerlink" title="map 的两种 get 操作"></a>map 的两种 get 操作</h2><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ageMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ageMap[<span class="string">"qcrao"</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带 comma 用法</span></span><br><span class="line">age1 := ageMap[<span class="string">"stefno"</span>]</span><br><span class="line">fmt.Println(age1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带 comma 用法</span></span><br><span class="line">age2, ok := ageMap[<span class="string">"stefno"</span>]</span><br><span class="line">fmt.Println(age2, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0 false</span><br></pre></td></tr></table></figure><p>以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/hashmap.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure><p>源码里，函数命名不拘小节，直接带上后缀 1，2，完全不理会《代码大全》里的那一套命名的做法。从上面两个函数的声明也可以看出差别了，<code>mapaccess2</code> 函数返回值多了一个 bool 型变量，两者的代码也是完全一样的，只是在返回值后面多加了一个 false 或者 true。</p><p>另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：</p><table><thead><tr><th>key 类型</th><th>查找</th></tr></thead><tbody><tr><td>uint32</td><td>mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td></tr><tr><td>uint32</td><td>mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)</td></tr><tr><td>uint64</td><td>mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td></tr><tr><td>uint64</td><td>mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)</td></tr><tr><td>string</td><td>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td></tr><tr><td>string</td><td>mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)</td></tr></tbody></table><p>这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。</p><p>上面这些函数都是在文件 <code>src/runtime/hashmap_fast.go</code> 里。</p><h2 id="如何进行扩容"><a href="#如何进行扩容" class="headerlink" title="如何进行扩容"></a>如何进行扩容</h2><p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 <code>O(1)</code> 的效率，但这样空间消耗太大，用空间换时间的代价太高。</p><p>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。</p><p>当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。</p><p>因此，需要有一个指标来衡量前面描述的情况，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadFactor := count / (<span class="number">2</span>^B)</span><br></pre></td></tr></table></figure><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ol><p>通过汇编语言可以找到赋值操作对应源码中的函数是 <code>mapassign</code>，对应扩容条件的源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/hashmap.go/mapassign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发扩容时机</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(<span class="keyword">int64</span>(h.count), h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载因子超过 6.5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int64</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt;= bucketCnt &amp;&amp; <span class="keyword">float32</span>(count) &gt;= loadFactor*<span class="keyword">float32</span>((<span class="keyword">uint64</span>(<span class="number">1</span>)&lt;&lt;B))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow buckets 太多</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> B &lt; <span class="number">16</span> &#123;</span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="number">1</span>&lt;&lt;<span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：</p><p>第 1 点：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p><p>第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p><p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p><p>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。</p><p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p><p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p><p>对于条件 2 的解决方案，曹大的博客里还提出了一个极端的情况：如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。</p><p>再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><p>我们先看 <code>hashGrow()</code> 函数所做的工作，再来看具体的搬迁 buckets 是如何进行的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line"><span class="comment">// B+1 相当于是原来 2 倍的空间</span></span><br><span class="line">bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应条件 2</span></span><br><span class="line"><span class="keyword">if</span> !overLoadFactor(<span class="keyword">int64</span>(h.count), h.B) &#123;</span><br><span class="line"><span class="comment">// 进行等量的内存扩容，所以 B 不变</span></span><br><span class="line">bigger = <span class="number">0</span></span><br><span class="line">h.flags |= sameSizeGrow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将老 buckets 挂到 buckets 上</span></span><br><span class="line">oldbuckets := h.buckets</span><br><span class="line"><span class="comment">// 申请新的 buckets 空间</span></span><br><span class="line">newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)</span><br><span class="line"></span><br><span class="line">flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">flags |= oldIterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交 grow 的动作</span></span><br><span class="line">h.B += bigger</span><br><span class="line">h.flags = flags</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line"><span class="comment">// 搬迁进度为 0</span></span><br><span class="line">h.nevacuate = <span class="number">0</span></span><br><span class="line"><span class="comment">// overflow buckets 数为 0</span></span><br><span class="line">h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是申请到了新的 buckets 空间，把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。</p><p>值得一说的是对 <code>h.flags</code> 的处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">flags |= oldIterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里得先说下运算符：&amp;^。这叫<code>按位置 0</code>运算符。例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">01010011</span></span><br><span class="line">y = <span class="number">01010100</span></span><br><span class="line">z = x &amp;^ y = <span class="number">00000011</span></span><br></pre></td></tr></table></figure><p>如果 y bit 位为 1，那么结果 z 对应 bit 位就为 0，否则 z 对应 bit 位就和 x 对应 bit 位的值相同。</p><p>所以上面那段对 flags 一顿操作的代码的意思是：先把 h.flags 中 iterator 和 oldIterator 对应位清 0，然后如果发现 iterator 位为 1，那就把它转接到 oldIterator 位，使得 oldIterator 标志位变成 1。潜台词就是：buckets 现在挂到了 oldBuckets 名下了，对应的标志位也转接过去吧。</p><p>几个标志位如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能有迭代器使用 buckets</span></span><br><span class="line">iterator     = <span class="number">1</span></span><br><span class="line"><span class="comment">// 可能有迭代器使用 oldbuckets</span></span><br><span class="line">oldIterator  = <span class="number">2</span></span><br><span class="line"><span class="comment">// 有协程正在向 map 中写入 key</span></span><br><span class="line">hashWriting  = <span class="number">4</span></span><br><span class="line"><span class="comment">// 等量扩容（对应条件 2）</span></span><br><span class="line">sameSizeGrow = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>再来看看真正执行搬迁工作的 growWork() 函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 确认搬迁老的 bucket 对应正在使用的 bucket</span></span><br><span class="line">evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再搬迁一个 bucket，以加快搬迁进程</span></span><br><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">evacuate(t, h, h.nevacuate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h.growing() 函数非常简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">growing</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>oldbuckets</code> 不为空，说明还没有搬迁完毕，还得继续搬。</p><p><code>bucket&amp;h.oldbucketmask()</code> 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。<code>oldbucketmask()</code> 函数返回扩容前的 map 的 bucketmask。</p><p>所谓的 bucketmask，作用就是将 key 计算出来的哈希值与 bucketmask 相与，得到的结果就是 key 应该落入的桶。比如 B = 5，那么 bucketmask 的低 5 位是 <code>11111</code>，其余位是 <code>0</code>，hash 值与其相与的意思是，只有 hash 值的低 5 位决策 key 到底落入哪个 bucket。</p><p>接下来，我们集中所有的精力在搬迁的关键函数 evacuate。源码贴在下面，不要紧张，我会加上大面积的注释，通过注释绝对是能看懂的。之后，我会再对搬迁过程作详细说明。</p><p>源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 定位老的 bucket 地址</span></span><br><span class="line">b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">// 结果是 2^B，如 B = 5，结果为32</span></span><br><span class="line">newbit := h.noldbuckets()</span><br><span class="line"><span class="comment">// key 的哈希函数</span></span><br><span class="line">alg := t.key.alg</span><br><span class="line"><span class="comment">// 如果 b 没有被搬迁过</span></span><br><span class="line"><span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// 表示bucket 移动的目标地址</span></span><br><span class="line">x, y   *bmap</span><br><span class="line"><span class="comment">// 指向 x,y 中的 key/val</span></span><br><span class="line">xi, yi <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 指向 x，y 中的 key</span></span><br><span class="line">xk, yk unsafe.Pointer</span><br><span class="line"><span class="comment">// 指向 x，y 中的 value</span></span><br><span class="line">xv, yv unsafe.Pointer</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认是等 size 扩容，前后 bucket 序号不变</span></span><br><span class="line"><span class="comment">// 使用 x 来进行搬迁</span></span><br><span class="line">x = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">xi = <span class="number">0</span></span><br><span class="line">xk = add(unsafe.Pointer(x), dataOffset)</span><br><span class="line">xv = add(xk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))、</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是等 size 扩容，前后 bucket 序号有变</span></span><br><span class="line"><span class="comment">// 使用 y 来进行搬迁</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// y 代表的 bucket 序号增加了 2^B</span></span><br><span class="line">y = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">yi = <span class="number">0</span></span><br><span class="line">yk = add(unsafe.Pointer(y), dataOffset)</span><br><span class="line">yv = add(yk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的 bucket，包括 overflow buckets</span></span><br><span class="line"><span class="comment">// b 是老的 bucket 地址</span></span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 bucket 中的所有 cell</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line"><span class="comment">// 当前 cell 的 top hash 值</span></span><br><span class="line">top := b.tophash[i]</span><br><span class="line"><span class="comment">// 如果 cell 为空，即没有 key</span></span><br><span class="line"><span class="keyword">if</span> top == empty &#123;</span><br><span class="line"><span class="comment">// 那就标志它被"搬迁"过</span></span><br><span class="line">b.tophash[i] = evacuatedEmpty</span><br><span class="line"><span class="comment">// 继续下个 cell</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常不会出现这种情况</span></span><br><span class="line"><span class="comment">// 未被搬迁的 cell 只可能是 empty 或是</span></span><br><span class="line"><span class="comment">// 正常的 top hash（大于 minTopHash）</span></span><br><span class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">throw(<span class="string">"bad map state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k2 := k</span><br><span class="line"><span class="comment">// 如果 key 是指针，则解引用</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用 X，等量扩容</span></span><br><span class="line">useX := <span class="literal">true</span></span><br><span class="line"><span class="comment">// 如果不是等量扩容</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// 计算 hash 值，和 key 第一次写入时一样</span></span><br><span class="line">hash := alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有协程正在遍历 map</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果出现 相同的 key 值，算出来的 hash 值不同</span></span><br><span class="line"><span class="keyword">if</span> !t.reflexivekey &amp;&amp; !alg.equal(k2, k2) &#123;</span><br><span class="line"><span class="comment">// 只有在 float 变量的 NaN() 情况下会出现</span></span><br><span class="line"><span class="keyword">if</span> top&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 第 B 位置 1</span></span><br><span class="line">hash |= newbit</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第 B 位置 0</span></span><br><span class="line">hash &amp;^= newbit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取高 8 位作为 top hash 值</span></span><br><span class="line">top = <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">top += minTopHash</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取决于新哈希值的 oldB+1 位是 0 还是 1</span></span><br><span class="line"><span class="comment">// 详细看后面的文章</span></span><br><span class="line">useX = hash&amp;newbit == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 key 搬到 X 部分</span></span><br><span class="line"><span class="keyword">if</span> useX &#123;</span><br><span class="line"><span class="comment">// 标志老的 cell 的 top hash 值，表示搬移到 X 部分</span></span><br><span class="line">b.tophash[i] = evacuatedX</span><br><span class="line"><span class="comment">// 如果 xi 等于 8，说明要溢出了</span></span><br><span class="line"><span class="keyword">if</span> xi == bucketCnt &#123;</span><br><span class="line"><span class="comment">// 新建一个 bucket</span></span><br><span class="line">newx := h.newoverflow(t, x)</span><br><span class="line">x = newx</span><br><span class="line"><span class="comment">// xi 从 0 开始计数</span></span><br><span class="line">xi = <span class="number">0</span></span><br><span class="line"><span class="comment">// xk 表示 key 要移动到的位置</span></span><br><span class="line">xk = add(unsafe.Pointer(x), dataOffset)</span><br><span class="line"><span class="comment">// xv 表示 value 要移动到的位置</span></span><br><span class="line">xv = add(xk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 top hash 值</span></span><br><span class="line">x.tophash[xi] = top</span><br><span class="line"><span class="comment">// key 是指针</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line"><span class="comment">// 将原 key（是指针）复制到新位置</span></span><br><span class="line">*(*unsafe.Pointer)(xk) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 将原 key（是值）复制到新位置</span></span><br><span class="line">typedmemmove(t.key, xk, k) <span class="comment">// copy value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 是指针，操作同 key</span></span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">*(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemmove(t.elem, xv, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到下一个 cell</span></span><br><span class="line">xi++</span><br><span class="line">xk = add(xk, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">xv = add(xv, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// key 搬到 Y 部分，操作同 X 部分</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">// 省略了这部分，操作和 X 部分相同</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &#123;</span><br><span class="line">b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态</span></span><br><span class="line"><span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">memclrHasPointers(add(unsafe.Pointer(b), dataOffset), <span class="keyword">uintptr</span>(t.bucketsize)-dataOffset)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memclrNoHeapPointers(add(unsafe.Pointer(b), dataOffset), <span class="keyword">uintptr</span>(t.bucketsize)-dataOffset)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新搬迁进度</span></span><br><span class="line"><span class="comment">// 如果此次搬迁的 bucket 等于当前进度</span></span><br><span class="line"><span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line"><span class="comment">// 进度加 1</span></span><br><span class="line">h.nevacuate = oldbucket + <span class="number">1</span></span><br><span class="line"><span class="comment">// Experiments suggest that 1024 is overkill by at least an order of magnitude.</span></span><br><span class="line"><span class="comment">// Put it in there as a safeguard anyway, to ensure O(1) behavior.</span></span><br><span class="line"><span class="comment">// 尝试往后看 1024 个 bucket</span></span><br><span class="line">stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line"><span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">stop = newbit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寻找没有搬迁的 bucket</span></span><br><span class="line"><span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">h.nevacuate++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 h.nevacuate 之前的 bucket 都被搬迁完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的 buckets 搬迁完毕</span></span><br><span class="line"><span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line"><span class="comment">// 清除老的 buckets</span></span><br><span class="line">h.oldbuckets = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 清除老的 overflow bucket</span></span><br><span class="line"><span class="comment">// 回忆一下：[0] 表示当前 overflow bucket</span></span><br><span class="line"><span class="comment">// [1] 表示 old overflow bucket</span></span><br><span class="line"><span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">h.extra.overflow[<span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除正在扩容的标志位</span></span><br><span class="line">h.flags &amp;^= sameSizeGrow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evacuate 函数的代码注释非常清晰，对着代码和注释是很容易看懂整个的搬迁过程的，耐心点。</p><p>搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。</p><p>对于条件 2，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p><p>对于条件 1，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 <code>rehash</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/57740474-af7adb80-76ea-11e9-8409-4af0ce1a814a.png" alt="map rehash"></p><p>因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0  还是 1。</p><p>理解了上面 bucket 序号的变化，我们就可以回答另一个问题了：为什么遍历 map 是无序的？</p><p>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p><p>当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。</p><p>多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p><p>再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。</p><p>例如，原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 <code>10</code> 决定它们落在 2 号桶，现在 B 变成 3，所以 <code>010</code>、<code>110</code> 分别落入 2、6 号桶。</p><p><img src="https://user-images.githubusercontent.com/7698088/57818861-74df7480-77b8-11e9-8104-2a58dc006660.png" alt="bucket split"></p><p>理解了这个，后面讲 map 迭代的时候会用到。</p><p>再来讲搬迁函数中的几个关键点：</p><p>evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。bucket 还会链接 overflow bucket，它们同样需要搬迁。因此会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。这样的循环在 map 的源码里到处都是，要理解透了。</p><p>源码里提到 X, Y part，其实就是我们说的如果是扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的 key 可能会分裂落到 2 个桶，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个 Part。很简单，重新计算 cell 中 key 的 hash，并向前“多看”一位，决定落入哪个 Part，这个前面也说得很详细了。</p><p>有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 <code>math.NaN()</code> 的结果，它的含义是 <code>not a number</code>，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</p><p>你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 <code>m[math.NaN()]</code> 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 <code>math.NaN()</code> 作为 key。</p><p>当搬迁碰到 <code>math.NaN()</code> 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</p><p>这是通过 tophash 值与新算出来的哈希值进行运算得到的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> top&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// top hash 最低位为 1</span></span><br><span class="line">    <span class="comment">// 新算出来的 hash 值的 B 位置 1</span></span><br><span class="line">hash |= newbit</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新算出来的 hash 值的 B 位置 0</span></span><br><span class="line">hash &amp;^= newbit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 值的 B 位为 0，则搬迁到 x part</span></span><br><span class="line"><span class="comment">// 当 B = 5时，newbit = 32，二进制低 6 位为 10 0000</span></span><br><span class="line">useX = hash&amp;newbit == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其实这样的 key 我随便搬迁到哪个 bucket 都行，当然，还是要搬迁到上面裂变那张图中的两个 bucket 中去。但这样做是有好处的，在后面讲 map 迭代的时候会再详细解释，暂时知道是这样分配的就行。</p><p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。</p><p>设置 key 在原始 buckets 的 tophash 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的 x part 或是 y part。新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p><p>下面通过图来宏观地看一下扩容前后的变化。</p><p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963483-5b286380-7957-11e9-852a-8296c6c16daa.png" alt="扩容前"></p><p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963519-dc7ff600-7957-11e9-9877-36c3f4bc3526.png" alt="same size 扩容"></p><p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 <code>0-3</code> 称为 x part，<code>4-7</code> 称为 y part。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963651-04705900-795a-11e9-9801-e3dc475d4782.png" alt="2倍扩容"></p><p>注意，上面的两张图忽略了其他 buckets 的搬迁情况，表示所有的 bucket 都搬迁完毕后的情形。实际上，我们知道，搬迁是一个“渐进”的过程，并不会一下子就全部搬迁完毕。所以在搬迁过程中，oldbuckets 指针还会指向原来老的 []bmap，并且已经搬迁完毕的 key 的 tophash 值会是一个状态值，表示 key 的搬迁去向。</p><h2 id="map-的遍历"><a href="#map-的遍历" class="headerlink" title="map 的遍历"></a>map 的遍历</h2><p>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。</p><p>但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。</p><p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。</p><p>我先写一个简单的代码样例，假装不知道遍历过程具体调用的是什么函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ageMp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ageMp[<span class="string">"qcrao"</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ageMp &#123;</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>得到汇编命令。这里就不逐行讲解了，可以去看之前的几篇文章，说得很详细。</p><p>关键的几行汇编代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="number">0x0124</span> <span class="number">00292</span> (test16.<span class="keyword">go</span>:<span class="number">9</span>)      CALL    runtime.mapiterinit(SB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="number">0x01f</span>b <span class="number">00507</span> (test16.<span class="keyword">go</span>:<span class="number">9</span>)      CALL    runtime.mapiternext(SB)</span><br><span class="line"><span class="number">0x0200</span> <span class="number">00512</span> (test16.<span class="keyword">go</span>:<span class="number">9</span>)      MOVQ    <span class="string">""</span>..autotmp_4+<span class="number">160</span>(SP), AX</span><br><span class="line"><span class="number">0x0208</span> <span class="number">00520</span> (test16.<span class="keyword">go</span>:<span class="number">9</span>)      TESTQ   AX, AX</span><br><span class="line"><span class="number">0x020b</span> <span class="number">00523</span> (test16.<span class="keyword">go</span>:<span class="number">9</span>)      JNE     <span class="number">302</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>这样，关于 map 迭代，底层的函数调用关系一目了然。先是调用 <code>mapiterinit</code> 函数初始化迭代器，然后循环调用 <code>mapiternext</code> 函数进行 map 迭代。</p><p><img src="https://user-images.githubusercontent.com/7698088/57976471-ad2ebf00-7a13-11e9-8dd8-d7be54f96440.png" alt="map iter loop"></p><p>迭代器的结构体定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// key 指针</span></span><br><span class="line">key         unsafe.Pointer</span><br><span class="line"><span class="comment">// value 指针</span></span><br><span class="line">value       unsafe.Pointer</span><br><span class="line"><span class="comment">// map 类型，包含如 key size 大小等</span></span><br><span class="line">t           *maptype</span><br><span class="line"><span class="comment">// map header</span></span><br><span class="line">h           *hmap</span><br><span class="line"><span class="comment">// 初始化时指向的 bucket</span></span><br><span class="line">buckets     unsafe.Pointer</span><br><span class="line"><span class="comment">// 当前遍历到的 bmap</span></span><br><span class="line">bptr        *bmap</span><br><span class="line">overflow    [<span class="number">2</span>]*[]*bmap</span><br><span class="line"><span class="comment">// 起始遍历的 bucet 编号</span></span><br><span class="line">startBucket <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// 遍历开始时 cell 的编号（每个 bucket 中有 8 个 cell）</span></span><br><span class="line">offset      <span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// 是否从头遍历了</span></span><br><span class="line">wrapped     <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// B 的大小</span></span><br><span class="line">B           <span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// 指示当前 cell 序号</span></span><br><span class="line">i           <span class="keyword">uint8</span></span><br><span class="line"><span class="comment">// 指向当前的 bucket</span></span><br><span class="line">bucket      <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// 因为扩容，需要检查的 bucket</span></span><br><span class="line">checkBucket <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapiterinit</code> 就是对 hiter 结构体里的字段进行初始化赋值操作。</p><p>前面已经提到过，即使是对一个写死的 map 进行遍历，每次出来的结果也是无序的。下面我们就可以近距离地观察他们的实现了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成随机数 r</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从哪个 bucket 开始遍历</span></span><br><span class="line">it.startBucket = r &amp; (<span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 从 bucket 的哪个 cell 开始遍历</span></span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>例如，B = 2，那 <code>uintptr(1)&lt;&lt;h.B - 1</code> 结果就是 3，低 8 位为 <code>0000 0011</code>，将 r 与之相与，就可以得到一个 <code>0~3</code> 的 bucket 序号；bucketCnt - 1 等于 7，低 8 位为 <code>0000 0111</code>，将 r 右移 2 位后，与 7 相与，就可以得到一个 <code>0~7</code> 号的 cell。</p><p>于是，在 <code>mapiternext</code> 函数中就会从 it.startBucket 的 it.offset 号的 cell 开始遍历，取出其中的 key 和 value，直到又回到起点 bucket，完成遍历过程。</p><p>源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。</p><p>假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，<code>1 号</code>裂变成 <code>1 号</code>和 <code>3 号</code>；<code>0 号</code> bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p><p><img src="https://user-images.githubusercontent.com/7698088/57978113-f8a79400-7a38-11e9-8e27-3f3ba4fa557f.png" alt="map origin"></p><p>这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980268-a4fa7200-7a5b-11e9-9ad1-fb2b64fe3159.png" alt="map init"></p><p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2。</p><p>因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。判断方法就是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">h := b.tophash[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> h &gt; empty &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 b.tophash[0] 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">empty = <span class="number">0</span></span><br><span class="line">evacuatedEmpty = <span class="number">1</span></span><br><span class="line">evacuatedX = <span class="number">2</span></span><br><span class="line">evacuatedY = <span class="number">3</span></span><br><span class="line">minTopHash = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。</p><p>依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时我们的遍历结果仅有一个元素：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980302-56010c80-7a5c-11e9-8263-c11ddcec2ecc.png" alt="iter res"></p><p>由于返回的 key 不为空，所以会继续调用 mapiternext 函数。</p><p>继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。</p><p>遍历结果集也因此壮大：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980349-2d2d4700-7a5d-11e9-819a-a59964f70a7c.png" alt="iter res"></p><p>新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。那是不是把老 0 号 bucket 中的所有 key 都取出来呢？</p><p>并没有这么简单，回忆一下，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 <code>*bucket</code> 指针，也就是所谓的新 buckets）。所以，我们只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key。</p><p>因此，<code>lowbits == 00</code> 的将进入遍历结果集：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980449-6fa35380-7a5e-11e9-9dbf-86332ea0e215.png" alt="iter res"></p><p>和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。结果集变成：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980487-e8a2ab00-7a5e-11e9-8e47-050437a099fc.png" alt="iter res"></p><p>继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 <code>lowbit == 10</code> 的那些 key。</p><p>这样，遍历结果集变成：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980574-ae85d900-7a5f-11e9-8050-ae314a90ee05.png" alt="iter res"></p><p>最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。</p><p>顺便说一下，如果碰到 key 是 <code>math.NaN()</code> 这种的，处理方式类似。核心还是要看它被分裂后具体落入哪个 bucket。只不过只用看它 top hash 的最低位。如果 top hash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。据此决定是否取出 key，放到遍历结果集里。</p><p>map 遍历的核心在于理解 2 倍扩容时，老 bucket 会分裂到 2 个新 bucket 中去。而遍历操作，会按照新 bucket 的序号顺序进行，碰到老 bucket 未搬迁的情况时，要在老 bucket 中找到将来要搬迁到新 bucket 来的 key。</p><h2 id="map-的赋值"><a href="#map-的赋值" class="headerlink" title="map 的赋值"></a>map 的赋值</h2><p>通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 <code>mapassign</code> 函数。</p><p>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</p><p>mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。</p><table><thead><tr><th>key 类型</th><th>插入</th></tr></thead><tbody><tr><td>uint32</td><td>mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td></tr><tr><td>uint64</td><td>mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td></tr><tr><td>string</td><td>mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td></tr></tbody></table><p>我们只用研究最一般的赋值函数 <code>mapassign</code>。</p><p>整体来看，流程非常得简单：对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p><p>源码大体和之前讲的类似，核心还是一个双层循环，外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell。限于篇幅，这部分代码的注释我也不展示了，有兴趣的可以去看，保证理解了这篇文章内容后，能够看懂。</p><p>我这里会针对这个过程提几点重要的。</p><p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p><p>通过前文我们知道扩容是渐进式的，如果 map 处在扩容的过程中，那么当 key 定位到了某个 bucket 后，需要确保这个 bucket 对应的老 bucket 完成了迁移过程。即老 bucket 里的 key 都要迁移到新的 bucket 中来（分裂到 2 个新 bucket），才能在新的 bucket 中进行插入或者更新的操作。</p><p>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。</p><p>现在到了定位 key 应该放置的位置了，所谓找准自己的位置很重要。准备两个指针，一个（<code>inserti</code>）指向 key 的 hash 值在 tophash 数组所处的位置，另一个(<code>insertk</code>)指向 cell 的位置（也就是 key 最终放置的地址），当然，对应 value 的位置就很容易定位出来了。这三者实际上都是关联的，在 tophash 数组中的索引位置决定了 key 在整个 bucket 中的位置（共 8 个 key），而 value 的位置需要“跨过” 8 个 key 的长度。</p><p>在循环的过程中，inserti 和 insertk 分别指向第一个找到的空闲的 cell。如果之后在 map 没有找到 key 的存在，也就是说原来 map 中没有此 key，这意味着插入新 key。那最终 key 的安置地址就是第一次发现的“空位”（tophash 是 empty）。</p><p>如果这个 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，发现 inserti 和 insertk 都是空，这时候需要在 bucket 后面挂上 overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。</p><p>在正式安置 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</p><p>这之后，整个之前的查找定位 key 的过程，还得再重新走一次。因为扩容之后，key 的分布都发生了变化。</p><p>最后，会更新 map 相关的值，如果是插入新 key，map 的元素数量字段 count 值会加 1；在函数之初设置的 <code>hashWriting</code> 写标志出会清零。</p><p>另外，有一个重要的点要说一下。前面说的找到 key 的位置，进行赋值操作，实际上并不准确。我们看 <code>mapassign</code> 函数的原型就知道，函数并没有传入 value 值，所以赋值操作是什么时候执行的呢？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br></pre></td></tr></table></figure><p>答案还得从汇编语言中寻找。我直接揭晓答案，有兴趣可以私下去研究一下。<code>mapassign</code> 函数返回的指针就是指向的 key 所对应的 value 值位置，有了地址，就很好操作赋值了。</p><h2 id="map-的删除"><a href="#map-的删除" class="headerlink" title="map 的删除"></a>map 的删除</h2><p>写操作底层的执行函数是 <code>mapdelete</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure><p>根据 key 类型的不同，删除操作会被优化成更具体的函数：</p><table><thead><tr><th>key 类型</th><th>删除</th></tr></thead><tbody><tr><td>uint32</td><td>mapdelete_fast32(t *maptype, h *hmap, key uint32)</td></tr><tr><td>uint64</td><td>mapdelete_fast64(t *maptype, h *hmap, key uint64)</td></tr><tr><td>string</td><td>mapdelete_faststr(t *maptype, h *hmap, ky string)</td></tr></tbody></table><p>当然，我们只关心 <code>mapdelete</code> 函数。它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作。</p><p>计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。</p><p>删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。</p><p>找到对应位置后，对 key 或者 value 进行“清零”操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 key 清零</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemclr(t.key, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 value 清零</span></span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">*(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemclr(t.elem, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将 count 值减 1，将对应位置的 tophash 值置成 <code>Empty</code>。</p><p>这块源码同样比较简单，感兴起直接去看代码。</p><h1 id="map-进阶"><a href="#map-进阶" class="headerlink" title="map 进阶"></a>map 进阶</h1><h2 id="可以边遍历边删除吗"><a href="#可以边遍历边删除吗" class="headerlink" title="可以边遍历边删除吗"></a>可以边遍历边删除吗</h2><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p><p>一般而言，这可以通过读写锁来解决：<code>sync.RWMutex</code>。</p><p>读之前调用 <code>RLock()</code> 函数，读完之后调用 <code>RUnlock()</code> 函数解锁；写之前调用 <code>Lock()</code> 函数，写完之后，调用 <code>Unlock()</code> 解锁。</p><p>另外，<code>sync.Map</code> 是线程安全的 map，也可以使用。它的实现原理，这次先不说了。</p><h2 id="key-可以是-float-型吗？"><a href="#key-可以是-float-型吗？" class="headerlink" title="key 可以是 float 型吗？"></a>key 可以是 float 型吗？</h2><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。</p><p>顺便说一句，任何类型都可以作为 value，包括 map 类型。</p><p>来看个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="number">1.4</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="number">2.4</span>] = <span class="number">2</span></span><br><span class="line">m[math.NaN()] = <span class="number">3</span></span><br><span class="line">m[math.NaN()] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Printf(<span class="string">"[%v, %d] "</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"\nk: %v, v: %d\n"</span>, math.NaN(), m[math.NaN()])</span><br><span class="line">fmt.Printf(<span class="string">"k: %v, v: %d\n"</span>, <span class="number">2.400000000001</span>, m[<span class="number">2.400000000001</span>])</span><br><span class="line">fmt.Printf(<span class="string">"k: %v, v: %d\n"</span>, <span class="number">2.4000000000000000000000001</span>, m[<span class="number">2.4000000000000000000000001</span>])</span><br><span class="line"></span><br><span class="line">fmt.Println(math.NaN() == math.NaN())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2.4, 2] [NaN, 3] [NaN, 3] [1.4, 1] </span><br><span class="line">k: NaN, v: 0</span><br><span class="line">k: 2.400000000001, v: 0</span><br><span class="line">k: 2.4, v: 2</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：1.4， 2.4， NAN，NAN。</p><p>打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。</p><p>接着，我们查询了几个 key，发现 NAN 不存在，2.400000000001 也不存在，而 2.4000000000000000000000001 却存在。</p><p>有点诡异，不是吗？</p><p>接着，我通过汇编发现了如下的事实：</p><p>当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。</p><p>具体是通过 <code>Float64frombits</code> 函数完成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Float64frombits returns the floating point number corresponding</span></span><br><span class="line"><span class="comment">// the IEEE 754 binary representation b.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64frombits</span><span class="params">(b <span class="keyword">uint64</span>)</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> *(*<span class="keyword">float64</span>)(unsafe.Pointer(&amp;b)) &#125;</span><br></pre></td></tr></table></figure><p>也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00bd 00189 (test18.go:9)      LEAQ    &quot;&quot;.statictmp_0(SB), DX</span><br><span class="line">0x00c4 00196 (test18.go:9)      MOVQ    DX, 16(SP)</span><br><span class="line">0x00c9 00201 (test18.go:9)      PCDATA  $0, $2</span><br><span class="line">0x00c9 00201 (test18.go:9)      CALL    runtime.mapassign(SB)</span><br></pre></td></tr></table></figure><p><code>&quot;&quot;.statictmp_0(SB)</code> 变量是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.statictmp_0 SRODATA size=8</span><br><span class="line">        0x0000 33 33 33 33 33 33 03 40</span><br><span class="line">&quot;&quot;.statictmp_1 SRODATA size=8</span><br><span class="line">        0x0000 ff 3b 33 33 33 33 03 40</span><br><span class="line">&quot;&quot;.statictmp_2 SRODATA size=8</span><br><span class="line">        0x0000 33 33 33 33 33 33 03 40</span><br></pre></td></tr></table></figure><p>我们再来输出点东西：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span>)</span><br><span class="line">m[<span class="number">2.4</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(math.Float64bits(<span class="number">2.4</span>))</span><br><span class="line">fmt.Println(math.Float64bits(<span class="number">2.400000000001</span>))</span><br><span class="line">fmt.Println(math.Float64bits(<span class="number">2.4000000000000000000000001</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4612586738352864255</span><br><span class="line">4612586738352862003</span><br><span class="line">4612586738352862003</span><br></pre></td></tr></table></figure><p>转成十六进制为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x4003333333333333</span><br><span class="line">0x4003333333333BFF</span><br><span class="line">0x4003333333333333</span><br></pre></td></tr></table></figure><p>和前面的 <code>&quot;&quot;.statictmp_0</code> 比较一下，很清晰了吧。<code>2.4</code> 和 <code>2.4000000000000000000000001</code> 经过 <code>math.Float64bits()</code> 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。</p><p>再来看一下 NAN（not a number）：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NaN returns an IEEE 754 ``not-a-number'' value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NaN</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> Float64frombits(uvnan) &#125;</span><br></pre></td></tr></table></figure><p>uvan 的定义为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvnan    = <span class="number">0x7FF8000000000001</span></span><br></pre></td></tr></table></figure><p>NAN() 直接调用 <code>Float64frombits</code>，传入写死的 const 型变量 <code>0x7FF8000000000001</code>，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？</p><p>这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f64hash</span><span class="params">(p unsafe.Pointer, h <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">f := *(*<span class="keyword">float64</span>)(p)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> f == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> c1 * (c0 ^ h) <span class="comment">// +0, -0</span></span><br><span class="line"><span class="keyword">case</span> f != f:</span><br><span class="line"><span class="keyword">return</span> c1 * (c0 ^ h ^ <span class="keyword">uintptr</span>(fastrand())) <span class="comment">// any kind of NaN</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> memhash(p, h, <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个 case，<code>f != f</code> 就是针对 <code>NAN</code>，这里会再加一个随机数。</p><p>这样，所有的谜题都解开了。</p><p>由于 NAN 的特性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAN != NAN</span><br><span class="line">hash(NAN) != hash(NAN)</span><br></pre></td></tr></table></figure><p>因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。</p><p>最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在写作本文时，有些问题看遍了中文世界的博客都没能找到解答。当然，源码可以解答任何问题。但是，你不能一下子跳进源码的细节，你得先有一个整体的认识才好。</p><p>所以，我开始搜索英文相关讲源码的文章，没有太多这方面的。但是我发现了一篇质量很高的文章，放在了参考资料第一条，它带领读者一步步优化，最终实现了从 map 中随机取出一个 key。推荐你去阅读，非常精彩。尤其是你知道了 map 的底层遍历、扩容的具体过程后更是如此。</p><p>总结一下，Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突。</p><p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p><p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。扩容分为等量扩容和 2 倍容量扩容。扩容后，原来一个 bucket 中的 key 一分为二，会被重新分配到两个桶中。</p><p>扩容过程是渐进的，主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素，bucket 搬迁的时机则发生在赋值、删除期间，每次最多搬迁两个 bucket。</p><p>查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置，需要重点理解。一旦理解，关于 map 的源码就可以看懂了。</p><p>最后，如果文章对你有帮助，恳请你帮我分享一下，或者点一下在看，谢谢！</p><p>最后的最后，点击<a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">阅读原文</a>，你可能会参与见证一个从零开始的千星项目。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【english 如何实现随机取一个map的key，非常精彩】<a href="https://lukechampine.com/hackmap.html" target="_blank" rel="noopener">https://lukechampine.com/hackmap.html</a></p><p>【map 的维基百科】<a href="https://en.wikipedia.org/wiki/Associative_array" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Associative_array</a></p><p>【sync.map 源码分析】<a href="https://github.com/Chasiny/Blog/blob/master/blog/go/sync.Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/Chasiny/Blog/blob/master/blog/go/sync.Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md</a></p><p>【各种 map 相关操作的流程图】<a href="https://www.jianshu.com/p/aa0d4808cbb8" target="_blank" rel="noopener">https://www.jianshu.com/p/aa0d4808cbb8</a></p><p>【map 源码分析】<a href="https://www.twblogs.net/a/5bd78d5d2b71777ac86b541f" target="_blank" rel="noopener">https://www.twblogs.net/a/5bd78d5d2b71777ac86b541f</a></p><p>【曹大关于map的文章 不用解释】<a href="https://github.com/cch123/golang-notes/blob/master/map.md" target="_blank" rel="noopener">https://github.com/cch123/golang-notes/blob/master/map.md</a></p><p>【english 有图】<a href="https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html</a></p><p>【english 对比了 java, c++ 的 map 实现】<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics" target="_blank" rel="noopener">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a></p><p>【english 为什么 go map 对竞争敏感】<a href="https://dave.cheney.net/2015/12/07/are-go-maps-sensitive-to-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2015/12/07/are-go-maps-sensitive-to-data-races</a></p><p>【golang blog map】<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="noopener">https://blog.golang.org/go-maps-in-action</a></p><p>【randommap 开源代码】<a href="https://github.com/lukechampine/randmap" target="_blank" rel="noopener">https://github.com/lukechampine/randmap</a></p><p>【图不错】<a href="https://hacpai.com/article/1533916370874" target="_blank" rel="noopener">https://hacpai.com/article/1533916370874</a></p><p>【夜读issue】<a href="https://github.com/developer-learning/reading-go/issues/332" target="_blank" rel="noopener">https://github.com/developer-learning/reading-go/issues/332</a></p><p>【新发现的博客，很有深度】<a href="https://draveness.me/golang-hashmap" target="_blank" rel="noopener">https://draveness.me/golang-hashmap</a></p><p>【扩容过程+图】<a href="https://my.oschina.net/renhc/blog/2208417" target="_blank" rel="noopener">https://my.oschina.net/renhc/blog/2208417</a></p><p>【运算符】<a href="https://juejin.im/post/5c0e572fe51d4522ad6e59d5" target="_blank" rel="noopener">https://juejin.im/post/5c0e572fe51d4522ad6e59d5</a></p><p>【english】<a href="https://www.digitalocean.com/community/tutorials/understanding-maps-in-go" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-maps-in-go</a></p><p>【map 遍历 源码简单阐述】<a href="https://gocn.vip/article/1704" target="_blank" rel="noopener">https://gocn.vip/article/1704</a></p><p>【短文，同时遍历、删除key是可以的】<a href="https://cloud.tencent.com/developer/article/1065474" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1065474</a></p><p>【面向信仰编程，golang range】<a href="https://draveness.me/golang-for-range" target="_blank" rel="noopener">https://draveness.me/golang-for-range</a></p><p>【slice 和 map 作为参数的区别】<a href="https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531" target="_blank" rel="noopener">https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531</a></p><p>【Go官方博客关于 map】<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="noopener">https://blog.golang.org/go-maps-in-action</a></p><p>【Go 语言可比较类型】<a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">https://golang.org/ref/spec#Comparison_operators</a></p><p>【key 类型】<a href="http://lanlingzi.cn/post/technical/2016/0904_go_map/" target="_blank" rel="noopener">http://lanlingzi.cn/post/technical/2016/0904_go_map/</a></p><p>【哈希函数性能比较】<a href="http://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/" target="_blank" rel="noopener">http://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/</a></p><p>【哈希函数选择，C++/Java 对比】<a href="https://studygolang.com/articles/15839" target="_blank" rel="noopener">https://studygolang.com/articles/15839</a></p><p>【slice 和 map 作为函数参数】<a href="https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531" target="_blank" rel="noopener">https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531</a></p><p>【煎鱼大佬博客 map1】<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0.md</a></p><p>【煎鱼大佬博客 map2】<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-24-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%89%A9%E5%AE%B9%E8%BF%81%E7%A7%BB.md" target="_blank" rel="noopener">https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-24-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%89%A9%E5%AE%B9%E8%BF%81%E7%A7%BB.md</a></p><p>【哈希函数的定义】<a href="http://zhangshuai.ren/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">http://zhangshuai.ren/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/</a></p><p>【如何比较两个 map 相等】<a href="https://golangbot.com/maps/" target="_blank" rel="noopener">https://golangbot.com/maps/</a></p><p>【NAN hash】<a href="https://research.swtch.com/randhash" target="_blank" rel="noopener">https://research.swtch.com/randhash</a></p><p>【并发安全阐述】<a href="http://zjykzk.github.io/post/cs/golang/map/" target="_blank" rel="noopener">http://zjykzk.github.io/post/cs/golang/map/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。&lt;/p&gt;
&lt;p&gt;我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之反射</title>
    <link href="https://qcrao.com/2019/05/07/dive-into-go-reflection/"/>
    <id>https://qcrao.com/2019/05/07/dive-into-go-reflection/</id>
    <published>2019-05-07T00:35:00.000Z</published>
    <updated>2019-07-31T08:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>反射和 Interface 息息相关，而 Interface 是我们<a href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA" target="_blank" rel="noopener">上一篇文章</a>的内容。在开始正文前，和大家说点题外话。</p><p>上一篇关于 Interface 的文章发出后，获得了很多的关注和阅读。比如，登上了 GoCN 的每日新闻第一条：</p><p><img src="https://user-images.githubusercontent.com/7698088/57132448-3c13c880-6dd2-11e9-91b0-4d6b846a605e.png" alt="gocn"></p><p>可能是编辑者觉得这篇文章称不上“深度解密”，把标题给小小地改动了下，哈哈~~</p><p>在博客园登上了 48 小时阅读排行榜：</p><p><img src="https://user-images.githubusercontent.com/7698088/57132468-4a61e480-6dd2-11e9-953c-a981ed048dae.png" alt="博客园"></p><p>在开发者头条 APP （类似于今日头条，不过内容都是技术相关的，还挺有意思的）上收获了 150 收藏，并被推荐到首页最显眼的 banner 位置，阅读量达到了 1w 多，只是不知道这个数字是否是真实的，有点难以相信。</p><p><img src="https://user-images.githubusercontent.com/7698088/57132395-0e2e8400-6dd2-11e9-88e7-f71605c3bb66.png" alt="开发者头条"></p><p>很多同学在后台向我反映文章太长了，不利于阅读，建议拆分一下。我非常理解，读屏时代，大家需要快速地读完全文，拿到收益。而码农桃花源的文章都非常长，读者很难在短时间内读完，并且获得相应的收益。</p><p>首先非常感谢大家的建议！其实我的想法是这样的：大家都在说，现在是一个信息严重过载的时代，信息多得看不完，不免产生很多焦虑。但是，我想说，优质的信息真有那么多吗？在我看来，文章的水平都是参差不齐，很多毫无内容和价值，大家把时间浪费在这些信息上面是很不值得的。因为你读了这些文章，就没有了读其他好的文章的精力。</p><p>所以，码农桃花源想做一个优质信息源，提供优质的内容。每一篇文章都是有深度，有内容，有收获。一篇文章，我一般得花费 2 周左右，算是半月更，和那些日更的没法比。当然，只是在数量上没法比。而这个时代，最不缺的就是数量。</p><p>另外，文章长也算是我的一个特色。我完全可以拆分成上、中、下等等，但我希望一次性交付给我的读者所有有价值的内容。这样，你可以集中一个小时或是更长时间，精读完一篇文章。</p><p>闲话结束，今天要讲的内容是反射，进入正题。</p><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>直接看维基百科上的定义：</p><blockquote><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p></blockquote><p>那我就要问个问题了：不用反射就不能在运行时访问、检测和修改它本身的状态和行为吗？</p><p>问题的回答，其实要首先理解什么叫访问、检测和修改它本身状态或行为，它的本质是什么？</p><p>实际上，它的本质是程序在运行期探知对象的类型信息和内存结构，不用反射能行吗？可以的！使用汇编语言，直接和内层打交道，什么信息不能获取？但是，当编程迁移到高级语言上来之后，就不行了！就只能通过<code>反射</code>来达到此项技能。</p><p>不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：</p><blockquote><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p></blockquote><h1 id="为什么要用反射"><a href="#为什么要用反射" class="headerlink" title="为什么要用反射"></a>为什么要用反射</h1><p>需要反射的 2 个常见场景：</p><ol><li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li><li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li></ol><p>在讲反射的原理以及如何用之前，还是说几点不使用反射的理由：</p><ol><li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li><li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li><li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。 </li></ol><h1 id="反射是如何实现的"><a href="#反射是如何实现的" class="headerlink" title="反射是如何实现的"></a>反射是如何实现的</h1><p>上一篇文章讲到了 <code>interface</code>，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。</p><p>Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。</p><h2 id="types-和-interface"><a href="#types-和-interface" class="headerlink" title="types 和 interface"></a>types 和 interface</h2><p>Go 语言中，每个变量都有一个静态类型，在编译阶段就确定了的，比如 <code>int, float64, []int</code> 等等。注意，这个类型是声明时候的类型，不是底层数据类型。</p><p>Go 官方博客里就举了一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure><p>尽管 i，j 的底层类型都是 int，但我们知道，他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 <code>MyInt</code>。</p><p>反射主要与 interface{} 类型相关。前面一篇关于 interface 相关的文章已经探讨过 interface 的底层结构，这里再来复习一下。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter  *interfacetype</span><br><span class="line">_type  *_type</span><br><span class="line">link   *itab</span><br><span class="line">hash   <span class="keyword">uint32</span></span><br><span class="line">bad    <span class="keyword">bool</span></span><br><span class="line">inhash <span class="keyword">bool</span></span><br><span class="line">unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">fun    [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>itab</code> 由具体类型 <code>_type</code> 以及 <code>interfacetype</code> 组成。<code>_type</code> 表示具体类型，而 <code>interfacetype</code> 则表示具体类型实现的接口类型。</p><p><img src="https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p><p>实际上，iface 描述的是非空接口，它包含方法；与之相对的是 <code>eface</code>，描述的是空接口，不包含任何方法，Go 语言里有的类型都 <code>“实现了”</code> 空接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p><p><img src="https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p><p>还是用 Go 官方关于反射的博客里的例子，当然，我会用图形来详细解释，结合两者来看会更清楚。顺便提一下，搞技术的不要害怕英文资料，要想成为技术专家，读英文原始资料是技术提高的一条必经之路。</p><p>先明确一点：接口变量可以存储任何实现了接口定义的所有方法的变量。</p><p>Go 语言中最常见的就是 <code>Reader</code> 和 <code>Writer</code> 接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是接口之间的各种转换和赋值了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">"/Users/qcrao/Desktop/test"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure><p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code>。</p><p>之后，<code>r = tty</code> 这一语句，将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/56844299-b29b5c80-68e0-11e9-8211-d227448806b7.png" alt="r=tty"></p><p>注意看上图，此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure><p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p><p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> 。<code>w</code> 的内存形式如下图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57341967-09215a00-716f-11e9-99cc-cfaa0f312b54.png" alt="w = r.(io.Writer)"></p><p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p><p>最后，再来一个赋值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br></pre></td></tr></table></figure><p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p><p><img src="https://user-images.githubusercontent.com/7698088/56844669-9b5f6d80-68e6-11e9-8a31-8d38951c7742.png" alt="empty=w"></p><p>从上面的三张图可以看到，interface 包含三部分信息：<code>_type</code> 是类型信息，<code>*data</code> 指向实际类型的实际值，<code>itab</code> 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法），补充一下关于 os.File 结构体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/56946658-4bd6a700-6b5d-11e9-9a3d-0e781957be31.png" alt="struct_type"></p><p>这一节的最后，复习一下上一篇关于 interface 的文章，提到的一个技巧，这里再展示一下：</p><p>先参考源码，分别定义一个<code>“伪装”</code>的 iface 和 eface 结构体。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter <span class="keyword">uintptr</span></span><br><span class="line">_type <span class="keyword">uintptr</span></span><br><span class="line">link <span class="keyword">uintptr</span></span><br><span class="line">hash  <span class="keyword">uint32</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type <span class="keyword">uintptr</span></span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，将接口变量占据的内存内容强制解释成上面定义的类型，再打印出来：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">fmt.Printf(<span class="string">"initial r: %T, %v\n"</span>, r, r)</span><br><span class="line"></span><br><span class="line">tty, _ := os.OpenFile(<span class="string">"/Users/qcrao/Desktop/test"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"tty: %T, %v\n"</span>, tty, tty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 r 赋值</span></span><br><span class="line">r = tty</span><br><span class="line">fmt.Printf(<span class="string">"r: %T, %v\n"</span>, r, r)</span><br><span class="line"></span><br><span class="line">rIface := (*iface)(unsafe.Pointer(&amp;r))</span><br><span class="line">fmt.Printf(<span class="string">"r: iface.tab._type = %#x, iface.data = %#x\n"</span>, rIface.tab._type, rIface.data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 w 赋值</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br><span class="line">fmt.Printf(<span class="string">"w: %T, %v\n"</span>, w, w)</span><br><span class="line"></span><br><span class="line">wIface := (*iface)(unsafe.Pointer(&amp;w))</span><br><span class="line">fmt.Printf(<span class="string">"w: iface.tab._type = %#x, iface.data = %#x\n"</span>, wIface.tab._type, wIface.data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 empty 赋值</span></span><br><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br><span class="line">fmt.Printf(<span class="string">"empty: %T, %v\n"</span>, empty, empty)</span><br><span class="line"></span><br><span class="line">emptyEface := (*eface)(unsafe.Pointer(&amp;empty))</span><br><span class="line">fmt.Printf(<span class="string">"empty: eface._type = %#x, eface.data = %#x\n"</span>, emptyEface._type, emptyEface.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initial r: &lt;<span class="literal">nil</span>&gt;, &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">tty: *os.File, &amp;&#123;<span class="number">0xc4200820f</span>0&#125;</span><br><span class="line">r: *os.File, &amp;&#123;<span class="number">0xc4200820f</span>0&#125;</span><br><span class="line">r: iface.tab._type = <span class="number">0x10bf</span>cc0, iface.data = <span class="number">0xc420080020</span></span><br><span class="line">w: *os.File, &amp;&#123;<span class="number">0xc4200820f</span>0&#125;</span><br><span class="line">w: iface.tab._type = <span class="number">0x10bf</span>cc0, iface.data = <span class="number">0xc420080020</span></span><br><span class="line">empty: *os.File, &amp;&#123;<span class="number">0xc4200820f</span>0&#125;</span><br><span class="line">empty: eface._type = <span class="number">0x10bf</span>cc0, eface.data = <span class="number">0xc420080020</span></span><br></pre></td></tr></table></figure><p><code>r，w，empty</code> 的动态类型和动态值都一样。不再详细解释了，结合前面的图可以看得非常清晰。</p><h2 id="反射的基本函数"><a href="#反射的基本函数" class="headerlink" title="反射的基本函数"></a>反射的基本函数</h2><p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此程序员可以获取甚至改变类型的值。</p><p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure><p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface{}</code>，调用此函数时，实参会先被转化为 <code>interface{}</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface{}</code> 变量里了。</p><p>看下源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>emptyInterface</code> 和上面提到的 <code>eface</code> 是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 <code>reflect</code> 包，后者在 <code>runtime</code> 包。 <code>eface.typ</code> 就是动态类型。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 <code>toType</code> 函数，只是做了一个类型转换：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，返回值 <code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 <code>*rtype</code> 实现了 <code>Type</code> 接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的类型都可以调用下面这些函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此类型的变量对齐后所占用的字节数</span></span><br><span class="line">Align() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 struct 的字段，对齐后占用的字节数</span></span><br><span class="line">FieldAlign() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型方法集里的第 `i` (传入的参数)个方法</span></span><br><span class="line">Method(<span class="keyword">int</span>) Method</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过名称获取方法</span></span><br><span class="line">MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类型方法集里导出的方法个数</span></span><br><span class="line">NumMethod() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型名称</span></span><br><span class="line">Name() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型所在的路径，如：encoding/base64</span></span><br><span class="line">PkgPath() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型的大小，和 unsafe.Sizeof 功能类似</span></span><br><span class="line">Size() <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型的字符串表示形式</span></span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型的类型值</span></span><br><span class="line">Kind() Kind</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型是否实现了接口 u</span></span><br><span class="line">Implements(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可以赋值给 u</span></span><br><span class="line">AssignableTo(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可以类型转换成 u</span></span><br><span class="line">ConvertibleTo(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型是否可以比较</span></span><br><span class="line">Comparable() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这些函数只有特定类型可以调用</span></span><br><span class="line"><span class="comment">// 如：Key, Elem 两个方法就只能是 Map 类型才能调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型所占据的位数</span></span><br><span class="line">Bits() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回通道的方向，只能是 chan 类型调用</span></span><br><span class="line">ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型是否是可变参数，只能是 func 类型调用</span></span><br><span class="line"><span class="comment">// 比如 t 是类型 func(x int, y ... float64)</span></span><br><span class="line"><span class="comment">// 那么 t.IsVariadic() == true</span></span><br><span class="line">IsVariadic() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用</span></span><br><span class="line">Elem() Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体类型的第 i 个字段，只能是结构体类型调用</span></span><br><span class="line"><span class="comment">// 如果 i 超过了总字段数，就会 panic</span></span><br><span class="line">Field(i <span class="keyword">int</span>) StructField</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回嵌套的结构体的字段</span></span><br><span class="line">FieldByIndex(index []<span class="keyword">int</span>) StructField</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名称获取字段</span></span><br><span class="line">FieldByName(name <span class="keyword">string</span>) (StructField, <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FieldByNameFunc returns the struct field with a name</span></span><br><span class="line"><span class="comment">// 返回名称符合 func 函数的字段</span></span><br><span class="line">FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="params">(StructField, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取函数类型的第 <span class="title">i</span> 个参数的类型</span></span><br><span class="line"><span class="function"><span class="title">In</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">map</span> 的 <span class="title">key</span> 类型，只能由类型 <span class="title">map</span> 调用</span></span><br><span class="line"><span class="function"><span class="title">Key</span><span class="params">()</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">Array</span> 的长度，只能由类型 <span class="title">Array</span> 调用</span></span><br><span class="line"><span class="function"><span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回类型字段的数量，只能由类型 <span class="title">Struct</span> 调用</span></span><br><span class="line"><span class="function"><span class="title">NumField</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回函数类型的输入参数个数</span></span><br><span class="line"><span class="function"><span class="title">NumIn</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回函数类型的返回值个数</span></span><br><span class="line"><span class="function"><span class="title">NumOut</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回函数类型的第 <span class="title">i</span> 个值的类型</span></span><br><span class="line"><span class="function"><span class="title">Out</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 返回类型结构体的相同部分</span></span><br><span class="line"><span class="function"><span class="title">common</span><span class="params">()</span> *<span class="title">rtype</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回类型结构体的不同部分</span></span><br><span class="line"><span class="function"><span class="title">uncommon</span><span class="params">()</span> *<span class="title">uncommonType</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>可见 <code>Type</code> 定义了非常多的方法，通过它们可以获取类型的一切信息，大家一定要完整的过一遍上面所有的方法。</p><p>注意到 <code>Type</code> 方法集的倒数第二个方法 <code>common</code><br> 返回的 <code>rtype</code>类型，它和上一篇文章讲到的 <code>_type</code> 是一回事，而且源代码里也注释了：两边要保持同步：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rtype must be kept in sync with ../runtime/type.go:/^type._type.</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="keyword">uintptr</span></span><br><span class="line">ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">hash       <span class="keyword">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="keyword">uint8</span></span><br><span class="line">fieldAlign <span class="keyword">uint8</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">alg        *typeAlg</span><br><span class="line">gcdata     *<span class="keyword">byte</span></span><br><span class="line">str        nameOff</span><br><span class="line">ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的类型都会包含 <code>rtype</code> 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。</p><p>比如下面的 <code>arrayType</code> 和 <code>chanType</code> 都包含 <code>rytpe</code>，而前者还包含 slice，len 等和数组相关的信息；后者则包含 <code>dir</code> 表示通道方向的信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrayType represents a fixed array type.</span></span><br><span class="line"><span class="keyword">type</span> arrayType <span class="keyword">struct</span> &#123;</span><br><span class="line">rtype <span class="string">`reflect:"array"`</span></span><br><span class="line">elem  *rtype <span class="comment">// array element type</span></span><br><span class="line">slice *rtype <span class="comment">// slice type</span></span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chanType represents a channel type.</span></span><br><span class="line"><span class="keyword">type</span> chanType <span class="keyword">struct</span> &#123;</span><br><span class="line">rtype <span class="string">`reflect:"chan"`</span></span><br><span class="line">elem  *rtype  <span class="comment">// channel element type</span></span><br><span class="line">dir   <span class="keyword">uintptr</span> <span class="comment">// channel direction (ChanDir)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>Type</code> 接口实现了 <code>String()</code> 函数，满足 <code>fmt.Stringer</code> 接口，因此使用 <code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。另外，<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T"</span>, <span class="number">3</span>) <span class="comment">// int</span></span><br></pre></td></tr></table></figure><hr><p>讲完了 <code>TypeOf</code> 函数，再来看一下 <code>ValueOf</code> 函数。返回值 <code>reflect.Value</code> 表示 <code>interface{}</code> 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 _type (具体到这里是指 structType) 类型持有的关于结构体的字段信息、偏移信息，以及 <code>*data</code> 所指向的内容 —— 结构体的实际值。</p><p>源码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ……</span></span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解 eface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"></span><br><span class="line">t := e.typ</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := flag(t.Kind())</span><br><span class="line"><span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">f |= flagIndir</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码看，比较简单：将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p><p>Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置切片的 len 字段，如果类型不是切片，就会panic</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">SetLen</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> // 设置切片的 <span class="title">cap</span> 字段</span></span><br><span class="line"><span class="function"> <span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetCap</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> // 设置字典的 <span class="title">kv</span></span></span><br><span class="line"><span class="function"> <span class="title">func</span> <span class="params">(v Value)</span> <span class="title">SetMapIndex</span><span class="params">(key, val Value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> // 返回切片、字符串、数组的索引 <span class="title">i</span> 处的值</span></span><br><span class="line"><span class="function"> <span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Index</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> // 根据名称获取结构体的内部字段值</span></span><br><span class="line"><span class="function"> <span class="title">func</span> <span class="params">(v Value)</span> <span class="title">FieldByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> // ……</span></span><br></pre></td></tr></table></figure><p><code>Value</code> 字段还有很多其他的方法。例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来获取 int 类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Int</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 用来获取结构体字段（成员）数量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">NumField</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 尝试向通道发送数据（不会阻塞）</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">TrySend</span><span class="params">(x reflect.Value)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 通过参数列表 <span class="title">in</span> 调用 <span class="title">v</span> 值所代表的函数（或方法</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> <span class="params">(r []Value)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 调用变参长度可变的函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">CallSlice</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span></span><br></pre></td></tr></table></figure><p>不一一列举了，反正是非常多。可以去 <code>src/reflect/value.go</code> 去看看源码，搜索 <code>func (v Value)</code> 就能看到。</p><p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。Type() 方法也可以返回变量的类型信息，与 reflect.TypeOf() 函数等价。Interface() 方法可以将 Value 还原成原来的 interface。</p><p>这里引用老钱《快学Go语言第十五课——反射》的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57130652-bb060280-6dcc-11e9-9c63-6e2bc4e33509.png" alt="三者关系"><br>总结一下：<code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p><p>用一张图来串一下：</p><p><img src="https://user-images.githubusercontent.com/7698088/56848267-6f111480-6919-11e9-826f-a809093d17ea.png" alt="value rtype"></p><p>上图中，<code>rtye</code> 实现了 <code>Type</code> 接口，是所有类型的公共部分。emptyface 结构体和 eface 其实是一个东西，而 rtype 其实和 _type 是一个东西，只是一些字段稍微有点差别，比如 emptyface 的 word 字段和 eface 的 data 字段名称不同，但是数据型是一样的。</p><h2 id="反射的三大定律"><a href="#反射的三大定律" class="headerlink" title="反射的三大定律"></a>反射的三大定律</h2><p>根据 Go 官方关于反射的博客，反射有三大定律：</p><blockquote><ol><li>Reflection goes from interface value to reflection object.</li></ol></blockquote><blockquote><ol start="2"><li>Reflection goes from reflection object to interface value.</li></ol></blockquote><blockquote><ol start="3"><li>To modify a reflection object, the value must be settable.</li></ol></blockquote><p>第一条是最基本的：反射是一种检测存储在 <code>interface</code> 中的类型和值机制。这可以通过 <code>TypeOf</code> 函数和 <code>ValueOf</code> 函数得到。</p><p>第二条实际上和第一条是相反的机制，它将 <code>ValueOf</code> 的返回值通过 <code>Interface()</code> 函数反向转变成 <code>interface</code> 变量。</p><p>前两条就是说 <code>接口型变量</code> 和 <code>反射类型对象</code> 可以相互转化，反射类型对象实际上就是指的前面说的 <code>reflect.Type</code> 和 <code>reflect.Value</code>。</p><p>第三条不太好懂：如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。</p><p>举一个经典例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure><p>执行上面的代码会产生 panic，原因是反射变量 <code>v</code> 不能代表 <code>x</code> 本身，为什么？因为调用 <code>reflect.ValueOf(x)</code> 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 <code>v</code> 代表的只是 <code>x</code> 的一个拷贝，因此对 <code>v</code> 进行操作是被禁止的。</p><p>可设置是反射变量 <code>Value</code> 的一个性质，但不是所有的 <code>Value</code> 都是可被设置的。</p><p>就像在一般的函数里那样，当我们想改变传入的变量时，使用指针就可以解决了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</span><br></pre></td></tr></table></figure><p>输出是这样的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of p: *<span class="keyword">float64</span></span><br><span class="line">settability of p: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>p</code> 还不是代表 <code>x</code>，<code>p.Elem()</code> 才真正代表 <code>x</code>，这样就可以真正操作 <code>x</code> 了：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface()) <span class="comment">// 7.1</span></span><br><span class="line">fmt.Println(x) <span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure><p>关于第三条，记住一句话：如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p><h1 id="反射相关函数的使用"><a href="#反射相关函数的使用" class="headerlink" title="反射相关函数的使用"></a>反射相关函数的使用</h1><h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><p>网络上各种博客文章里使用反射的样例代码非常多，读过这篇文章后，基本没有看不懂的，哈哈！不过，我这里还是举一个例子，并讲解一番：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span></span><br><span class="line">Grade    <span class="keyword">int</span></span><br><span class="line">Handsome <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adult <span class="keyword">struct</span> &#123;</span><br><span class="line">ID         <span class="keyword">string</span> <span class="string">`qson:"Name"`</span></span><br><span class="line">Occupation <span class="keyword">string</span></span><br><span class="line">Handsome   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，</span></span><br><span class="line"><span class="comment">// 并且有一个字段的 tag 或者字段名是 `Name` ，</span></span><br><span class="line"><span class="comment">// 如果该 `Name` 字段的值是 `qcrao`，</span></span><br><span class="line"><span class="comment">// 就把结构体中名为 `Handsome` 的字段值设置为 true。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handsome</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取 i 的反射变量 Value</span></span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定 v 是一个 Slice</span></span><br><span class="line"><span class="keyword">if</span> v.Kind() != reflect.Slice &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定 v 是的元素为结构体</span></span><br><span class="line"><span class="keyword">if</span> e := v.Type().Elem(); e.Kind() != reflect.Struct &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定结构体的字段名含有 "ID" 或者 json tag 标签为 `name`</span></span><br><span class="line"><span class="comment">// 确定结构体的字段名 "Handsome"</span></span><br><span class="line">st := v.Type().Elem()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段</span></span><br><span class="line">foundName := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; st.NumField(); i++ &#123;</span><br><span class="line">f := st.Field(i)</span><br><span class="line">tag := f.Tag.Get(<span class="string">"qson"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tag == <span class="string">"Name"</span> || f.Name == <span class="string">"Name"</span>) &amp;&amp; f.Type.Kind() == reflect.String &#123;</span><br><span class="line">foundName = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !foundName &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> niceField, foundHandsome := st.FieldByName(<span class="string">"Handsome"</span>); foundHandsome == <span class="literal">false</span> || niceField.Type.Kind() != reflect.Bool &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置名字为 "qcrao" 的对象的 "Handsome" 字段为 true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">e := v.Index(i)</span><br><span class="line">handsome := e.FieldByName(<span class="string">"Handsome"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找字段名为 Name 或者 tag 的值为 Name 的字段</span></span><br><span class="line"><span class="keyword">var</span> name reflect.Value</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; st.NumField(); j++ &#123;</span><br><span class="line">f := st.Field(j)</span><br><span class="line">tag := f.Tag.Get(<span class="string">"qson"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tag == <span class="string">"Name"</span> || f.Name == <span class="string">"Name"</span> &#123;</span><br><span class="line">name = v.Index(i).Field(j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name.String() == <span class="string">"qcrao"</span> &#123;</span><br><span class="line">handsome.SetBool(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">children := []Child&#123;</span><br><span class="line">&#123;Name: <span class="string">"Ava"</span>, Grade: <span class="number">3</span>, Handsome: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;Name: <span class="string">"qcrao"</span>, Grade: <span class="number">6</span>, Handsome: <span class="literal">false</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adults := []Adult&#123;</span><br><span class="line">&#123;ID: <span class="string">"Steve"</span>, Occupation: <span class="string">"Clerk"</span>, Handsome: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;ID: <span class="string">"qcrao"</span>, Occupation: <span class="string">"Go Programmer"</span>, Handsome: <span class="literal">false</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"adults before handsome: %v\n"</span>, adults)</span><br><span class="line">handsome(adults)</span><br><span class="line">fmt.Printf(<span class="string">"adults after handsome: %v\n"</span>, adults)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"-------------"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"children before handsome: %v\n"</span>, children)</span><br><span class="line">handsome(children)</span><br><span class="line">fmt.Printf(<span class="string">"children after handsome: %v\n"</span>, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adults before handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer false&#125;]</span><br><span class="line">adults after handsome: [&#123;Steve Clerk true&#125; &#123;qcrao Go Programmer true&#125;]</span><br><span class="line">-------------</span><br><span class="line">children before handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 false&#125;]</span><br><span class="line">children after handsome: [&#123;Ava 3 true&#125; &#123;qcrao 6 true&#125;]</span><br></pre></td></tr></table></figure><p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p><p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p><p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p><h2 id="未导出成员"><a href="#未导出成员" class="headerlink" title="未导出成员"></a>未导出成员</h2><p>利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。</p><p>注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。</p><blockquote><p>一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。<br>CanAddr 不能说明一个变量是否可以被修改。<br>CanSet 则可以检查对应的 reflect.Value 是否可取地址并可被修改。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span></span><br><span class="line">handsome <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">qcrao := Child&#123;Name: <span class="string">"qcrao"</span>, handsome: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">f := v.Elem().FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">fmt.Println(f.String())</span><br><span class="line"></span><br><span class="line">f.SetString(<span class="string">"stefno"</span>)</span><br><span class="line">fmt.Println(f.String())</span><br><span class="line"></span><br><span class="line">f = v.Elem().FieldByName(<span class="string">"handsome"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一句会导致 panic，因为 handsome 字段未导出</span></span><br><span class="line"><span class="comment">//f.SetBool(true)</span></span><br><span class="line">fmt.Println(f.Bool())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qcrao</span><br><span class="line">stefno</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>上面的例子中，handsome 字段未导出，可以读取，但不能调用相关 set 方法，否则会 panic。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。</p><h1 id="反射的实际应用"><a href="#反射的实际应用" class="headerlink" title="反射的实际应用"></a>反射的实际应用</h1><p>反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p><p>这里举 2 个例子：json 序列化和 DeepEqual 函数。</p><h2 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h2><p>开发过 web 服务的同学，一定用过 <code>json</code> 数据格式。<code>json</code> 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。</p><p>Go 语言中，主要提供 2 个函数用于序列化和反序列化：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>两个函数的参数都包含 <code>interface</code>，具体实现的时候，都会用到反射相关的特性。</p><p>对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 get 函数或者 set 函数进行实际的操作。</p><h2 id="DeepEqual-的作用及原理"><a href="#DeepEqual-的作用及原理" class="headerlink" title="DeepEqual 的作用及原理"></a>DeepEqual 的作用及原理</h2><p>在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。</p><p>例如：如何判断两个 slice 所有的元素完全相同；如何判断两个 map 的 key 和 value 完全相同等等。</p><p>上述问题，可以通过 <code>DeepEqual</code> 函数实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>DeepEqual</code> 函数的参数是两个 <code>interface</code>，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。</p><p>先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> YourInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := MyInt(<span class="number">1</span>)</span><br><span class="line">y := YourInt(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(reflect.DeepEqual(m, y)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 <code>MyInt</code>，后者是 <code>YourInt</code>，因此两者不是“深度”相等。</p><p>在源码里，有对 DeepEqual 函数的非常清楚地注释，列举了不同类型，DeepEqual 的比较情形，这里做一个总结：</p><table><thead><tr><th>类型</th><th>深度相等情形</th></tr></thead><tbody><tr><td>Array</td><td>相同索引处的元素“深度”相等</td></tr><tr><td>Struct</td><td>相应字段，包含导出和不导出，“深度”相等</td></tr><tr><td>Func</td><td>只有两者都是 nil 时</td></tr><tr><td>Interface</td><td>两者存储的具体值“深度”相等</td></tr><tr><td>Map</td><td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td></tr><tr><td>Pointer</td><td>1、使用 == 比较的结果相等；2、指向的实体“深度”相等</td></tr><tr><td>Slice</td><td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] == &amp;y[0] 或者 相同索引处的元素“深度”相等</td></tr><tr><td>numbers, bools, strings, and channels</td><td>使用 == 比较的结果为真</td></tr></tbody></table><p>一般情况下，DeepEqual 的实现只需要递归地调用 == 就可以比较两个变量是否是真的“深度”相等。</p><p>但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等；float 类型，由于精度的原因，也是不能使用 == 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。</p><p>对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。</p><p>同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。</p><p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p><p>来看源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(x, y <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> || y == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x == y</span><br><span class="line">&#125;</span><br><span class="line">v1 := ValueOf(x)</span><br><span class="line">v2 := ValueOf(y)</span><br><span class="line"><span class="keyword">if</span> v1.Type() != v2.Type() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deepValueEqual(v1, v2, <span class="built_in">make</span>(<span class="keyword">map</span>[visit]<span class="keyword">bool</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。</p><p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p><p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p><p>代码比较长，思路却比较简单清晰：核心是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。</p><p>实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 <code>map</code> 类型的比较：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deepValueEqual 函数</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Map:</span><br><span class="line"><span class="keyword">if</span> v1.IsNil() != v2.IsNil() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Len() != v2.Len() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v1.Pointer() == v2.Pointer() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> v1.MapKeys() &#123;</span><br><span class="line">val1 := v1.MapIndex(k)</span><br><span class="line">val2 := v2.MapIndex(k)</span><br><span class="line"><span class="keyword">if</span> !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p>和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> visit <span class="keyword">struct</span> &#123;</span><br><span class="line">a1  unsafe.Pointer</span><br><span class="line">a2  unsafe.Pointer</span><br><span class="line">typ Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>[visit]<span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 <code>true</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。</p><p>Go 语言的反射实现的基础是类型，或者说是 interface，当我们使用反射特性时，实际上用到的就是存储在 interface 变量中的和类型相关的信息，也就是常说的 <code>&lt;type, value&gt;</code> 对。</p><p>只有 interface 才有反射的说法。</p><p>反射在 reflect 包中实现，涉及到两个相关函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span> <span class="params">( i <span class="keyword">interface</span>&#123;&#125; )</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ValueOf</span> <span class="params">( i <span class="keyword">interface</span>&#123;&#125; )</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure><p>Type 是一个接口，定义了很多相关方法，用于获取类型信息。Value 则持有类型的具体值。Type、Value、Interface 三者间通过函数 TypeOf，ValueOf，Interface 进行相互转换。</p><p>最后温习一下反射三大定律：</p><blockquote><ol><li>Reflection goes from interface value to reflection object.</li><li>Reflection goes from reflection object to interface value.</li><li>To modify a reflection object, the value must be settable.</li></ol></blockquote><p>翻译一下：</p><blockquote><ol><li>反射将接口变量转换成反射对象 Type 和 Value；</li><li>反射可以通过反射对象 Value 还原成原先的接口变量；</li><li>反射可以用来修改一个变量的值，前提是这个值可以被修改。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【维基百科中文】<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p><p>【码洞老钱 反射】<a href="https://juejin.im/post/5c2040d76fb9a049c643d9bd" target="_blank" rel="noopener">https://juejin.im/post/5c2040d76fb9a049c643d9bd</a></p><p>【Go官方博客 reflection】<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">https://blog.golang.org/laws-of-reflection</a></p><p>【GCTT译文，不错】<a href="https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A</a></p><p>【json库 源码分析】<a href="https://zhuanlan.zhihu.com/p/37165706" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37165706</a></p><p>【reflect 代码例子和图比较好】<a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/</a></p><p>【反射使用讲得不错】<a href="https://juejin.im/post/5a75a4fb5188257a82110544" target="_blank" rel="noopener">https://juejin.im/post/5a75a4fb5188257a82110544</a></p><p>【接口和反射的关系 ，english】<a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/</a></p><p>【总结成知识点】<a href="http://www.cnblogs.com/susufufu/p/7653579.html" target="_blank" rel="noopener">http://www.cnblogs.com/susufufu/p/7653579.html</a></p><p>【Type Value】<a href="https://colobu.com/2016/07/09/dive-into-go-13/" target="_blank" rel="noopener">https://colobu.com/2016/07/09/dive-into-go-13/</a></p><p>【讲得比较清晰简单】<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html" target="_blank" rel="noopener">https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html</a></p><p>【DeepEqual】<a href="https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md" target="_blank" rel="noopener">https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md</a></p><p>【反射使用场景】<a href="https://yq.aliyun.com/articles/599584" target="_blank" rel="noopener">https://yq.aliyun.com/articles/599584</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射和 Interface 息息相关，而 Interface 是我们&lt;a href=&quot;https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;的内容
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之关于interface的 10 个问题</title>
    <link href="https://qcrao.com/2019/04/25/dive-into-go-interface/"/>
    <id>https://qcrao.com/2019/04/25/dive-into-go-interface/</id>
    <published>2019-04-25T00:25:00.000Z</published>
    <updated>2019-12-21T13:17:00.940Z</updated>
    
    <content type="html"><![CDATA[<p>这次文章依然很长，基本上涵盖了 <code>interface</code> 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到<code>反射</code>，当然，后面会单独写一篇关于<code>反射</code>的文章，这是后话。</p><p>还是希望看你在看完文章后能有所收获，有任何问题或意见建议，欢迎在文章后面留言。</p><p>这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。</p><h1 id="1-Go-语言与鸭子类型的关系"><a href="#1-Go-语言与鸭子类型的关系" class="headerlink" title="1. Go 语言与鸭子类型的关系"></a>1. Go 语言与鸭子类型的关系</h1><p>先直接来看维基百科里的定义：</p><blockquote><p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p></blockquote><p>翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p><p><code>Duck Typing</code>，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。</p><p>例如，在动态语言 python 中，定义一个这样的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(coder)</span>:</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure><p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</p><p>而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</p><p>动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 <code>python</code> 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。</p><p>Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</p><p>来看个例子：</p><p>先定义一个接口，和使用此接口作为参数的函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来定义两个结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hi, I am GO!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hi, I am PHP!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在 main 函数里调用 sayHello() 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">golang := Go&#123;&#125;</span><br><span class="line">php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">sayHello(golang)</span><br><span class="line">sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure><p>在 main 函数中，调用调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</p><p>顺带再提一下动态语言的特点：</p><blockquote><p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p></blockquote><p>总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</p><h1 id="2-值接收者和指针接收者的区别"><a href="#2-值接收者和指针接收者的区别" class="headerlink" title="2. 值接收者和指针接收者的区别"></a>2. 值接收者和指针接收者的区别</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</p><p>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p><p>也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p><p>来看个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// qcrao 是值类型</span></span><br><span class="line">qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型 调用接收者也是值类型的方法</span></span><br><span class="line">fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型 调用接收者是指针类型的方法</span></span><br><span class="line">qcrao.growUp()</span><br><span class="line">fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stefno 是指针类型</span></span><br><span class="line">stefno := &amp;Person&#123;age: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型 调用接收者是值类型的方法</span></span><br><span class="line">fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型 调用接收者也是指针类型的方法</span></span><br><span class="line">stefno.growUp()</span><br><span class="line">fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例子的输出结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure><p>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p><p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p><table><thead><tr><th>-</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于“传值”</td><td>使用值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值，上例中，<code>stefno.howOld()</code> 实际上是 <code>(*stefno).howOld()</code></td><td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p><p>先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p><p>来看一个例子，就会完全明白：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">code()</span><br><span class="line">debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">c.code()</span><br><span class="line">c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure><p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p><p>最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p><p>运行一下，结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure><p>但是如果我们把 <code>main</code> 函数的第一条语句换一下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c coder = Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line">c.code()</span><br><span class="line">c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main.go:23:6: cannot use Gopher literal (type Gopher) as type coder in assignment:</span><br><span class="line">Gopher does not implement coder (debug method has pointer receiver)</span><br></pre></td></tr></table></figure><p>看出这两处代码的差别了吗？第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p><p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>，很明显了吧？因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法。表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</p><p>当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</p><p>所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</p><p>最后，只要记住下面这点就可以了：</p><blockquote><p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p></blockquote><h2 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h2><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><p>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</p><p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p><p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code>。</p><p>这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。</p><h1 id="3-iface-和-eface-的区别是什么"><a href="#3-iface-和-eface-的区别是什么" class="headerlink" title="3. iface 和 eface 的区别是什么"></a>3. iface 和 eface 的区别是什么</h1><p><code>iface</code> 和 <code>eface</code> 都是 Go 中描述接口的底层结构体，区别在于 <code>iface</code> 描述的接口包含方法，而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</p><p>从源码层面看一下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter  *interfacetype</span><br><span class="line">_type  *_type</span><br><span class="line">link   *itab</span><br><span class="line">hash   <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">bad    <span class="keyword">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">inhash <span class="keyword">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p><p>再来仔细看一下 <code>itab</code> 结构体：<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；<code>inter</code> 字段则描述了接口的类型。<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p><p>这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</p><p>另外，你可能会觉得奇怪，为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p><p>再看一下 <code>interfacetype</code> 类型，它描述的是接口的类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p><p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p><p><img src="https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p><p>接着来看一下 <code>eface</code> 的源码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p><p><img src="https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p><p>我们来看个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125; = x</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">g := Gopher&#123;<span class="string">"Go"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> c coder = g</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">code()</span><br><span class="line">debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"I am coding %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"I am debuging %s language\n"</span>, p.language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令，打印出汇编语言：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure><p>可以看到，main 函数里调用了两个函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func convT2E64(t *_type, elem unsafe.Pointer) (e eface)</span><br><span class="line">func convT2I(tab *itab, elem unsafe.Pointer) (i iface)</span><br></pre></td></tr></table></figure><p>上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p><p>作为补充，我们最后再来看下 <code>_type</code> 结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 类型大小</span></span><br><span class="line">size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 类型的 hash 值</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 类型的 flag，和反射相关</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    <span class="comment">// 内存对齐相关</span></span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// 类型的编号，有bool, slice, struct 等等等等</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">alg        *typeAlg</span><br><span class="line"><span class="comment">// gc 相关</span></span><br><span class="line">gcdata    *<span class="keyword">byte</span></span><br><span class="line">str       nameOff</span><br><span class="line">ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ   _type</span><br><span class="line">elem  *_type</span><br><span class="line">slice *_type</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  _type</span><br><span class="line">elem *_type</span><br><span class="line">dir  <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  _type</span><br><span class="line">elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgPath name</span><br><span class="line">fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些数据类型的结构体定义，是反射实现的基础。</p><h1 id="4-接口的动态类型和动态值"><a href="#4-接口的动态类型和动态值" class="headerlink" title="4. 接口的动态类型和动态值"></a>4. 接口的动态类型和动态值</h1><p>从源码里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<code>动态类型</code>和<code>动态值</code>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p><p>【引申1】接口类型和 <code>nil</code> 作比较</p><p>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p><p>来看个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">interface</span> &#123;</span><br><span class="line">code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s is coding\n"</span>, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c Coder</span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *Gopher</span><br><span class="line">fmt.Println(g == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">c = g</span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">"c: %T, %v\n"</span>, c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">c: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">c: *main.Gopher, &lt;nil&gt;</span><br></pre></td></tr></table></figure><p>一开始，<code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p><p>【引申2】<br>来看一个例子，看一下它的输出：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"MyError"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := Process()</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(err == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err *MyError = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</p><p>【引申3】如何打印出接口的动态类型和值？</p><p>直接看代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">itab, data <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = (*<span class="keyword">int</span>)(&amp;x)</span><br><span class="line"></span><br><span class="line">ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">fmt.Println(ia, ib, ic)</span><br><span class="line"></span><br><span class="line">fmt.Println(*(*<span class="keyword">int</span>)(unsafe.Pointer(ic.data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里直接定义了一个 <code>iface</code> 结构体，用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</p><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 <code>*int</code>；最后，c 的动态值为 5。</p><h1 id="5-编译器自动检测类型是否实现接口"><a href="#5-编译器自动检测类型是否实现接口" class="headerlink" title="5. 编译器自动检测类型是否实现接口"></a>5. 编译器自动检测类型是否实现接口</h1><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p><p>来看一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span></span><br><span class="line"><span class="comment">return</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 *myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 myWriter 类型是否实现了 io.Writer 接口</span></span><br><span class="line">    <span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">6</span>: cannot use (*myWriter)(<span class="literal">nil</span>) (<span class="keyword">type</span> *myWriter) as <span class="keyword">type</span> io.Writer in assignment:</span><br><span class="line">*myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">6</span>: cannot use myWriter literal (<span class="keyword">type</span> myWriter) as <span class="keyword">type</span> io.Writer in assignment:</span><br><span class="line">myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure><p>报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</p><p>解除注释后，运行程序不报错。</p><p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p><p>总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ io.Writer = (*myWriter)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-接口的构造过程是怎样的"><a href="#6-接口的构造过程是怎样的" class="headerlink" title="6. 接口的构造过程是怎样的"></a>6. 接口的构造过程是怎样的</h1><p>我们已经看过了 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p><p>为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。</p><p>来看一个示例代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(qcrao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>得到 main 函数的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0</span><br><span class="line">0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (./src/main.go:30) JLS     157</span><br><span class="line">0x0013 00019 (./src/main.go:30) SUBQ    $80, SP</span><br><span class="line">0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)</span><br><span class="line">0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)</span><br><span class="line">0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)</span><br><span class="line">0x003f 00063 (./src/main.go:31) PCDATA  $0, $0</span><br><span class="line">0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)</span><br><span class="line">0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX</span><br><span class="line">0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX</span><br><span class="line">0x004e 00078 (./src/main.go:33) TESTQ   CX, CX</span><br><span class="line">0x0051 00081 (./src/main.go:33) JEQ     87</span><br><span class="line">0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX</span><br><span class="line">0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX</span><br><span class="line">0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)</span><br><span class="line">0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)</span><br><span class="line">0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)</span><br><span class="line">0x008e 00142 (./src/main.go:33) PCDATA  $0, $1</span><br><span class="line">0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)</span><br><span class="line">0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP</span><br><span class="line">0x0098 00152 (./src/main.go:34) ADDQ    $80, SP</span><br><span class="line">0x009c 00156 (./src/main.go:34) RET</span><br><span class="line">0x009d 00157 (./src/main.go:34) NOP</span><br><span class="line">0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1</span><br><span class="line">0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a2 00162 (./src/main.go:30) JMP     0</span><br></pre></td></tr></table></figure><p>我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>10-14</td><td>构造调用 <code>runtime.convT2I64(SB)</code> 的参数</td></tr></tbody></table><p>我们来看下这个函数的参数形式：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</p><p>第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</p><p>我们从生成的汇编找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  </span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              </span><br><span class="line">        rel 0+8 t=1 type.&quot;&quot;.Person+0</span><br><span class="line">        rel 8+8 t=1 type.&quot;&quot;.Student+0</span><br></pre></td></tr></table></figure><p><code>size=40</code> 大小为40字节，回顾一下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter  *interfacetype <span class="comment">// 8字节</span></span><br><span class="line">_type  *_type <span class="comment">// 8字节</span></span><br><span class="line">link   *itab <span class="comment">// 8字节</span></span><br><span class="line">hash   <span class="keyword">uint32</span> <span class="comment">// 4字节</span></span><br><span class="line">bad    <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">inhash <span class="keyword">bool</span>   <span class="comment">// 1字节</span></span><br><span class="line">unused [<span class="number">2</span>]<span class="keyword">byte</span> <span class="comment">// 2字节</span></span><br><span class="line">fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized // 8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code> 实际上是 <code>itab</code> 的 <code>hash</code> 值，这在判断两个类型是否相同的时候会用到。</p><p>下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code> 里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</p><p>第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>15</td><td>调用 <code>runtime.convT2I64(SB)</code></td></tr></tbody></table><p>具体看下代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I64</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">t := tab._type</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> *(*<span class="keyword">uint64</span>)(elem) == <span class="number">0</span> &#123;</span><br><span class="line">x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = mallocgc(<span class="number">8</span>, t, <span class="literal">false</span>)</span><br><span class="line">*(*<span class="keyword">uint64</span>)(x) = *(*<span class="keyword">uint64</span>)(elem)</span><br><span class="line">&#125;</span><br><span class="line">i.tab = tab</span><br><span class="line">i.data = x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码比较简单，把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>17</td><td>把 <code>i.tab</code> 赋给 <code>CX</code></td></tr><tr><td>18</td><td>把 <code>i.data</code> 赋给 <code>AX</code></td></tr><tr><td>19-21</td><td>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code> 函数的参数</td></tr></tbody></table><p>后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了，不再赘述。</p><p>这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p><p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p><p>这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter <span class="keyword">uintptr</span></span><br><span class="line">_type <span class="keyword">uintptr</span></span><br><span class="line">link <span class="keyword">uintptr</span></span><br><span class="line">hash  <span class="keyword">uint32</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> qcrao = Person(Student&#123;age: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">iface := (*iface)(unsafe.Pointer(&amp;qcrao))</span><br><span class="line">fmt.Printf(<span class="string">"iface.tab.hash = %#x\n"</span>, iface.tab.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p><p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值，非常妙！你也可以自己动手试一下。</p><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface.tab.hash = 0xd4209fda</span><br></pre></td></tr></table></figure><p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使我把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<code>hash</code> 值只和他的字段、方法相关。</p><h1 id="7-类型转换和断言的区别"><a href="#7-类型转换和断言的区别" class="headerlink" title="7. 类型转换和断言的区别"></a>7. 类型转换和断言的区别</h1><p>我们知道，Go 语言中不允许隐式类型转换，也就是说 <code>=</code> 两边，不允许出现类型不相同的变量。</p><p><code>类型转换</code>、<code>类型断言</code>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p><blockquote><p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">f = <span class="keyword">float64</span>(i)</span><br><span class="line">fmt.Printf(<span class="string">"%T, %v\n"</span>, f, f)</span><br><span class="line"></span><br><span class="line">f = <span class="number">10.8</span></span><br><span class="line">a := <span class="keyword">int</span>(f)</span><br><span class="line">fmt.Printf(<span class="string">"%T, %v\n"</span>, a, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// s := []int(i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码里，我定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之前相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p><p>如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (type int) to type []int</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>前面说过，因为空接口 <code>interface{}</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><p>断言的语法为：</p><blockquote><p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言<br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言</p></blockquote><p>类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。</p><p>还是来看一个简短的例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">s := i.(Student)</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure><p>直接 <code>panic</code> 了，这是因为 <code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败。这里直接发生了 <code>panic</code>，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br><span class="line">s, ok := i.(Student)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使断言失败也不会 <code>panic</code>。</p><p>断言其实还有另一种形式，就是用在利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><p>代码示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var i interface&#123;&#125; = new(Student)</span></span><br><span class="line"><span class="comment">//var i interface&#123;&#125; = (*Student)(nil)</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;i, i)</span><br><span class="line"></span><br><span class="line">judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judge</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">fmt.Printf(<span class="string">"nil type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Student:</span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">fmt.Printf(<span class="string">"Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *Student:</span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">fmt.Printf(<span class="string">"*Student type[%T] %v\n"</span>, v, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%p %v\n"</span>, &amp;v, v)</span><br><span class="line">fmt.Printf(<span class="string">"unknow\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc4200701b0 [Name: ], [Age: 0]</span><br><span class="line">0xc4200701d0 [Name: ], [Age: 0]</span><br><span class="line">0xc420080020 [Name: ], [Age: 0]</span><br><span class="line">*Student type[*main.Student] [Name: ], [Age: 0]</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">0xc42000c030 &lt;nil&gt;</span><br><span class="line">*Student type[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1e0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">nil type[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure><p>对于第一行语句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure><p><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</p><p>对于第二行语句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = (*Student)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这里想说明的其实是 <code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</p><p>最后一行语句：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p><p>【引申1】<br><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</p><p>再来看一个简短的例子，比较简单，不要紧张：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s = Student&#123;</span><br><span class="line">Name: <span class="string">"qcrao"</span>,</span><br><span class="line">Age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure><p>增加一个 <code>String()</code> 方法的实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"[Name: %s], [Age: %d]"</span>, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure><p>按照我们自定义的方法来打印了。</p><p>【引申2】<br>针对上面的例子，如果改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s *Student) String() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><blockquote><p>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</p></blockquote><p>所以， <code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时，通过</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure><p>均可以按照自定义的格式来打印。</p><p>如果 <code>Student</code> 结构体定义了接受者类型是指针类型的 <code>String()</code> 方法时，只有通过</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure><p>才能按照自定义的格式打印。</p><h1 id="8-接口转换的原理"><a href="#8-接口转换的原理" class="headerlink" title="8. 接口转换的原理"></a>8. 接口转换的原理</h1><p>通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>interfacetype</code> 和 实体类型的类型 <code>_type</code>，这两者都是 <code>iface</code> 的字段 <code>itab</code> 的成员。也就是说生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</p><blockquote><p>&lt;interface 类型， 实体类型&gt; -&gt;itable</p></blockquote><p>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</p><p>例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</p><p>这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。</p><p>直接来看一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">code()</span><br><span class="line">run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</span><br><span class="line">run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Gopher)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c coder = Gopher&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r runner</span><br><span class="line">r = c</span><br><span class="line">fmt.Println(c, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释下上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</p><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure><p>得到 main 函数的汇编命令，可以看到： <code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，看下它的源代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">tab := i.tab</span><br><span class="line"><span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">r.tab = tab</span><br><span class="line">r.data = i.data</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">r.data = i.data</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</p><p>我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code> 组成。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p><p>因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 inter, typ 计算出 hash 值</span></span><br><span class="line">h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line"><span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line"><span class="comment">// common case will be no lock contention.</span></span><br><span class="line"><span class="keyword">var</span> m *itab</span><br><span class="line"><span class="keyword">var</span> locked <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> locked = <span class="number">0</span>; locked &lt; <span class="number">2</span>; locked++ &#123;</span><br><span class="line"><span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历哈希表的一个 slot</span></span><br><span class="line"><span class="keyword">for</span> m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != <span class="literal">nil</span>; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span></span><br><span class="line"><span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> locked != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;ifaceLock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 hash 表中没有找到 itab，那么新生成一个 itab</span></span><br><span class="line">m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到全局的 hash 表中</span></span><br><span class="line">additab(m, <span class="literal">true</span>, canfail)</span><br><span class="line">unlock(&amp;ifaceLock)</span><br><span class="line"><span class="keyword">if</span> m.bad &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结一下：getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p><p>这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。 </p><p>再来看一下 <code>additab</code> 函数的代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">inter := m.inter</span><br><span class="line">typ := m._type</span><br><span class="line">x := typ.uncommon()</span><br><span class="line"></span><br><span class="line"><span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line"><span class="comment">// and interface names are unique,</span></span><br><span class="line"><span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line">    <span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// inter 和 typ 的方法都按方法名称进行了排序</span></span><br><span class="line">    <span class="comment">// 并且方法名都是唯一的。所以循环的次数是固定的</span></span><br><span class="line">    <span class="comment">// 只用循环 O(ni+nt)，而非 O(ni*nt)</span></span><br><span class="line">ni := <span class="built_in">len</span>(inter.mhdr)</span><br><span class="line">nt := <span class="keyword">int</span>(x.mcount)</span><br><span class="line">xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">i := &amp;inter.mhdr[k]</span><br><span class="line">itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">name := inter.typ.nameOff(i.name)</span><br><span class="line">iname := name.name()</span><br><span class="line">ipkg := name.pkgPath()</span><br><span class="line"><span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">ipkg = inter.pkgpath.name()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="comment">// 检查方法名字是否一致</span></span><br><span class="line"><span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">pkgPath := tname.pkgPath()</span><br><span class="line"><span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line"><span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取函数地址，并加入到itab.fun数组中</span></span><br><span class="line">ifn := typ.textOff(t.ifn)</span><br><span class="line">*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> nextimethod</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        </span><br><span class="line">m.bad = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">nextimethod:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !locked &#123;</span><br><span class="line">throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    <span class="comment">// 加到Hash Slot链表中</span></span><br><span class="line">m.link = hash[h]</span><br><span class="line">m.inhash = <span class="literal">true</span></span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p><p>求 hash 值的函数比较简单：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">h := inter.typ.hash</span><br><span class="line">h += <span class="number">17</span> * typ.hash</span><br><span class="line"><span class="keyword">return</span> h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashSize</code> 的值是 1009。</p><p>更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p><blockquote><ol><li>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</li></ol></blockquote><h1 id="9-如何用-interface-实现多态"><a href="#9-如何用-interface-实现多态" class="headerlink" title="9. 如何用 interface 实现多态"></a>9. 如何用 interface 实现多态</h1><p><code>Go</code> 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p><p>多态是一种运行期的行为，它有以下几个特点：</p><blockquote><ol><li>一种类型具有多种类型的能力</li><li>允许不同的对象对同一消息做出灵活的反应</li><li>以一种通用的方式对待使用的对象</li><li>非动态语言必须通过继承和接口的方式来实现</li></ol></blockquote><p>看一个实现了多态的代码例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">qcrao := Student&#123;age: <span class="number">18</span>&#125;</span><br><span class="line">whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">growUp(&amp;qcrao)</span><br><span class="line">fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">stefno := Programmer&#123;age: <span class="number">100</span>&#125;</span><br><span class="line">whatJob(stefno)</span><br><span class="line"></span><br><span class="line">growUp(stefno)</span><br><span class="line">fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span> &#123;</span><br><span class="line">p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">job()</span><br><span class="line">growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Student)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I am a student."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Student)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">struct</span> &#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">job</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I am a programmer."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Programmer)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 程序员老得太快 ^_^</span></span><br><span class="line">p.age += <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure><p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p><p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whatJob</span><span class="params">(p Person)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">growUp</span><span class="params">(p Person)</span></span></span><br></pre></td></tr></table></figure><p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p><p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p><p>运行一下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;19&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;100&#125;</span><br></pre></td></tr></table></figure><h1 id="10-Go-接口与-C-接口有何异同"><a href="#10-Go-接口与-C-接口有何异同" class="headerlink" title="10. Go 接口与 C++ 接口有何异同"></a>10. Go 接口与 C++ 接口有何异同</h1><p>接口定义了一种规范，描述了类的行为和功能，而不做具体实现。</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">string</span> name;      <span class="comment">// 名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【包含反射、接口等源码分析】<a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27055513</a></p><p>【虚函数表和C++的区别】<a href="https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q</a></p><p>【具体类型向接口赋值】<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html</a></p><p>【Go夜读群的讨论】<a href="https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md" target="_blank" rel="noopener">https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md</a></p><p>【廖雪峰 鸭子类型】<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000</a></p><p>【值类型和指针类型，iface源码】<a href="https://www.jianshu.com/p/5f8ecbe4f6af" target="_blank" rel="noopener">https://www.jianshu.com/p/5f8ecbe4f6af</a></p><p>【总体说明itab的生成方式、作用】<a href="http://www.codeceo.com/article/go-interface.html" target="_blank" rel="noopener">http://www.codeceo.com/article/go-interface.html</a></p><p>【conv系列函数的作用】<a href="https://blog.csdn.net/zhonglinzhang/article/details/85772336" target="_blank" rel="noopener">https://blog.csdn.net/zhonglinzhang/article/details/85772336</a></p><p>【convI2I itab作用】<a href="https://www.jianshu.com/p/a5e99b1d50b1" target="_blank" rel="noopener">https://www.jianshu.com/p/a5e99b1d50b1</a></p><p>【interface 源码解读 很不错 包含反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p><p>【what why how思路来写interface】<a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">http://legendtkl.com/2017/06/12/understanding-golang-interface/</a></p><p>【有汇编分析，不错】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p><p>【第一幅图可以参考 gdb调试】<a href="https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/</a></p><p>【类型转换和断言】<a href="https://my.oschina.net/goal/blog/194308" target="_blank" rel="noopener">https://my.oschina.net/goal/blog/194308</a></p><p>【interface 和 nil】<a href="https://my.oschina.net/goal/blog/194233" target="_blank" rel="noopener">https://my.oschina.net/goal/blog/194233</a></p><p>【函数和方法】<a href="https://www.jianshu.com/p/5376e15966b3" target="_blank" rel="noopener">https://www.jianshu.com/p/5376e15966b3</a></p><p>【反射】<a href="https://flycode.co/archives/267357" target="_blank" rel="noopener">https://flycode.co/archives/267357</a></p><p>【接口特点列表】<a href="https://segmentfault.com/a/1190000011451232" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011451232</a></p><p>【interface 全面介绍，包含C++对比】<a href="https://www.jianshu.com/p/b38b1719636e" target="_blank" rel="noopener">https://www.jianshu.com/p/b38b1719636e</a></p><p>【Go四十二章经 interface】<a href="https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md" target="_blank" rel="noopener">https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md</a></p><p>【对Go接口的反驳，有说到接口的定义】<a href="http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html" target="_blank" rel="noopener">http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html</a></p><p>【gopher 接口】<a href="http://fuxiaohei.me/2017/4/22/gopherchina-2017.html" target="_blank" rel="noopener">http://fuxiaohei.me/2017/4/22/gopherchina-2017.html</a></p><p>【译文 还不错】<a href="https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA</a></p><p>【infoQ 文章】<a href="https://www.infoq.cn/article/go-interface-talk" target="_blank" rel="noopener">https://www.infoq.cn/article/go-interface-talk</a></p><p>【Go接口详解】<a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27055513</a></p><p>【Go interface】<a href="https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="noopener">https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/</a></p><p>【getitab源码说明】<a href="https://www.twblogs.net/a/5c245d59bd9eee16b3db561d" target="_blank" rel="noopener">https://www.twblogs.net/a/5c245d59bd9eee16b3db561d</a></p><p>【浅显易懂】<a href="https://yami.io/golang-interface/" target="_blank" rel="noopener">https://yami.io/golang-interface/</a></p><p>【golang io包的妙用】<a href="https://www.jianshu.com/p/8c33f7c84509" target="_blank" rel="noopener">https://www.jianshu.com/p/8c33f7c84509</a></p><p>【探索C++与Go的接口底层实现】<a href="https://www.jianshu.com/p/073c09a05da7" target="_blank" rel="noopener">https://www.jianshu.com/p/073c09a05da7</a><br><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</a></p><p>【汇编层面】<a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">http://xargin.com/go-and-interface/</a></p><p>【有图】<a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">https://i6448038.github.io/2018/10/01/Golang-interface/</a></p><p>【图】<a href="https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA</a></p><p>【英文开源书】<a href="https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md" target="_blank" rel="noopener">https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md</a></p><p>【曹大的翻译】<a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">http://xargin.com/go-and-interface/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次文章依然很长，基本上涵盖了 &lt;code&gt;interface&lt;/code&gt; 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到&lt;code&gt;反射&lt;/code&gt;，当然，后面会单独写一篇关于&lt;co
      
    
    </summary>
    
      <category term="编程语言" scheme="https://qcrao.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://qcrao.com/tags/golang/"/>
    
  </entry>
  
</feed>
