<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>qcrao 的博客</title><link>https://qcrao.com/</link><description>Recent content on qcrao 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 13 Nov 2022 12:17:00 +0800</lastBuildDate><atom:link href="https://qcrao.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Go map 竟然也会发生内存泄露？</title><link>https://qcrao.com/post/memory-leak-of-go-map/</link><pubDate>Sun, 13 Nov 2022 12:17:00 +0800</pubDate><guid>https://qcrao.com/post/memory-leak-of-go-map/</guid><description>Go 程序运行时，有些场景下会导致进程进入某个“高点”，然后就再也下不来了。 比如，多年前曹大写过的一篇文章讲过，在做活动时线上涌入的大流量把 goroutine 数抬升了不少，流量恢复之后 goroutine 数也没降下来，导致 GC 的压力升高，总体的 CPU 消耗也较平时上升了 2 个点左右。 有一个 issue 讨论为什么 allgs（runtime</description></item><item><title>你说的下游是 upstream 吧？</title><link>https://qcrao.com/post/what-is-upstream-downstream/</link><pubDate>Sun, 31 Jul 2022 18:56:00 +0800</pubDate><guid>https://qcrao.com/post/what-is-upstream-downstream/</guid><description>工作中，有一些术语比较容易混淆，聊半天，最后发现双方对术语的理解不一致。这个时候用英文原本的表达或者换一种方式来表述能让沟通更顺畅。 像我们经常说的『上下游』便是经常发生混淆的一对名词。 以前，我经常说『梳理一下我们依赖的下游』，后来发现这种说法是错误的。正确的是：梳理一下我们依赖的</description></item><item><title>将博客迁移到了 Cloudflare Pages</title><link>https://qcrao.com/post/migrate-blog-to-cloudflare-pages/</link><pubDate>Tue, 19 Jul 2022 22:20:00 +0800</pubDate><guid>https://qcrao.com/post/migrate-blog-to-cloudflare-pages/</guid><description>上个月把博客从 hexo 迁移到了 hugo，博客数据、发布流程全部托管到 github。之后把之前写的一篇《那些年曹大写的文章》搬了过来，其他文章暂时下线了。 上周在折腾博客 css 的时候，aofei 说不如迁移到 Cloudflare，还能全球 cdn 加速。于是又动手迁移到 Cloudflare Pages，顺便又修改了一些 cs</description></item><item><title>那些年曹大写的文章</title><link>https://qcrao.com/post/blogs-written-by-xargin/</link><pubDate>Wed, 22 Jun 2022 09:37:00 +0800</pubDate><guid>https://qcrao.com/post/blogs-written-by-xargin/</guid><description>某天晚上看到曹大在群里指点江山，折服。感叹为何曹大如此渊博，遂决定从头到尾研读完他所有的博文。 前后共花了一个月的时间，今天终于读完了（2020-11-24~2020-12-26），总共 118 篇。从 15 年 10 月 31 日开始的第一篇，到今天，总共写了 5 年多的时间。基本上每半个月产出一篇，非常稳定</description></item><item><title>最重要的是内容</title><link>https://qcrao.com/post/content-is-more-important/</link><pubDate>Tue, 21 Jun 2022 22:00:00 +0800</pubDate><guid>https://qcrao.com/post/content-is-more-important/</guid><description>最近，看曹大依然在坚持固定频率发新的文章，非常佩服。今年是我写博客的第四年，因为各种原因，上半年基本没有发表新东西，非常惭愧。养成一个好习惯很难，破坏却很容易。 这次将博客改用 hugo 搭建。最早 qcrao.com 是用 hexo 在 mac 渲染，然后将 public 推到 github 上的 qcrao.github.io。坏外是需要在 mac 上安装一堆前</description></item><item><title>为梦想而努力！</title><link>https://qcrao.com/readings/</link><pubDate>Tue, 21 Jun 2022 00:13:27 +0000</pubDate><guid>https://qcrao.com/readings/</guid><description>向大佬们看齐，见贤思齐焉！这是他们的书单： 大佬 书单地址 曹大 https://xargin.com/readings/ 芮神 https://xiaorui.cc/archives/3342 技术类 《MySQL 必知必会》100%，工作以后就没怎么参与用到 MySQL 的项目，基本的 SQL 语法都有点虚，用这本书重新复习一下。本书只讲了基本的语法，也就入个门的水平，读完找找感觉。『必知必会』这个系列的书都是比较容易读懂的，</description></item><item><title>关于我</title><link>https://qcrao.com/about/</link><pubDate>Tue, 21 Jun 2022 00:13:27 +0000</pubDate><guid>https://qcrao.com/about/</guid><description>一线互联网码农，热衷探究技术背后的原理。喜欢情景喜剧、相声、小品，阅读，终生学习者。 其他平台 Github：https://github.com/qcrao/Go-Questions/ 博客园：https://www.cnblogs.com/qcrao-2018/ 知乎主页：https</description></item><item><title>分享列表</title><link>https://qcrao.com/ishare/</link><pubDate>Tue, 21 Jun 2022 00:13:27 +0000</pubDate><guid>https://qcrao.com/ishare/</guid><description>公开的技术分享是必须的，也是必要的。 目前为止，我做过的公开技术分享都是关于 Golang 主题，且都是在『Go 夜读』这个平台。 主题 作者 观看链接 课件 Go defer 和逃逸分析 饶全成 YouTuBe, Bilibili - Go map 源码阅读 饶全成 YouTuBe, Bilibili - Go Scheduler 源码阅读 饶全成 YouTuBe, Bilibili -</description></item><item><title>写 Go 时如何优雅地查文档</title><link>https://qcrao.com/post/look-up-go-doc-gracefully/</link><pubDate>Thu, 09 Sep 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/look-up-go-doc-gracefully/</guid><description>某天写代码时发现自己对 IDE 的依赖非常深，如果没了 Goland 就不会写代码了，心里为之一惊。 Goland 的自动补全功能已经是必需品了，只要打出相关的几个字符，不管是变量名还是函数调用，都能帮你直接补全。我们只需要往相应的位置填东西就行了。 进而又想到，当补全功能缺失或者暂时失灵的情况下，该如何快速地查出某</description></item><item><title>曹大带我学 Go（11）—— 从 map 的 extra 字段谈起</title><link>https://qcrao.com/post/talk-about-map-extra-field/</link><pubDate>Sun, 08 Aug 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/talk-about-map-extra-field/</guid><description>熟悉 map 结构体的读者应该知道，hmap 由很多 bmap（bucket） 构成，每个 bmap 都保存了 8 个 key/value 对： 有时落在同一个 bmap 中的 key/value 太多了，超过了 8 个，就会由溢出 bmap 来承接，即 overflow bmap（后面我们叫它 bucket）。溢出的 bucket 和原来的 bucket 形成一个“拉链”。 对于这些 overflow 的 bucket，在 hmap 结构体和 bmap 结构</description></item><item><title>曹大带我学 Go（10）—— 如何给 Go 提性能优化的 pr</title><link>https://qcrao.com/post/go-tls-pr-by-xargin/</link><pubDate>Tue, 03 Aug 2021 23:43:04 +0800</pubDate><guid>https://qcrao.com/post/go-tls-pr-by-xargin/</guid><description>之前写了一篇《成为 Go Contributor》 的文章，讲了如何给 Go 提一个 typo 的 pr，以此熟悉整个流程。当然，离真正的 Contributor 还差得远。 开课前曹大在 Go 夜读上讲了他给 Go 提的一个关于 tls 的性能优化，课上又细讲了下，本文就带大家来学习下他优化了啥以及如何看优化效果。 第一次提的 pr 在这里，之后又挪到了一</description></item><item><title>曹大带我学 Go（9）—— 开始积累自己的工具库</title><link>https://qcrao.com/post/start-to-build-up-personal-tools/</link><pubDate>Wed, 21 Jul 2021 23:42:31 +0800</pubDate><guid>https://qcrao.com/post/start-to-build-up-personal-tools/</guid><description>不知道你有没有这样的经验：看了很多计算机相关的书，觉得自己懂得很多，但是一遇到实际问题，就不会解。 再看身边的老司机，执行几行命令，看了几个指标，就准确地定位问题了。他可能也没看那么多理论，但实战能力确实强，心里一下子就失衡了。 这其中有很多原因，我认为其中有一个比较重要的就是：工具</description></item><item><title>曹大带我学 Go（8）—— 一个 metrics 打点引发的事故</title><link>https://qcrao.com/post/accident-by-a-metric/</link><pubDate>Mon, 19 Jul 2021 23:28:24 +0800</pubDate><guid>https://qcrao.com/post/accident-by-a-metric/</guid><description>最近线上事故频发，搞得焦头烂额，但是能用上跟曹大学的知识并定位出了问题，还是值得高兴一把的。毕竟“打破砂锅问到底”，“定位出根因”一直是技术人的优良品质。 虽然我们总是逃不过事故驱动开发的魔咒，但吃一堑长一智，看别人的事故，学到的是自己的能力。 现象 一个平凡的午高峰，服务在全量上线的</description></item><item><title>曹大带我学 Go（7）—— 如何优雅地指定配置项</title><link>https://qcrao.com/post/how-to-use-functional-options-pattern/</link><pubDate>Thu, 15 Jul 2021 23:28:02 +0800</pubDate><guid>https://qcrao.com/post/how-to-use-functional-options-pattern/</guid><description>最近一个年久失修的库导致了线上事故，不得不去做一些改进。 这个陈年库的作用是调用第三方的 RPC 拿一些比较重要的配置，业务代码中有段逻辑会根据读到的配置调用不同端的下游。如果没拿到配置，就会默认地调一个兜底下游。恰好这个兜底下游最近新上了一些逻辑，不兼容这种跨端调用，直接把它打挂了。 先抛</description></item><item><title>曹大带我学 Go（6）—— 技术之外</title><link>https://qcrao.com/post/out-of-tech/</link><pubDate>Thu, 10 Jun 2021 00:10:07 +0800</pubDate><guid>https://qcrao.com/post/out-of-tech/</guid><description>这篇文章主要来讲一下怎么做动画。 其实只要掌握几个核心的要点，就可以学会怎么用 Figma 做动画了。 我们想一下小时候看的那种胶片电影： 每一张胶片上的影像都是静止的，但是当胶片连续滚动时，静止的图片就变成了连续的视频。 或者想像一下小时候我们看的那种武打的小人书，连着翻页，就能看到一个连续的打斗</description></item><item><title>曹大带我学 Go（5）—— 哪来里的 goexit？</title><link>https://qcrao.com/post/where-is-goexit-from/</link><pubDate>Mon, 07 Jun 2021 23:26:36 +0800</pubDate><guid>https://qcrao.com/post/where-is-goexit-from/</guid><description>有同学在用 dlv 调试时看到了令人不解的 goexit：goexit 函数是啥，为啥 go fun(){}() 的上层是它？看着像是一个“退出”函数，为什么会出现在最上层？ 其实如果看过 pprof 的火焰图，也会经常看到 goexit 这个函数。 我们来个例子重现一下： package main import &amp;#34;time&amp;#34; func main() { go func () { println(&amp;#34;hello world&amp;#34;) }() time.Sleep(10*time.Minute) } 启动 dlv 调试，并分别在不同的地方打上断点：</description></item><item><title>曹大带我学 Go（4）—— 初始 ast 的威力</title><link>https://qcrao.com/post/getting-to-know-the-power-of-ast/</link><pubDate>Tue, 01 Jun 2021 23:26:17 +0800</pubDate><guid>https://qcrao.com/post/getting-to-know-the-power-of-ast/</guid><description>抽象语法树是编译过程中的一个中间产物，一般简单了解一下就行了。但我们可以把 Go 语言的整个 parser 和 ast 包直接拿来用，在一些场景下有很大的威力。 什么是 ast 呢，我从维基百科上摘录了一段： 在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代</description></item><item><title>曹大带我学 Go（3）—— 如何用汇编打同事的脸</title><link>https://qcrao.com/post/how-to-get-asm-code-of-go/</link><pubDate>Thu, 27 May 2021 23:21:54 +0800</pubDate><guid>https://qcrao.com/post/how-to-get-asm-code-of-go/</guid><description>今天介绍几个常用的查看 Go 汇编代码、调试 Go 程序的命令和工具，既可以在平时和同事、网友抬杠时使用，还能在关键时刻打他们的脸。 比如，有同事说这段代码： package main type Student struct { Class int } func main() { var a = &amp;amp;Student{1} println(a) } 的执行效率要高于下面这段代码： package main type Student struct { Class int } func main() { var a = Student{1} var b = &amp;amp;a println(b) } 并且给你讲了一通道理，你好</description></item><item><title>曹大带我学 Go（2）—— 迷惑的 goroutine 执行顺序</title><link>https://qcrao.com/post/confusing-goroutine-running-orders/</link><pubDate>Fri, 21 May 2021 14:38:54 +0800</pubDate><guid>https://qcrao.com/post/confusing-goroutine-running-orders/</guid><description>上一篇文章我们讲了 Go 调度的本质是一个生产-消费流程。 生产端是正在运行的 goroutine 执行 go func(){}() 语句生产出 goroutine 并塞到三级队列中去。 消费端则是 Go 进程中的 m 在不断地执行调度循环，从三级队列中拿到 goroutine 来运行。 今天我们来通过 2 个实际的代码例子来看看 goroutine 的执行顺序是怎样的。 第一个例子 首先来看第一个例子： package main import (</description></item><item><title>曹大带我学 Go（1）—— Go 调度的本质</title><link>https://qcrao.com/post/go-schedule-under-the-hood/</link><pubDate>Thu, 20 May 2021 08:13:00 +0800</pubDate><guid>https://qcrao.com/post/go-schedule-under-the-hood/</guid><description>首先抛出本文的结论：Go 调度的本质是一个生产-消费流程。 生产者-消费者模型 我们平时用 Go 最爽的一点莫过于用一句 go func(){}() 就启动了一个 goroutine 来并发地执行任务。这比用 C/C++ 启动一个线程并发地去执行任务方便太多。这句代码实际上就生产出了一个 goroutine，并进入可运行队列，等待 m 来找它从而可以得到</description></item><item><title>深度解密 Go 语言之基于信号的抢占式调度</title><link>https://qcrao.com/post/diving-into-preempt-by-signal/</link><pubDate>Wed, 12 May 2021 23:12:56 +0800</pubDate><guid>https://qcrao.com/post/diving-into-preempt-by-signal/</guid><description>不知道大家在实际工作中有没有遇到过老版本 Go 调度器的坑：死循环导致程序“死机”。我去年就遇到过，并且搞出了一起 P0 事故，还写了篇弱智的找 bug 文章。 识别事故的本质，并且用一个非常简单的示例展示出来，是功力的一种体现。那次事故的原因可以简化成如下的 demo： 我来简单解释一下上面这个程序。在</description></item><item><title>深度阅读之《Mastering Go》</title><link>https://qcrao.com/post/mastering-go-reading-notes/</link><pubDate>Mon, 19 Apr 2021 23:07:24 +0000</pubDate><guid>https://qcrao.com/post/mastering-go-reading-notes/</guid><description>写在前面：这本书前前后后花了挺长时间，去年 11 月份就开始读了，中间又断了，直到最近才捡起来看完。 本书讲得内容非常全面，语言也很顺畅，生词非常少，并且内容没有太大难度，看起来比较过瘾，算是全面复习一下 Go 语言。如果你想开始练习阅读英文书，这本将是一个非常好的开始。 下面是阅读过程中记录的</description></item><item><title>喜提 Go Contributor</title><link>https://qcrao.com/post/become-a-go-typo-contributor/</link><pubDate>Tue, 30 Mar 2021 22:44:48 +0800</pubDate><guid>https://qcrao.com/post/become-a-go-typo-contributor/</guid><description>上次写了一篇《喜提 Redir Contributor》，内容是给欧神写的一个短网址小工具加了一个输出结果排序的功能，凑了个热闹。结果有朋友看成了 redis contributor，并没有那么牛逼~😛 但这次真的是给 golang/go 提交了代码，喜提 Go Contributor。 当然因为是第一次，只是改了几个 typos，不</description></item><item><title>Go 命令 『go build -X』 的妙用</title><link>https://qcrao.com/post/ingenious-use-of-go-build-x/</link><pubDate>Mon, 15 Mar 2021 22:08:04 +0800</pubDate><guid>https://qcrao.com/post/ingenious-use-of-go-build-x/</guid><description>不知道大家还记不记得，上次发了一篇关于 panic 检测机器人的文章，原理非常简单，简单回顾一下： 业务服务在 recover 函数里通过 HTTP 请求的方式向机器人上报 panic 栈信息。 机器人解析出 panic 栈里的代码行号，调用 gitlab 接口拿到该行代码的提交人、提交日期等信息。 当然，后面我又给机器人增加了一些其他的功能，例如自动拉群，自</description></item><item><title>Go channel 的妙用</title><link>https://qcrao.com/post/ingenious-use-of-channel/</link><pubDate>Thu, 04 Feb 2021 22:02:17 +0800</pubDate><guid>https://qcrao.com/post/ingenious-use-of-channel/</guid><description>昨天在内网上看到一篇讲数据库连接的文章，列出了一些 sql 包的一些源码，我注意到其中取用、归还连接的方式非常有意思——通过临时创建的 channel 来传递连接。 在 sql.DB 结构体里，使用 freeConn 字段来表示当前所有的连接，也就是一个连接池。 type DB struct { freeConn []*driverConn } 当需要拿连接的时候，从 freeConn 中取出第一个元素： conn := db.freeConn[0] copy(db.freeConn, db.freeConn[1:]) db.freeConn = db.freeConn[:numFree-1] conn.inUse =</description></item><item><title>事故现场之依赖了不该依赖的 host ip</title><link>https://qcrao.com/post/error-depend-on-host-ip/</link><pubDate>Fri, 29 Jan 2021 10:18:55 +0800</pubDate><guid>https://qcrao.com/post/error-depend-on-host-ip/</guid><description>昨天，组里服务遇到了一个诡异的问题，跟着看了下原因，记录在此。 先介绍背景：我们维护了两个服务，一个对外服务，承接流量，称之为主服务，主服务会调用各种第三方 RPC 服务，获取各种字段，拼在一个大的 model 上。其中有一个 RPC 服务，称之为 E 服务，是我们自己维护的，它返回一部分字段。 E 服务会定时读取规</description></item><item><title>写一个 panic blame 机器人</title><link>https://qcrao.com/post/panic-blame-robot/</link><pubDate>Mon, 11 Jan 2021 09:17:59 +0800</pubDate><guid>https://qcrao.com/post/panic-blame-robot/</guid><description>最近接手了一个“公共”服务，负责维护它的稳定性。代码库有很多人参与“维护”，其实就是各种业务方使劲往上堆逻辑。虽然入库前我会进行 CR，但多了之后，也看不过来，还有一些人自己偷摸就把代码合到 master 上去了。总之，代码质量无法得到很好的保证。 当然了，如果把合代码的权限收敛到我一个人，理论上</description></item><item><title>喜提 redir contributor</title><link>https://qcrao.com/post/become-contributor-of-redir/</link><pubDate>Mon, 16 Nov 2020 09:30:00 +0800</pubDate><guid>https://qcrao.com/post/become-contributor-of-redir/</guid><description>看多了 Go 源代码，看一看应用，尤其是比较短小且有趣的应用代码，感觉很有意思，而且举重若轻。 如果顺带修一下小的错误，成为 Contributor，那就更多了一种成就感。就像杨文前几天成为 Go Contributor 那样，从小处开始，慢慢提升技术含量，总有一天，慢慢成为真正的 Contributor，像曹大那样。</description></item><item><title>深度阅读之《Concurrency in Go》</title><link>https://qcrao.com/post/concurrency-in-go-reading-notes/</link><pubDate>Sat, 05 Sep 2020 11:45:16 +0800</pubDate><guid>https://qcrao.com/post/concurrency-in-go-reading-notes/</guid><description>作为一个终身学习者，输入和输出是必不可少的。输入多了之后，会发现很多中文文章很难读，可能还有很多错漏之处。不客气地说，输入的是垃圾，输出的只能是垃圾。 曹大经常说需要多看英文资料，包括各种新出的英文书、文章等等，这从他的书单也可以看出来。我自己的情况是：英文资料读的不多，英文技术书</description></item><item><title>《Head First 设计模式》读书笔记</title><link>https://qcrao.com/post/head-first-design-pattern-reading-notes/</link><pubDate>Sun, 10 May 2020 22:50:12 +0800</pubDate><guid>https://qcrao.com/post/head-first-design-pattern-reading-notes/</guid><description>第一章 设计模式入门 使用模式最好的方式是：”把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。” 通过一个给 Duck 类型添加 fly 功能的实例，一步步地提出解决方案。 先是使用继承，但是继承并不能很好地解决问题，因为鸭子的行为在子类里不断地改变，并且让所有的子类都有这些行为是不</description></item><item><title>深度解密 Go 语言之 sync.map</title><link>https://qcrao.com/post/dive-into-go-sync-map/</link><pubDate>Wed, 06 May 2020 09:40:56 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-sync-map/</guid><description>工作中，经常会碰到并发读写 map 而造成 panic 的情况，为什么在并发读写的时候，会 panic 呢？因为在并发读写的情况下，map 里的数据会被写乱，之后就是 Garbage in, garbage out，还不如直接 panic 了。 是什么 Go 语言原生 map 并不是线程安全的，对它进行并发读写操作的时候，需要加锁。而 sync.map 则是一种并发安全的 map，在 Go 1.9 引入。 sync.map</description></item><item><title>『���』引发的线上事故</title><link>https://qcrao.com/post/codec-accident/</link><pubDate>Mon, 27 Apr 2020 00:10:53 +0800</pubDate><guid>https://qcrao.com/post/codec-accident/</guid><description>最近遇到了一起依赖升级 + 异常数据引发的线上事故，教训惨痛，本文对此进行回故和总结。 背景 起因是我们使用的服务框架版本比较老，GC 次数的 metrics 打点一直为 0，咨询了相关同学后，决定升级框架。升级的过程中，出现了 use of internal package xxx not allowed 的报错，又咨询了一下相关同学后，尝试使用 go mod 解决。 从 go vendor 到 go mod 的升</description></item><item><title>深度解密 Go 语言之 sync.pool</title><link>https://qcrao.com/post/dive-into-go-sync-pool/</link><pubDate>Mon, 20 Apr 2020 09:34:32 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-sync-pool/</guid><description>最近在工作中碰到了 GC 的问题：项目中大量重复地创建许多对象，造成 GC 的工作量巨大，CPU 频繁掉底。准备使用 sync.Pool 来缓存对象，减轻 GC 的消耗。为了用起来更顺畅，我特地研究了一番，形成此文。本文从使用到源码解析，循序渐进，一一道来。 本文基于 Go 1.14 是什么 sync.Pool 是 sync 包下的一个组件，可以作为保存临时取还对</description></item><item><title>聊聊 g0</title><link>https://qcrao.com/post/talk-about-g0/</link><pubDate>Fri, 03 Apr 2020 15:27:15 +0800</pubDate><guid>https://qcrao.com/post/talk-about-g0/</guid><description>很多时候，当我们跟着源码去理解某种事物时，基本上可以认为是以时间顺序展开，这是编年体的逻辑。还有另一种逻辑，纪传体，它以人物为中心编排史事，使得读者更聚焦于某个人物。以一种新的视角，把所有的事情串连起来，令人大呼过瘾。今天我们试着以这样一种逻辑再看 g0。 回顾一下 Go 夜读第 78 期，关于</description></item><item><title>defer 链表如何被遍历执行</title><link>https://qcrao.com/post/how-to-traverse-defer-links/</link><pubDate>Mon, 23 Mar 2020 09:32:16 +0800</pubDate><guid>https://qcrao.com/post/how-to-traverse-defer-links/</guid><description>去年开始写文章的第一篇就是关于 defer，名字比较文艺：《Golang 之轻松化解 defer 的温柔陷阱》，还被吐槽了。因为这篇文章，到《Go 夜读》讲了一期。不过当时纯粹是应用层面的，也还没有跳进 Go 源码这个大坑，文章看着比较清新，也没有大段的源码解析。 自从听了曹大在《Go 夜读》分享的 Go 汇编，</description></item><item><title>《高性能 MySQL》读书笔记</title><link>https://qcrao.com/post/high-performance-mysql-reading-notes/</link><pubDate>Sun, 08 Mar 2020 19:17:23 +0800</pubDate><guid>https://qcrao.com/post/high-performance-mysql-reading-notes/</guid><description>第一章 MySQL 的灵活性体现在很多方面，但其中最与众不同的特性是它的存储引擎架构：将查询处理以及其他系统任务和数据的存储/提取相分离。这种设计使得我们可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。 MySQL 架构整体上分为三层：第一层处理连接、权限等；第二层包含所有核心的功能，例如</description></item><item><title>深度解密 Go 语言之 pprof</title><link>https://qcrao.com/post/dive-into-go-pprof/</link><pubDate>Sun, 10 Nov 2019 22:25:48 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-pprof/</guid><description>相信很多人都听过“雷神 3”关于性能优化的故事。在一个 3D 游戏引擎的源码里，John Carmack 将 1/sqrt(x) 这个函数的执行效率优化到了极致。 一般我们使用二分法，或者牛顿迭代法计算一个浮点数的平方根。但在这个函数里，作者使用了一个“魔数”，根本没有迭代，两步就直接算出了平方根。令人叹为观止！ 因为它是最底</description></item><item><title>Golang error 的突围</title><link>https://qcrao.com/post/golang-error-break-through/</link><pubDate>Wed, 18 Sep 2019 12:05:21 +0800</pubDate><guid>https://qcrao.com/post/golang-error-break-through/</guid><description>写过 C 的同学知道，C 语言中常常返回整数错误码（errno）来表示函数处理出错，通常用 -1 来表示错误，用 0 表示正确。 而在 Go 中，我们使用 error 类型来表示错误，不过它不再是一个整数类型，是一个接口类型： type error interface { Error() string } 它表示那些能用一个字符串就能说清的错误。 我们最常用的就是 errors.New() 函数，非常简单： //</description></item><item><title>深度解密调度器源码系列</title><link>https://qcrao.com/post/dive-into-go-scheduler-source-code/</link><pubDate>Fri, 06 Sep 2019 11:47:34 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-scheduler-source-code/</guid><description>上篇文章从全局视角讲了 Go 的调度器，其实在这个过程中，我还阅读了 Go 的源码，并作了详细的讲解。 整个系列共 10 篇文章，深度解析调度器的源码。 源码阅读系列 题目 三足鼎立 —— GPM 到底是什么？（一） 开天辟地 —— Go scheduler 初始化（二） 粉墨登场 —— main goroutine 的诞生（三） 偷天换日 —— g0 栈和用户栈如何完成切换？（四）</description></item><item><title>深度解密 Go 语言之 scheduler</title><link>https://qcrao.com/post/dive-into-go-scheduler/</link><pubDate>Mon, 02 Sep 2019 17:06:06 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-scheduler/</guid><description>好久不见，你还好吗？距离上一篇文章已经过去了一个多月了，迟迟未更新文章，我也很着急啊。 跟大家汇报一下，这段时间我在看 proc.go 的源码，其实就是调度器的源码。代码有几千行之多，不像以往的 map，channel 等等。想把这些代码都看明白，是一个庞大的工程。到今天为止，我也不敢说我都看明白了。</description></item><item><title>深度解密 Go 语言之 channel</title><link>https://qcrao.com/post/dive-into-go-channel/</link><pubDate>Mon, 22 Jul 2019 08:40:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-channel/</guid><description>大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。 上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客园登上了 48 小时阅读排行榜，并且受到了编辑推</description></item><item><title>如何打造一份优雅的简历</title><link>https://qcrao.com/post/how-to-write-resume-gracefully/</link><pubDate>Mon, 08 Jul 2019 09:00:00 +0800</pubDate><guid>https://qcrao.com/post/how-to-write-resume-gracefully/</guid><description>最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。 为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。 虽然现在不是求职的高峰期，</description></item><item><title>Go 程序是怎样跑起来的</title><link>https://qcrao.com/post/how-go-runs/</link><pubDate>Wed, 03 Jul 2019 09:42:00 +0800</pubDate><guid>https://qcrao.com/post/how-go-runs/</guid><description>刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。 在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，我第一次看到这本书的书名，就非常喜</description></item><item><title>曹大谈内存重排</title><link>https://qcrao.com/post/cch-says-memory-reorder/</link><pubDate>Mon, 17 Jun 2019 09:00:00 +0800</pubDate><guid>https://qcrao.com/post/cch-says-memory-reorder/</guid><description>写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的参考资料都在文章最后一部</description></item><item><title>深度解密 Go 语言之 context</title><link>https://qcrao.com/post/dive-into-go-context/</link><pubDate>Wed, 12 Jun 2019 09:26:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-context/</guid><description>Go 语言的 context 包短小精悍，非常适合新手学习。不论是它的源码还是实际使用，都值得投入时间去学习。 这篇文章依然想尝试全面、深入地去研究。文章相比往期而言，整体不长，希望你看完可以有所收获！ 什么是 context Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环</description></item><item><title>深度解密 Go 语言之 unsafe</title><link>https://qcrao.com/post/dive-into-go-unsafe/</link><pubDate>Mon, 03 Jun 2019 08:25:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-unsafe/</guid><description>上一篇文章我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 unsafe.Pointer 不陌生，map 对 key 进行定位的时候，大量使用。 unsafe.Pointer 位于 unsafe 包，这篇文章，我们来深入研究 unsafe 包。先说明一下，本文没有之前那么长了，你可以比较轻松地读完，这样的时候不是太多。 上次发布文章的时候，包括代码超过 5w 字，后台编辑</description></item><item><title>深度解密 Go 语言之 map</title><link>https://qcrao.com/post/dive-into-go-map/</link><pubDate>Wed, 22 May 2019 09:57:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-map/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。 什么是 map 维基百科</description></item><item><title>深度解密 Go 语言之反射</title><link>https://qcrao.com/post/dive-into-go-reflection/</link><pubDate>Tue, 07 May 2019 08:35:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-reflection/</guid><description>反射和 Interface 息息相关，而 Interface 是我们上一篇文章的内容。在开始正文前，和大家说点题外话。 上一篇关于 Interface 的文章发出后，获得了很多的关注和阅读。比如，登上了 GoCN 的每日新闻第一条： 可能是编辑者觉得这篇文章称不上“深度解密”，把标题给小小地改动了下，哈哈~~ 在博客园登上了 48 小时阅读排行榜： 在开发者头条</description></item><item><title>深度解密 Go 语言之关于 interface 的 10 个问题</title><link>https://qcrao.com/post/dive-into-go-interface/</link><pubDate>Thu, 25 Apr 2019 08:25:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-interface/</guid><description>这次文章依然很长，基本上涵盖了 interface 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到反射，当然，后面会单独写一篇关于反射的文章，这是后话。 还是希望看你在看完文章后能有所收获，有任何问题或意见建议，欢迎在文章</description></item><item><title>深度解密 Go 语言之 slice</title><link>https://qcrao.com/post/dive-into-go-slice/</link><pubDate>Tue, 02 Apr 2019 08:38:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-slice/</guid><description>Go 语言的 slice 很好用，不过也有一些坑。slice 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它。而且在我写这篇文章的过程中，发现绝大部分文章都存在一些问题，文章里会讲到，</description></item><item><title>深入 Go 的底层，带你走进一群有追求的人</title><link>https://qcrao.com/post/dive-into-go-asm/</link><pubDate>Wed, 20 Mar 2019 08:10:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-go-asm/</guid><description>上周六晚上，我参加了“Go夜读”活动，这期主要讲Go汇编语言，由滴滴大佬曹春晖大神主讲。活动结束后，我感觉打通了任督二脉。活动从晚上9点到深夜11点多，全程深度参与，大呼过瘾，以至于活动结束之后，久久不能平静。 可以说理解了Go汇编语言，就可以让我们对Go的理解上一个台阶，很多以前</description></item><item><title>图解 Go 语言内存分配</title><link>https://qcrao.com/post/graphic-go-memory-allocation/</link><pubDate>Wed, 13 Mar 2019 09:41:00 +0800</pubDate><guid>https://qcrao.com/post/graphic-go-memory-allocation/</guid><description>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。 Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread</description></item><item><title>Golang 之变量去哪儿</title><link>https://qcrao.com/post/where-go-variables-go/</link><pubDate>Fri, 01 Mar 2019 08:30:00 +0800</pubDate><guid>https://qcrao.com/post/where-go-variables-go/</guid><description>写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露，搞得胆战心惊。 切换到Golang后，基本不会担心内存泄露了。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。堆和</description></item><item><title>Golang 之轻松化解 defer 的温柔陷阱</title><link>https://qcrao.com/post/how-to-keep-off-trap-of-defer/</link><pubDate>Tue, 12 Feb 2019 11:08:00 +0800</pubDate><guid>https://qcrao.com/post/how-to-keep-off-trap-of-defer/</guid><description>什么是defer？ defer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。 defer语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。 defe</description></item><item><title>一个字节的网络漫游故事独白</title><link>https://qcrao.com/post/byte-travel-story/</link><pubDate>Wed, 30 Jan 2019 06:48:00 +0800</pubDate><guid>https://qcrao.com/post/byte-travel-story/</guid><description>大家好，给大家介绍一下，我是一个字节。相比于你们人类据说即将达到的百岁人生的寿命，我的一生简直不直一提（我只能存活零点几个毫秒）。 也许只有那些码农才会了解我，而且也只有一部分码农。那些整天做业务的猿们想来也不会真正的了解我，更别提人类其他行业的人了。 我不甘心，虽然我微不足道，但是</description></item><item><title>深度解密 HTTP 通信细节</title><link>https://qcrao.com/post/dive-into-http/</link><pubDate>Fri, 18 Jan 2019 10:13:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-http/</guid><description>上一篇文章中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的锤子，拿着锤子，看什么都像钉子！在这篇文章中，我对准了HTTP这颗钉子砸下去，咳咳。 为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上</description></item><item><title>“三次握手，四次挥手”你真的懂吗？</title><link>https://qcrao.com/post/dive-into-three-way-handshake/</link><pubDate>Wed, 16 Jan 2019 11:10:00 +0800</pubDate><guid>https://qcrao.com/post/dive-into-three-way-handshake/</guid><description>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！ 作为程序员，要有“刨根问底”的精神。知其然，更要</description></item><item><title>归档</title><link>https://qcrao.com/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qcrao.com/archives/</guid><description/></item><item><title>搜索</title><link>https://qcrao.com/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qcrao.com/search/</guid><description/></item></channel></rss>